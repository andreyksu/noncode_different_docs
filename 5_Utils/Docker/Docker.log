Docker

Если цель виртуалки — полностью воспроизвести устройство компьютера, то основная цель Docker — создать среду для одного приложения.
Виртуальная среда контейнера запускается внутри операционной системы. Ей не нужно виртуализировать оборудование — она использует его через ОС.


В поставку Docker входят следующие компоненты:

    Docker host — это операционная система, на которую устанавливают Docker и на которой он работает.
    Docker daemon — служба, которая управляет Docker-объектами: сетями, хранилищами, образами и контейнерами.
    Docker client — консольный клиент, при помощи которого пользователи взаимодействуют с Docker daemon и отправляют ему команды, создают контейнеры и управляют ими.
    Docker image — это неизменяемый образ, из которого разворачивается контейнер.
    Docker container — развёрнутое и запущенное приложение.
    Docker Registry — репозиторий, в котором хранятся образы.
    Dockerfile — файл-инструкция для сборки образа.
    Docker Compose — инструмент для управления несколькими контейнерами. Он позволяет создавать контейнеры и задавать их конфигурацию.
    Docker Desktop — GUI-клиент, который распространяется по GPL. Бесплатная версия работает на Windows, macOS, а с недавних пор и на Linux. Это очень удобный клиент, который отображает все сущности Docker и позволяет запустить однонодовый Kubernetes для компьютера.


	можем создавать образы, в которых находятся наши приложения;
	можем создавать контейнеры из образов, для запуска приложений;

Docker image (образ). 
	Это шаблон, по которому создают контейнеры. Его часто сравнивают со слоёным пирогом: мы накладываем слой файловой системы поверх слоя базового образа и получаем неизменяемый образ.
	В него можно установить приложение, конфигурации и зависимости. Другие образы могут наследоваться, поэтому если положить сверху слой файлов и закоммитить, то мы получим ещё один неизменяемый образ.
	Dockerfile. Если Docker image — это пирог, то Dockerfile — рецепт его приготовления. В этом файле описаны основные инструкции для сборки образа: какой базовый образ взять, откуда и куда положить файлы и так далее.


    Образ — это набор файлов, необходимых для работы приложения на голой машине с установленным Docker.
    Образ состоит из неизменяемых слоев, каждый из которых добавляет/удаляет/изменяет файлы из предыдущего слоя.
    Неизменяемость слоев позволяет их использовать совместно в разных образах.

    By default all files created inside a container are stored on a writable container layer that sits on top of the read-only, immutable image layers.
		- Data written to the container layer doesn't persist when the container is destroyed. This means that it can be difficult to get the data out of the container if another process needs it.
		- The writable layer is unique per container. You can't easily extract the data from the writeable layer to the host, or to another container.

Контейнер — это runtime-сущность на основе образа, приложение, которое мы развернули с помощью Docker.
	Контейнер — запущенный процесс операционной системы в изолированном окружении с подключенной файловой системой из образа.
	Повторюсь, что контейнер — всего лишь обычный процесс вашей операционной системы. Разница лишь в том, что благодаря возможностям ядра (о них в конце) Докер стартует процесс в изолированном окружении. Контейнер видит свой собственный список процессов, свою собственную сеть, свою собственную файловую систему и так далее. Пока ему не укажут явно, он не может взаимодействовать с вашей основной операционной системой и всем, что в ней хранится или запущено.

	Можно провести такую аналогию: образ — это инсталлятор программы, а контейнер — уже запущенная программа.
	При развёртывании контейнера поверх файловой системы создаётся ещё один изменяемый слой. Приложение внутри контейнера может записывать туда данные или редактировать их. После удаления контейнера данные стираются

	Docker-контейнер строится на основе образа. Суть преобразования образа в контейнер состоит в добавлении верхнего слоя, для которого разрешена запись. Результаты работы приложения (файлы) пишутся именно в этом слое.	
	Можно провести и обратную операцию: из контейнера сделать образ. Верхний слой контейнера отличается от остальных только лишь разрешением на запись, в остальном это обычный слой — набор файлов и директорий. Делая верхний слой read only, мы преобразуем контейнер в образ. 

	Механизм такой: из базового образа создается контейнер (добавляется ему слой для записи), выполняется инструкция в данном слое (она может добавлять файлы в слой для записи: COPY или нет: ENTRYPOINT), вызывается команда docker commit и получается образ. Процесс создания контейнера и коммита в образ повторяется для каждой инструкции в файле. В итоге в процессе формирования конечного образа создается столько промежуточных образов и контейнеров, сколько инструкций в файле. Все они автоматически удаляются после окончания сборки конечного образа.

	Докер при необходимости автоматически скачивает образ (первый аргумент после docker run) и на основе него стартует контейнер с указанной командой.


	Основной подход использования Docker
		Каждый запущенный контейнер — атомарный сервис. Другими словами каждый контейнер представляет из себя ровно одну программу, будь то веб-сервер или приложение.
			Docker содержит механизмы, для хранения и использования данных лежащих в основной файловой системе.

	После остновки контейнера и повторного запуска - все изменения выполненные в файловой системе контейнера - будет доступны.
		docker run -it --name container1 ubuntu bash  
		touch /data.txt  
		exit 

		docker start container1  
		docker exec container1 ls /  # Shows data.txt  


Docker Registry. 
	Это репозиторий, в котором хранятся Docker-образы. Он может быть как локальным, так и публичным.
	Репозитории создают на платформах вроде Docker Hub и GitLab и размещают в них образы с описанием, разными версиями и тегами.


В стандартной поставке Docker Compose есть механизм, который позволяет управлять их запуском с помощью конфигурационного файла YAML. 
	В больших приложениях с микросервисной архитектурой используют оркестраторы Kubernetes или OpenShift. Единицей управления в Kubernetes является контейнер Docker, но на голом Docker прод практически никто не держит.
	Kubernetes — это мощный слой абстракции над железом, альтернатива гипервизорам у виртуалок. Он позволяет настраивать политики безопасности, реализует различные схемы обновления и позволяет гибко управлять ресурсами.





Упражнения. Я провожу тренинги и внутреннее обучение в командах. Обычно рекомендую такие упражнения:

    Установите Docker на рабочий компьютер. Возьмите готовый Docker image с Docker Hub с базой данных и запустите на его основе контейнер. Это можно сделать по инструкции, которую производитель image выкладывает на Docker Hub. Затем подключитесь к запущенной БД каким-нибудь клиентом и убедитесь, что всё работает.
    Напишите простенький сервис REST API и Docker-файл для упаковки сервиса в образ, подглядывая в референсы или книгу. Ваша задача — разобраться в теории, получить Docker image и проставить теги.
    Из полученного ранее образа создайте и запустите контейнер. Вам придётся разобраться с параметрами команды Docker run, настройками портов, передачей переменных окружению, монтированием и основными параметрами. Также стоит научиться подключаться к контейнеру, выполнять bash-команды и смотреть логи приложения.
    Усложните тестовый сервис, научив его работать с базой данных. Затем разверните контейнеры с сервисом и базой данных и соедините их внутренней сетью. Простое и в то же время очень полезное упражнение, на котором очень часто возникают затруднения на собеседованиях.
    Переходим к Docker Compose. Посмотрите, как написать YAML и создать группу контейнеров, как соединять их в сеть и работать с маунтами.
    Опубликуйте свой Docker image в Docker Hub. На одном аккаунте можно бесплатно публиковать только один образ, но есть GitLab, где нет таких ограничений. Правда, он устроен немного сложнее, новичок может запутаться. Ещё в том же GitLab можно создать приватный registry-режим и публиковать проекты без ограничений.






Практика Docker: знакомимся с docker-maven-plugin
	mvn verify -Docker_host = localhost

	<profile>
    <id>it</id>
    <activation>
        <property>
            <name>docker_host</name>
        </property>
    </activation>


    Профиль включает плагины maven-failsafe-plugin и docker-maven-plugin.

	Первый необходим для запуска самих тестов:

	<plugin>
	    <artifactId>maven-failsafe-plugin</artifactId>
	    <executions>
	        <execution>
	            <goals>
	                <goal>integration-test</goals>
	                <goal>verify</goals>
	            </goals>
	        </execution>
	    </executions>

	А второй — как раз для запуска зависимостей в контейнерах Docker:

	<plugin>
	<groupId>io.fabric8</groupId>
	<artifactId>docker-maven-plugin</artifactId>
	<version>0.38.0</version>





Когда мы выполняем команду run docker run <image name>, то Docker проверяет наличие указанного образа на локальной машине и скачивает его по необходимости. Список образов, уже скачанных на компьютер, можно посмотреть командой docker images
	Для гарантированного обновления образа существует другая команда: docker pull. Вот она всегда проверяет, обновился ли образ для определенного тега.
	Когда мы выполняли команду docker run nginx, то на самом деле выполнялась команда docker run nginx:latest.



# docker pull <имя_образа>
	Скачать образ можно с помощью команды. После этого образ появится в локальном хранилище и будет готов к использованию.

# docker images
	Проверить список загруженных образов можно командой.

# docker create <имя_образа>
	Эта команда создаст контейнер, но не запустит его. Он будет находиться в неактивном состоянии до момента запуска.

# docker ps -a
	Просмотреть список созданных контейнеров можно с помощью команды

# docker start <container_ID>
	Если контейнер уже был создан, но еще не запущен, используйте команду.

# docker run <имя_образа>
	Cоздать и запустить контейнер одной командой. Вместо docker create и docker start можно сразу использовать команду.

	# docker run --name my_nginx nginx
		Задание имени контейнера, а не дефолтное присваение имени.

	# docker run --rm ubuntu echo "Hello, Docker!"
		Удаление контейнера после выполнения

	# docker run --memory=512m --cpus=1 nginx
		Ограничение ресурсов

	# docker run -it ubuntu bash
		Инерактивный режим

	# docker run -d nginx
		Запуск в фоновом режиме
    
# docker exec -it <container_ID> bash
	docker exec позволяет выполнить команду внутри работающего контейнера.
		docker exec <container_ID> ls / - или непосредственно команду.

		- "docker exec" allows you to run a new command inside a running Docker container.
		- It's primarily used for debugging, inspecting, or modifying the state of a container.
		- The command runs in the container's default working directory.
			-i or --interactive: Keeps the input stream open, allowing you to interact with the container.
			-t or --tty: Allocates a pseudo-TTY, providing a terminal-like experience.
			-w, --workdir		API 1.35+ Working directory inside the container

# docker attach <container_ID>
	Если контейнер запущен в интерактивном режиме, можно подключиться к его основному процессу с помощью команды docker attach


Если закрыть сессию docker attach с помощью Ctrl + C, контейнер остановится. Чтобы выйти, не прерывая работу контейнера, нажмите Ctrl + P, а затем Ctrl + Q.


Удаляются образы командой docker rmi <imagename>.

Запуск для работы в фоне -d 
	docker run -d -p 8080:80 nginx

	Без -d в текущей консоли будет вывод из контейнера.
		Остановить без -d можно Ctrl+C

Просмотр логов контейнера docker logs
	docker logs <container_id>
	docker logs -f <container_id> # Вы также можете подсоединиться к выводу лога в стиле tail -f (Аналог tail -f)

	Выход по ctrl+c но контейнер останется рабочим.

Теперь выведем информацию о запущенных контейнерах командой docker ps
	docker ps -a

Команда docker stats выводит информацию о том, сколько ресурсов потребляют запущенные контейнеры


После остановки контейнер можно даже перезапустить:
	docker start <cont_name/id>
	docker logs

Для запуска интерактивных сессий необходимо указать -it
	docker run -it ubuntu bash

	Для выхода exit, Ctrl+D

	docker run nginx cat /etc/nginx/nginx.conf // Просто выведет и всё, после этого я уже не будут в контейнере.

Но если запустить его так docker run -p 8080:80 nginx, то nginx начнет отвечать на порту 8080.
	Порт 8080 слушается на 0.0.0.0, то есть на всех доступных интерфейсах. Поэтому запущенный таким образом контейнер доступен не только через localhost:8080, но и снаружи машины (если доступ не запрещен как-нибудь еще). Если нужно выполнить проброс только на loopback, то команда меняется на такую: docker run -p 127.0.0.1:8080:80 nginx.

	docker run -p 80:80 -p 443:443 nginx


docker run -it -v ~/.bash_history:/root/.bash_history ubuntu bash # Получается таким образом логи будут доступны из хостовой машины в докере (и при этом не перезаписаны а дописаны)
	Пробрасывать можно как файлы, так и директории. 
		Любые изменения производимые внутри volume меняются как внутри контейнера, так и снаружи, причем по умолчанию доступны любые операции. 
		Как и в случае портов, количество пробрасываемых файлов и директорий может быть любым.

	При работе с Volumes есть несколько важных правил, которые надо знать:
    	- Путь до файла во внешней системе должен быть абсолютным.
    	- Если внутренний путь (то, что идет после :) не существует, то Докер создаст все необходимые директории и файлы. Если существует, то заменит старое тем, что было проброшено.


Переменные окружения
	Существует два способа их установки:
    	Флаг -e. Используется он так: docker run -it -e "HOME=/tmp" ubuntu bash
    	Специальный файл, содержащий определения переменных окружения, который пробрасывается внутрь контейнера опцией --env-file.


# docker stop $(docker ps -aq) && docker rm $(docker ps -aq)
	Остановит все запущенные контейнеры и удалить все контейнеры.

# docker run --rm <image_name>
	Флаг —rm автоматически удаляет контейнер после завершения его работы.

# docker image rm
	# Удалить образ
	# Другие псевдонимы
		docker rmi <image_id_or_name>		
		docker image remove 
		docker rmi


docker container rm
	# Удаление контейнера.
		docker container remove
		docker rm



# docker ps -a --filter "ancestor=<image_name>"
	Получить список всех контейнеров, созданных из определенного образа




Подготовка собственного образа

Создание и публикация собственного образа не сложнее его использования. Весь процесс делится на три шага:

    Создается файл Dockerfile в корне проекта. Внутри описывается процесс создания образа.
    Выполняется сборка образа командой docker build
    Выполняется публикация образа в Registry командой docker push

    docker run -it -v /path/to/js/files:/app my_account_name/eslint



    Создание Dockerfile

		# Dockerfile
		FROM node:9.3

		WORKDIR /usr/src

		RUN npm install -g eslint babel-eslint
		RUN npm install -g eslint-config-airbnb-base eslint-plugin-import #RUN <shell команда>

		COPY eslintrc.yml /root/.eslintrc.yml

		CMD ["eslint", "/app"] # CMD ["команда", "аргумент1", "аргумент2"]

		Dockerfile имеет довольно простой формат. На каждой строчке указывается инструкция (директива) и её описание.


		FROM
			Инструкция FROM нужна для указания образа, от которого происходит наследование. Здесь необходимо оговориться, что образы строятся на базе друг друга и все вместе образуют большое дерево.
			В корне этого дерева находится образ busybox.

		RUN
			Основная инструкция в Dockerfile. Фактически здесь указывается sh команда, которая будет выполнена в рамках окружения, указанного во FROM при сборке образа. Так как по умолчанию всё выполняется от пользователя root, то использовать sudo не нужно (и скорее всего его нет в базовом образе). К тому же учтите, что сборка образа — процесс не интерактивный. В тех ситуациях, когда вы используете команду, которая может запросить что-то от пользователя, необходимо подавлять этот вывод. Например, в случае пакетных менеджеров делают так: apt-get install -y curl. Флаг -y как раз говорит о том что нужно производить установку без дополнительных вопросов.

			Технически образ Докера — это не один файл, а набор так называемых слоев. Каждый вызов RUN формирует новый слой, который можно представить как набор файлов, созданных и измененных (в том числе удаленных) командой, указанной в RUN. Такой подход позволяет значительно улучшить производительность системы, задействовав кеширование слоев, которые не поменялись. С другой стороны, Докер переиспользует слои в разных образах если они идентичны, что сокращает и скорость загрузки и занимаемое пространство на диске.

		COPY
			В соответствии со своим названием команда COPY берет файл или директорию из основной файловой системы и копирует её внутрь образа. У команды есть ограничение. То, что копируется, должно лежать в той же директории, где и Dockerfile. Именно эту команду используют при разработке когда необходимо упаковать приложение внутрь образа.

		WORKDIR
			Инструкция, устанавливающая рабочую директорию. Все последующие инструкции будут считать, что они выполняются именно внутри неё. По инструкция WORKDIR действует, как команда cd. Кроме того, когда мы запускаем контейнер, то он также стартует из рабочей директории. Например, запустив bash, вы окажетесь внутри неё.

		CMD
			Та самая инструкция, определяющая действие по умолчанию при использовании docker run. Она используется только в том случае, если контейнер был запущен без указания команды, иначе она игнорируется.

				Директиву CMD можно опустить. Тогда команду, которая исполнится в контейнере, придется указать вручную.
					docker run -it my-first-image python
						# Запустит интерпретатор Python в контейнере
						# Кстати, если задать команду вручную, она переопределит ту, что указана в CMD. А если не указать CMD вообще, то Docker возьмет ее из базового образа


	Сборка
		Для сборки образа используется команда docker build. С помощью флага -t передается имя образа, включая имя аккаунта и тег. Как обычно, если не указывать тег, то подставляется latest.

		$ docker build -t my_account_name/eslint .

			# Точка после нее соответствует пути сборки (все, что в ней находится является контекстом сборки).
			# При ее запуске клиент docker передает контекст демону, который по инструкциям-директивам начинает собирать образ. Аргумент -t определяет имя образа.
			# docker build . -t my-first-image
			# docker run -it -p "80:8000/tcp" -p "5000:5000/udp" my-first-image

		После выполнения данной команды вы можете увидеть текущий образ в списке docker images. Вы даже можете начать его использовать без необходимости публикации в Registry. Напомню, что команда docker run не пытается искать обновленную версию образа, если локально есть образ с таким именем и тегом.











Docker Compose
	Docker Compose позволяет управлять набором контейнеров, каждый из которых представляет из себя один сервис проекта. Управление включает в себя сборку, запуск с учетом зависимостей и конфигурацию. Конфигурация Docker Compose описывается в файле docker-compose.yml, лежащем в корне проекта, и выглядит примерно так: