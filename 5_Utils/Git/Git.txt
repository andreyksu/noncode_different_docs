Перед сохранением любого файла Git вычисляет контрольную сумму, и она становится индексом этого файла.
	- Фактически, в своей базе данных Git сохраняет всё не по именам файлов, а по хешам их содержимого.

В Git'е файлы могут находиться в одном из трёх состояний: зафиксированном, изменённом и подготовленном.
	"Зафиксированный" значит, что файл уже сохранён в вашей локальной базе.
	Подготовленные файлы — это изменённые файлы, отмеченные для включения в следующий коммит.
	К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.

Каталог Git - это база данных GIT - по сути то что мы получаем когда клонируем репозиторий.
Рабочий каталог - это извлеченная из базы копия определенной версии проекта. Файлы достаются из базы данных GIT на диск для работы с ними.
Область подготовленных файлов - это область в "Каталоге Git" которая говорит что должно войти в след. коммит. (index или staging area)

> Вы вносите изменения в файлы в своём рабочем каталоге.
> Подготавливаете файлы, добавляя их слепки в область подготовленных файлов.
> Делаете коммит, который берёт подготовленные файлы из индекса и помещает их в каталог Git'а на постоянное хранение.

Создать репозиторий для существующего проекта
	git init

Добавить файлы под версионный контроль (т.е. проиндексировать) - выполняется как для новых файлов которые хотим добавить так и после изменения, чтобы изменения попали в коммит.
	git add <list_of_files>  - если указан каталог, то добавляется все рекурсивно.
	
	git add Documentation/\*.txt Note that the asterisk * is quoted from the shell in this example; this lets the command include the files from subdirectories of Documentation/ directory.

Фиксация изменений:
	git commit -m "message"
	
Клонирование репозитория (т.е. получение всех данных репозитория, копия)
	git clone https://github.com/andreyksu/selenium.git
	git clone user@server:/path.git (для клонирования по ssh)
	
Файлы в рабочем каталоге могу быть в двух состояниях:
	отслеживаемые	(те файлы которые были в последнем слепке проекта - snapshot. Могут быть измененными, неизменными, подготовленными к коммиту(staged)).
	неотслеживаемые	(все остальные файлы, кторые не входили в последний слепок, не подготовленнны к коммиту)

Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, т.к. вы изменили их с момента последнего коммита. 
Вы индексируете (stage) эти изменения и затем фиксируете все индексированные изменения, а затем цикл повторяется. 


Для проверки состояния репозитория:
	git status

Для детального просмотра что было измеенено необходимо использовть команды:
	git diff   			- для измененных файлов но не проиндексированных
	git diff --cached - или git diff --staged для просмотра измененных и проиндексированных файлов
		Важно что эти команды испльзуются лишь для соответствюущего состояния (git diff не покажет изменений после индексации)

Фиксация изменений (делает снимок моего рабчего каталога - само собой лишь то что проиндексированно):
	git commit
	git commit -a 	- позволяет автоматом проиндексировать все отслеживаемые файлы и совершить коммит.

Для удаления файла из отслеживаемых, т.е. из репозитория.
	git rm <regexp> - пример git rm -r .idea/ и git rm \*.iml
	git rm -r --cached <regexp> - удаляет из индекса, но оставляет на диске. Полезно когда измененеия в gitignore после git add .
		git rm -f
	
Получение истории репозитория
	git log 		- показывает краткую инфомацию
	git log -p 		- показывает информацию по коммитам детальную
	git log --stat 	- показывает статистику сколько файлов/строк добавлено или удалено
	git log --pretty - меняет формат вывода
	git log --oneline --decorate --graph --all - графическое представление.
						
Изменение последнего коммита:
	git commit --amend
		Пример:
			git commit -m 'initial commit'
			git add forgotten_file
			git commit --amend - т.е. в последний коммит добавим еще и файл. Т.е. меняет последний коммит.
	
Отмена индексации файла:
	restore пришло в замент reset

	git reset HEAD <file> - отменяет индесацию файла.
	git resotre --staged <file> - новый аналог

	git checkout -- <file> - переводит файл в сосотояние из последнего коммита. Все изменения исчезнут и файл будет соответствовать последнему коммиту.
	git restore <file> - новый аналог. Отменяет изменения и приводит к состоянию из коммита.

	Удаление последнего коммита
		git reflog

		reset --hard commit-before-the-merge
			Или
		git reset --hard HEAD~1


Работа с удаленным репозиторием:
	git remote - отобразить репозитории.
		git clone - 1. Автоматически даёт удалённому репозиторию имя origin
					2. Связывает master удалённым master (т.е. делает отслеживаемым)

	git remote -v 			- как я понял отобразит имя удаленного репозитория и его url (как пример origin  http://git.gosuslugi.local/rmis-n2o/mdm-app.git (fetch) какраз origin это псевдоним репозитория, этот псевдоним можно изменить)
	git remote show origin 	- как я понял отобразит ветки в удаленном репозитории.
	
Получение обновлений из репозитория:
	git fetch 	- После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта.
				- Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем origin. Таким образом, git fetch origin извлекает все наработки, отправленные (push) на этот сервер после того, как вы склонировали его (или получили изменения с помощью fetch).
				- Важно отметить, что команда fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.
	
	git pull 	- извлекает (fetch) данные с сервера, с которого вы изначально склонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете. Лучше испльзовать ее а не fetch


	git remote add <aliace-name-for-remote-rep> url
	git fetch <aliace-name-for-remote-rep> т.е. git fetch <remote-server>
	git push <remote-name-rep> <br-name>
	git remote show <remote-name>

Переименование веток.
	git branch --move old_name new_name - переименование ветки.
	git push --set-upstrim <remote-server> new_name - отправка переименования на сервер.
	git push <remote-server> --delete old_branch_name - удаление на сервере старого имени.

Заливка изменений на сервер:
	git push [удал. сервер] [ветка]
		Пример git push <remote-server> master
		Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а затем команду push выполняете вы, то ваш push точно будет отклонён. Вам придётся сначала вытянуть (pull) их изменения и объединить с вашими. Только после этого вам будет позволено выполнить push. 

	git push <remote> <br-name> - или git push <remote> <br_name_local>:<br_name_remote>
	git pull <remote-server>/<br_name> - или git fetch <remote-server>/<br_name> -> git merge <remote-server>/<br_name>


	git checkout -b <br_name_local> <remote-server>/<br_name_remote> - создание ветки на базе ветки слежения.
		или git checkout --track <remote-server>/<br_name_remote>

		Ветка слежения это локальная ветка связанная с удалённой (upstream branch)

	git checkout <br_name> - переключение на ветку. Если есть ветка отслеживания но нет локальной ветки, то создаётся локальная ветка с тем же именем.

	Если есть локальная ветка которую нужно свзяать с удалённой то можно сделать
	git branch <br_local_name>
	git branch -u <remote-server>/<br_remote_name>   (или --set-upstream)



	git push <remote-server> <br> - залить ветку.
	git push <remote-server> <br_local>:<br_remote> - Аналогично но с указанием имён. Наименования текущей ветки и удалённой могут различаться.
			При получении данных создаются ветки слежения, но не создаются автоматом локальные копии веток.
			Получаем только указатель на origin/<br> который нельзя менять.
			По этому нужно:
				git fetch <remote>
				git checkout -b <name_local_br> origin/<name_remote_br> - создаёт локальную ветку.

				git branch -vv

		Ветка слежения это ссылка(указатель) на определённое состояние удалённых веток. Это локальные ветки которые нельзя перемещать. По сути это закладка.
		Имя ветка слежения имеет вид <remote>/<br_name>

Rebase

	git checkout <br>
	git rebase master   (git rebase <base>) This automatically rebases the current branch onto ＜base＞
						 С
						/
				A-----B-----D-----E

	Берётся дельта BC и применяется поверх D И E - как бы смещая место ответвления С с B на E
		Т.е. текущая ветка устанавливается на последний коммит ветки, куда перебазируемся (т.е. на последний коммит мастера) и последовательно применяем коммиты-дельты

									  С'
									/
				A-----B-----D-----E

					Если у С несколько коммитов то дельта считается для каждого коммита в ветке С.

	Дальше если не было конфликтов можно пушить на сервер и там уже мёрджить.
	 Если локльная ветка только была то
	 	git checkout master
		git merge <br>


	git rebase -i HEAD~3  - а это измеенние трёх последних коммитов.


Работа с ветками:
	Git хранит данные как последовательность снимков состояния (snapshot).
	Когда вы создаёте коммит в Git'е, Git записывает в базу объект-коммит, который содержит указатель на снимок состояния, записанный ранее в индекс, метаданные автора и комментария и ноль и более указателей на коммиты, являющиеся прямыми предками этого коммита: ноль предков для первого коммита, один — для обычного коммита и несколько — для коммита, полученного в результате слияния двух или более веток.
	При добавлении файлов в индекс для каждого из них вычислится контрольная сумма (SHA-1 хеш, о котором мы упоминали в главе 1), затем эти версии файлов будут сохранены в Git-репозиторий (Git обращается к ним как к двоичным данным), а их контрольные суммы добавятся в индекс.
	https://git-scm.com/book/ru/v1/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B2%D0%B5%D1%82%D0%BA%D0%B0%3F
	
	Ветка это лишь именнованный указатель на коммит. А HEAD это указатель/индикатор того на какой ветке я нахожусь(текущей ветке)
			 _ _ _ _ _ _master
			/
	--------
			\
			 - - - - - - testing
	git branch testing 		- создание ветки testing
								Ветка это просто указатель для перемещения.
								HEAD - указатель на ветку на которой находимся.

	git branch 				- отображает ветки
	git branch --merged		- покажет слитые ветки с master но еще неудаленные.
	git checkout testing	- переключение на ветку.
		Или git switch master

	Создать ветку и переключиться git switch -c <new-branch> или в старом стиле git checkout -b <new-branch>
	
	git checkout -b testing	- создает ветку и переходит на нее.
	При переключении между ветками все изменения и индексы должны быть закоммичены.
	
	Для сливания ветки с master
		git checkout master		- переключились в master или
		git merge testing		- сливаем в мастер данные из ветки.
		git branch -d testing	- удаляем ветку, так как нам не нужна, master указывает на нее. Ибо мы слили их.
	
	Для слития в ветку мастера а не наоборот как был в примере выше
		git checkout testing
		git merge master		- т.е. образом мы слили в ветку testing все из master
	
#Клонировать
git clone http://[npovs.username]@bb.npovs.ru:7990/scm/ncuorf/r50-sandbox.git
#Создать ветку NCUORF-18813
git checkout -b NCUORF-18813
#или
git branch NCUORF-18813
#Выбор/переключение между ветками
git checkout NCUORF-18813
git checkout master
#Удалить ветку NCUORF-18813
git branch -D NCUORF-18813
#Связать локальную ветку с уделенной (нужно например для rebase)
#c веткоой origin/NCUORF-18813
git branch --set-upstream-to=origin/NCUORF-18813
#с веткой origin/master
git branch --set-upstream-to=origin NCUORF-18813
#Показать все ветки включая удаленные
git branch -a
#только удаленные
git branch -r
#только локальные
git branch
#Обновить изменения из удаленного репозитория c rebase изменений в ветке origin/master :
git pull --rebase origin master
#Отправить на сервер изменения ветки NCUORF-18813 на точку монтирования origin
git push origin NCUORF-18813
  
#Отправить
# на сервер изменения ветки NCUORF-18813 на точку монтирования origin со
#всеми коммитами из NCUORF-18813 то есть делает в origin все так же как и
# у вас на локальной ветке включая коммиты. Использовать когда в вашей ветке на сервере оказалось несколько коммитов.
git push origin NCUORF-18813 --force
#Локальный коммит с добавление всех файлов
git commit -a
  
#локальный коммит интерактивный режим - позволяет гибко выбирать что добавить в коммит
git commit --interactive
#Объединение нескольких локальных коммитов в один для того, что бы на сервер ушел 1 коммит.
git rebase -i master
  
#делаем rebase в интерактивном режиме.
#Позволяет объединить истрию коммитов в 1.
#видим список коммитов начинаеся с pick (порядок от нового к старому)
#Нужно заменить у старых комитов pick на squash - это сольет комиит с более новым.
#Сохраняем. Если все прошло успешно, то git log покажет новый объединенный коммит.
 
#если так вышло, что у вас в ветке на сервере уже несколько коммитов их можно объединить в один локально, затем форсированно запушить на сервер новое содержимое ветки
git push origin NCUORF-18813 --force
#история коммитов в текущей ветке
git log
  
#статус индекса в текущей ветке
git status