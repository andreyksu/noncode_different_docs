graphite postgresql - для мониторинга за БД.  (http://eax.me/graphite-statsd-collectd/)
BMC TrueSight - еще одно средство
Zabbix - в представлении не нуждается



Отобразить топ запросов(количество запросов и время их выполнения)
	select queryid,query from pg_stat_statements where queryid in (4248211384,3054902337);
	
Важно знать какие запросы выполняются в данный момент, какой процесс их выполняет и сколько запрос уже работает. У PostgreSQL есть отличная служебная табличка pg_stat_activity.
		select now() - query_start, pid, waiting, query from pg_stat_activity where state != 'idle' order by 1 desc;
		select now() - query_start, procpid, waiting, current_query from pg_stat_activity where current_query != '<IDLE>' order by 1 desc; (для Postgresql-9.1)
	Задача: увидеть какие запросы в данный момент исполняются в базе данных.
	Проблема: pg_stat_activity показывает текущие запросы не полностью(обрезает).
	Решение: gdb.
		Возможно, у этой задачки есть решение проще, но мы его не нашли. Берем PID из запроса выше и подключаемся к нему
			gdb [path_to_postgres] [pid]
		и после того как подключились к процессу выполняем
			printf "%s\n", debug_query_string	
	
Задача: Мониторить медленные запросы
Проблема: Хочется сделать это на уровне базы данных
Решение: log_min_duration_statement
	Настройка log_min_duration_statement задается в миллисекундах, и логирует все запросы к базе, которые исполнялись дольше заданного значения.	
	Давайте поправим конфиг PostgreSQL vim /var/lib/pgsql/9.4/data/posgresql.conf и поставим в нем 3 секунды как пороговое значение
		log_min_duration_statement = 3000 
	Чтобы изменения вступили в силу не обязательно перезагружать базу, достаточно выполнить команду из psql, pgadmin или другого интерфейса к базе
		SELECT pg_reload_conf();
	или выполнить из командной строки
		su - postgres
		/usr/bin/pg_ctl reload
	Нужно помнить, что некоторые параметры в конфигурационном файле вступят в силу только после перезапуска базы данных.
	И после этого можно посмотреть в лог PostgreSQL, который у нас находится по такому пути /var/lib/pgsql/9.4/data/pg_log/postgresql-2015-07-07.log и здесь видно, что есть запрос который исполняется почти 6 секунд.
		2015-07-07 09:39:30 UTC 192.168.100.82(45276) LOG:  duration: 5944.540 ms  statement: SELECT * FROM application_devices WHERE applicationid='1234' AND hwid='95ea842e368f6a64' LIMIT 1
	Как вариант в дальнейшем, чтобы мониторить лог-файл можно сделать связку logstash+elasticsearch+kibana и сразу слать через zabbix уведомление о появление медленных запросов, если это является критичным для проекта.
	
Задача: узнать, что делает процесс(как пример какие запросы шлет в базу)
Проблема: процесс нельзя прерывать или останавливать.
Решение: strace
	Для этого достаточно взять pid процесса указать длину и добавить опцию -T. В итоге вывод strace может быть примерно таким
		strace -p 27345 -s 1024 -T 2> out
	gettimeofday({1437846841, 447186}, NULL) = 0 <0.000004>
	sendto(8, "Q\0\0\0005SELECT * FROM accounts WHERE uid='25143' LIMIT 1\0", 54, MSG_NOSIGNAL, NULL, 0) = 54 <0.000013>
	poll([{fd=8, events=POLLIN|POLLERR}], 1, -1) = 1 ([{fd=8, revents=POLLIN}]) <0.000890>

	
	
Здесь все запросы сгруппированы, то есть статистику мы получаем не по каждому запросу, а по группе одинаковых с точки зрения pg запросов.
-Я долгое время считал, что запросы группируются по реальному плану выполнения. Смущало только то, что запросы с разным количеством аргументов в IN отображаются отдельно, план то у них должен быть одинаковый.
-В коде видно, что на самом деле берется хэш от "значимых" частей запроса после синтаксического разбора. Начиная с 9.4 он выводится в колонке queryid.
-На практике нам приходится дополнительно нормализовывать и группировать запросы уже в агенте. Например, разное количество аргументов в IN мы схлопываем в один плейсхолдер "(?)". Или аргументы, которые прилетели в pg заинлайнеными в запрос мы сами заменяем на плейсхолдеры. Задача усложняется еще и тем, что текст запроса может быть не полным.
-До 9.4 текст запроса обрезается до track_activity_query_size, c 9.4 текст запроса хранится вне разделяемой памяти и ограничение убрали, но мы в любом случае обрезаем запрос до 8Кб, так как если в query лежат очень увесистые строки, запросы от агента ощутимо нагружают постгрес.

Все счетчики растут с момента старта или с момент сброса счетчиков (pg_stat_statements_reset).
	query — текст запроса
	calls — количество вызовов запроса
	total_time — сумма времен выполнения запроса в миллисекундах
	rows — количество строк возвращенных (select) или модифицированных в ходе запроса (update)
	shared_blks_hit — количество блоков разделяемой памяти, полученное из кэша
	shared_blks_read — количество блоков разделяемой памяти, прочитанное не из кэша
		В документации не очевидно, это суммарное количество прочитанных блоков или только то, что не нашлось в кэше, проверяем по коду
	shared_blks_dirtied — количество блоков разделяемой памяти, промаркированных как "грязные" в ходе запроса (запрос изменил хотя бы один кортеж в блоке и данный блок необходимо записать на диск, это делает или checkpointer или bgwriter)
	shared_blks_written — количество блоков разделяемой памяти записанное на диск синхронно в процессе обработки запроса. Постгрес пытается синхронно записать блок, если он уже вернулся "грязным".
	local_blks — аналогичные счетчики для локальных с точки зрения backend блоков, используются для временных таблиц
	temp_blks_read — количество блоков временных файлов считанных с диска.
	Временные файлы используются для обработки запроса когда не хватает памяти, ограниченной настройкой work_mem
	temp_blks_written — количество блоков временных файлов записанных на диск
	blk_read_time — сумма времени ожидания чтения блоков миллисекундах
	blk_write_time — сумма времени ожидания записи блоков на диск в миллисекундах (учитывается только синхронная запись, время затраченное checkpointer/bgwriter здесь не учитывается)
		blk_read_time и blk_write_time собираются только при включенной настройке track_io_timing.
		

		
http://evtuhovich.ru/blog/2013/06/28/pg-stat-statements/


Статистика запросов и pg_stat_statements

Иногда при эксплуатации проекта возникает вопрос, какие запросы в БД выполняются дольше всего или потребляют наибольшее количество времени или ресурсов.

До версии 9.2 неплохой ответ на этот вопрос можно было получить с помощью проекта pgBadger. Если прорваться через достаточно простую процедуру его настройки, описанную в документации, то в результате можно получить достаточно красивый
отчет. К сожалению, этот подход имеет достаточно много слабых сторон. Во-первых, чтобы получить полную картину, необходимо писать логи всех запросов к БД, которые при значительной нагрузке отъедают огромное количество дискового пространства, а также производительность дисковой подсистемы. Во-вторых, в сухом остатке получается только суммарное время исполнения всех запросов и их количество. Это полезная информация, но хотелось бы знать много чего еще.

Такого же результата можно добиться с помощью сбора статистики на стороне клиента, например, так это сделано в newrelic.

Модуль pg_stat_statements появился в PostgreSQL уже достаточно давно, но только в 9.2 он научился «нормализовать» запросы, объединяя запросы, которые отличаются только параметрами, в один.

Чтобы воспользоваться этим модулем, необходимо добавить следующую строчку в postgresql.conf.

shared_preload_libraries = 'pg_stat_statements'         # (change requires restart)

После чего необходимо перезапустить сервер БД. После этого в БД, выполните следующую команду:

CREATE EXTENSION pg_stat_statements

После этого в БД, где вы выполнили эту команду, появится представление (view) pg_stat_statements.

$ psql dbname
dbname=# \x
Расширенный вывод включен.

doman=# select * from pg_stat_statements;

userid              | 10
dbid                | 16388
query               | SELECT  "words".* FROM "words"  WHERE "words"."id" = ? LIMIT ?
calls               | 27
total_time          | 0.277
rows                | 27
shared_blks_hit     | 76
shared_blks_read    | 6
shared_blks_dirtied | 0
shared_blks_written | 0
local_blks_hit      | 0
local_blks_read     | 0
local_blks_dirtied  | 0
local_blks_written  | 0
temp_blks_read      | 0
temp_blks_written   | 0
blk_read_time       | 0.051
blk_write_time      | 0

Для того, чтобы показывались последние две строчки, необходимо включить trackiotiming, для чего надо добавить в postgresql.conf следующую строчку.

track_io_timing = on

Давайте внимательнее посмотрим на вывод этого запроса. userid — это id пользователя, который выполнял запрос, dbid — id базы данных, в которой выполнялся этот запрос. Узнать его можно, выполнив select oid, * from pg_database. Далее следует нормализованный запрос (query), количество вызовов (calls), общее время выполнения всех вызовов (total_time).

Все это можно было узнать и из pgBadger, а вот дальше начинаются вкусности:

    rows — суммарное количество вовзращенных строк;
    shared_blks_hit — количество страниц, которые были в кэше БД;
    shared_blks_read — количество страниц, которые были прочитаны с диска, чтобы выполнить запросы такого типа;
    shared_blks_dirtied — количество страниц, которые были изменены;
    shared_blks_written — количество страниц, которые были записаны на диск;
    local_blks_hit, local_blks_read, local_blks_dirtied, local_blks_written — то же самое, что предыдущие 4, только для временных таблиц и индексов;
    temp_blks_read — сколько страниц временных данных было прочитано;
    temp_blks_written — сколько страниц временных данных было записано (используется при сортировке на диски, джойнах и других временных операциях);
    blk_read_time — сколько времени суммарно заняло чтение с диска;
    blk_write_time — сколько времени суммарно заняла запись на диск.

Вооружившись такой статистикой и вашим ясным аналитическим разумом, можно значительно увеличить производительность вашей БД.

Конечно, такая красота достается не бесплатно, pg_stat_statements создает дополнительную нагрузку на БД. Неплохой анализ этой нагрузки есть в конце этой отличной статьи.
