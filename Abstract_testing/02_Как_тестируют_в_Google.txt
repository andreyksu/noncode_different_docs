(Альберто Савоя)
	Качество не имеет значения, пока ваш продукт не имеет значения

Джеймс Уиттакер - основной автор, он же и пришел из Microsoft
	Соавторы:
		Джейсон Арбон
		Джефф Каролло
Патрика Коупленда - директор по тестированию. Является основоположником всех изменений. В том числе стоит над Джеймс Уиттакер.


Глава_1 Знакомство с организацией тестирования в Google
	* Группа тестирования называется - направлением продуктивности разработки
	* По тексту идет в контексте то что тестирование десктоп от того, что разрабатывает Google отличается.	
	* Тестирование не должно быть: догматичным, трудоемким, сложно выполнимым и занимающим много времени.
	* Дефицит приносит ясность.  Не набирайте слишком много тестеров - дефицит заставляет ценить ресурсы тестирования и относиться к ним с уважением.
	
	- Тестированием занимаются сами разработчики 
		* За качество отвечают разработчики. Пишутся тесты на ранней стадии тем самым повышается качеств ПРЕДОТВРАЩЕНИЕМ а не исправлением.
			+ Прежде всего пишутся тесты самими разработчиками. Все ошибки выявленные это недоработка на этапе разработки и раннего тестирования.
		* Проблема в качестве это проблема всего коллектива - начиная от проектирования заканчивая рук. проектов итд.
		* Тестирование =/= качество. 
			+ Тестирование не приносит качество, оно лишь обнажает его отсутствие. Да они переплетены очень сильно, но оно не является качеством. Но без него невозможно сделать качественный продукт.
			+ Найденные проблемы - лишь возвращают нас на доработку, т.е. мы вынуждены возвращаться назад и еще раз дорабатывать.
		* Цель была объеденить тестирвоание и разработку.
			+ Уйти от цикла немножко пишем, немножко тестируем.
			+ Слияние процесса тестирования и разработки.
	
	- Роли
		* Разарботчик
			+ Пишет код, пишет тест на функциональные тесты (т.е. цель - прирост функциональности и фич), проектирует, провдит код-ревью итд.
			+ Отвечает за качеств фич отдельно от всего остального. Ответственрны за архитектуру, за устойчивость к ошибкам и восстанавливаемость после ошибок и сбоев.
		* Разработчик в тестировании
			+ Тоже пишет код, но фокусируется на тестируемости кода и на создании инфраструктуры тестирования(заглушки-stub, подставные объекты - mocks, имитация - fakes).
			+ Отправляют код в репозиторий тоже они.
			+ Выполняет рефакторинг, что бы сделать код тестируемым, пишет фраемворки тестирования итд.
			+ Работает с тем же кодом, но заинтересован в покрытии тестами кода, повышении производительности а не на добавлении фич. Следят, что бы разработчики не ленились писать тесты.
		* Тестировщик
			+ На переднем плане пользователь а не разработка.
			+ Пишут автотесты, скрипты сценариев и имитируют действия пользователя.
			+ Организует работу по тестированию, управляет выполнением тестов и интерпретирует результаты тестов.
			+ Эксперт по продукту
			+ Оценивает риски.
			
	- Организационная структура.
		* Гр. тестирования не относится к гр. разработке. А является параллельной структурой. Что позволяет добиться независимости в принятии решений итд.
		* Тестировщик на проект назначает рук. направления продуктивности.
		
	- В гугл не стремятся поставить как можно больше фич, а выпускают функционал с минимальной фукнциональностью но при этом рабочей и полезной для пользователей.
		* Канареечный канал - тут пользутся только разработчики и тестировщики. Если не удовлетворяет, то канарейка умирает.
		* Канал разработки - если сборка прожила в канареечном канале неделю, то она переходит на этот уровень
			+ Участники начинают пользоваться этим продуктом каждый день. Обязаны использовать в своей работе каждый день. Если не удовлетворяет то обратно в канареечный канал.
		* Тестовый канал - попадает лучшая сборка месяца.
			+ Использует вся компания. Могут отдать внешним заказчикам для тестирования.
		* Бета или канал выпуска.
			+ Стабильные сборки прошедшие три предыдущих пункта. Это первые сборки, что доступны пользователям.
	
	- Ушли от модульного, интеграционного и системного тестирования
		* Ввели понятие мелкий, средний и крупный тест - лишь по количеству проверяемого кода. Мелкий один метод. Средний два метода и их взаимодейтсвие. Крупный много методов.

Глава_2 Разработчики в тестировании
	(стр.45)
	- Разработчик пишущие тесты и тестировщик пишущий тесты имеют разные подходы при написании. Тестировщик пишет разрушающий тест, а разработчик тест ориентированный на корректность
		* Пока разработчики пишут код, разработчики в тестирвоании пишут тесты и фраемворки для тестов.
		* Программист - функциональные тесты. Тесты направленные на проверку функциональности, сценарии испльзования, последовательность действия
			+ Разработчики часто погружены в разработку фич и их полезности и часто воспринимают продукт очень узко.
		* Программист в тестировании - код который выявит случаи мешающие эффективной работе пользователя и его действиям. Поддержка инфраструктуры тестов (заглушки, провайдеры итд) чтобы разарботчик не отвлекался от создания функционала и фич. Помогает писать больше юнит-тестов. Помогают поддерживать большие инфраструктуры для тестов, позволяющие выявить больше проблем.
		  Разработчики в тестировании вовлечены в создание больших сборок и определяют где нужно писать мыле тесты. И по мере роста этой сборки пишутся средние тесты.
			+ Держит в голове общую картину со всеми его фичами (по сравнению с другими инженерами они обладают самым широким представлением о продукте)
			+ Выявляют общие схемы для повторного использованя кода и взаимодействия компонентов.
		* И инженер по тестированию - сценарии использования, пользовательские истоории, исследовательсоке тестирования. Как различные фичи связываются воедино и образуют единое целое. Работают над проблемой всей системы и обычно принимают точку зрения пользователя, проверяя действительно ли совокупность частей образует что-то полезное. Они же пишут автоматизацию в привычном для нас понимании.
	
	- Все инструменты, код, библиотеке в единном репозитории и в общем доступе.
		* Инструменты и все остальное максимально унифицированно.
		* Все участники знают среду как свои пять пальцев, каждый может запустить тест, просмотреть исходники, поправить что-то через рефакторинг кода итд.
		* Переход из проекта в проект является безболезненым, так как все стандартизированно и знакомо.
		* Разработчик HTML может просмотрить код разработчика Браузера и тд.
			+ По максимому поддерживается повторное использование кода/уже написанных библиотек.
			+ Для написания своего, должна быть веская причина.
			+ Код должен быть легко читаемым и легко используемым - основное требование.
			+ Основное внимание выделяется код-ревью (C++, Java, Python, JS), выделяются люди, что занимаются рефакторингом.
		* У всех одна ОС с минимальными различиями, от сюда одна среда что позволяет легко воспроизводить дефекты.
		* У всех одна версия компилятора, который так же собирается и централизованно поставляется.
	
	- Разработчик в тестировании это прежде всего разработчик
		* Позволяет подключать тестирование на самом раннем этапе. См. выше (а именно код пишется с учетом его тестируемости, архитектуры итд)
			+ Тесты еще одна фича продукта.
		* Разработчик в тестировании на собеседовании отвечает на те же вопросы что и обычный разработчик но плюс еще на вопросы по тестированию в части тестирования кода.
	
	- В гугле есть 20% работа над др. проектом Google или же над экспериментами или новыми проектами.
		* Часть из новых проектов стартует (Gmail и Chrome OS), а чать так и умирают, а часть становится новой фичей уже существующего или нового проекта.
		* При этом тестировщики подключаются на этот проект только по согласованию. Т.е. когда проект начинает быть значимым. Иначе можем выбросить время в пустую.
			+ Браться за качество когда концепция продукта не дозрела и не сформирована до конца - это типичный пример неправильно расстановки приоритетов.
			+ Так же не стоит слишком рано заниматься глобальной автоматизацией или же писать большие тесты - они всеравно потерятю значимость так как все сильно меняется, да и время и силы на  поддержку из за изменений будет слишком большими.
			+ Лучше в самом начале браться за маленькие и легковесные тесты.
			+ С др. сороны, браться за тестирование слишком поздно так же не допустимо. Так как будет сложно и дорого менять архитектуру.
		
	- Проектная документация
		* На ранней фазе разумно вести документацию и структурировать процессы (но не нужно все досканально описывать и тратить на это много времени, так как может закончиться тем, что все изменится итд).
		* У каждого проекта есть документация и она развивается вместе с проектом.
		* По сути подобной работой должен заниматься в нашем случае Ильдар Гиматдинов (испльзуемые протоколы и интерфейсы, архитектура проекта/модулей)
		
	- Документ по автоматизации
		* Документ должен содержать не только описание используемых инструментов и описнаие как др. участники будут получать информацию по качестве, какие механизмы оценки качства итд.
		
	- Отправка кода в репозиторий
		* Код отправленный в репозиторий проходит цикл тестирвоания, статическим анализатором, и код-ревьювером. При этом создается очередь на коммит. Т.е. тем самым нет гонок.
		
	- Как ранее писалось, в гугл разделены тесты на три вида
		* Малые 	- (выполняеются мгновенно, проверяют только отдельные классы и методы - вне Google называются UnitTest)
		* Средние	- (требуют заглушки сервисов или др. имитации - выполняются дольше - вне Google называются Интеграционными)
		* Большие	- (прогон системы как еденной целой, задействуют все системы от UI до БД - занимают много времени - вне Google называются системные тесты или сквозные тесты)
		От сюда можно планировать какие тесты запускать в ту или иную минуту.		
			+ Малые тесты проще локализовывать проблемы, средние - локализация занимает больше времени и возростает время для детерменирования проблемы, ну и для системных еще сложнее
			+ В начале проекта идет следующий процент 70/20/10
		
	- Рекомендации к выполнению тестов:
		* Независимость между тестами (включаем рандомный режим выполнения тестов + выполнение тестов в параллельном режиме)
			+ Здесь нужно избегать зависимость на одну базу данных или требование предоставить один порт для разных тестов. В таком случае должен быть пул ресурсов которые выдает система тестирования выполняемым тестам.
		* После завершения тестов система возвращается в исходное состояние (ну или перед начало следующей итерации).
		
	- Для привлечения разработв. к тестам и заинтересованности их в тесировании в Google ввели сертификацию. Всего 5ть уровней как во всех IT сертификатах. 
		* За чистоту и читаемость кода дается первый уровень итд.
		
Глава_3 Инженер по тестированию:
	- Инженеры по тестированию играют другую роль — они ориентированы на «человеческую сторону»: как пользователи будут взаимодействовать с приложением и какие проблемы при этом могут возникнуть. Им, как и большинству технических специалистов в Google, нужно уметь программировать.	
		* Тестировщики работают с документами и артефактами, которые имеют определенный срок годности: на ранних стадиях они пишут тест-планы, позднее создают и выполняют тест-кейсы, формируют баг-репорты.
		* Среди всех тестовых документов у тест-планов самый коротий срок жизни.
			+ Тест-план сровно плюшевый мишка, везде берем с собой, но при этом не играем, а если потеряли или не взяли то рыдаем как дети.			
			+ Для поддержки тестов требуется огромная бюрократия и она оправдана только в том случае когда к этому документу регулярно обращаются.
				# Этот документ рождается вместе с проектом, живет и взрослеет свместе с ним, обновляется при каждом обновлении кода и описывает проект в его тек. виде а не в том виде в ктором он был на начальном этапе.
		* Еще позже тестирвщики составят отчеты о покрытии кода тестами и соберут отзывы у пользователей.
		
	- Тест-план
		* Он всегда актуален
		* Он объясняет назначение продукта и то, почему пользователи его используют(полюбят)
		* Он описывает структуру проекта с названиеми отдельных компонентов и фич.
		* Он описывает, что будет делать продукта и как именно он это будет далеть.
		* Он должен описывать то что надо протестировать
		* Должен помогать оценивать тестирвоание и выявлять проблемы в прокрытии.
		
	- Рекомендации
		* Избегайте повествования, пишите списки (цели создания продукта или потребноств в тестирвоании)
			+ Нет абзатцам.
		* Не лейте воду (у тест-плана нет четко определенного объема)
		* Если какой-то пункт не важен не включайте его (ни один пункт в тестплане не должен вызывать у читателя мыслей - это для меня не важно)
		* Пишите от общего к частному (какждый раздел должен расширять прередущий, что бы у читателя в голове формировалась целостная картина проекта)
		* Итогом тест-плана должен стать набор тест-кейсов.
			+ Если тест-план не описывает какие тест-кейсы мы должны писать, это бесполезный тест-план.
		
	- ACC
		* Attribute - имя прилагательное или наречие. Описываем цели и назанчение продукта.
			+ Это качества и характеристики что продвигает наш продукт. То почему им пользователи будет пользоваться, захотят использовать.
				# Быстрый, надежный, легкий. Прочно, надежно, быстро, лекго, интуитивно.
				# Порядка 10-20 пунктов.
		* Component - существительное. Определяем фичи и части продукта.
			+ Кирпичи из чего состоит продукт, компонент, т.е. то с чем пользователь будет взаимодействовать, через что будет достигать поставленных целей.
				# Порядка 10-20 пунктов не более. И то 20 многовато.
		* Capability - глагол, расскажет, что продукт способен сделать или что с ним может сделать пользователь.
			+ Это реация ПО на действия/запросы пользователя. Ожидания, операции действия, все что выполнняет приложение.
			+ По описанию в книге, это есть пересечение Атрибутов и Комопнентов. 
				# Но как то для меня это не прозрачно. Пример (добавить/удалить товар из карзины - это пересечение "Корзина" и "интуитивный") - не всегда так и не факт что это пересечение даст именно это действие. Или (получить данные кредитных карт и верификация - пересечение Корзина, удобный и интегрированный).
			+ Тут может быть около сотни и более пунктов. Как минимум на одно действие один тест-кейс.
			+ Возможность не должна быть аналогом тест-кейса. Не должно быть подробностей.
				# Но при этом возможность должна подводить при ее просмотре на: какие входные данные, переменные, окружение итд.
	
	- Риски:
			+ О каких событиях нам следует беспокоиться?
			+ Насколько такие события вероятны?
			+ Каким может быть от них ущерб для нашей компании?
			+ Каким может быть от них ущерб для будущих пользователей?
			+ Есть ли в программе защита от возникновения нежелательных событий?
			+ Какова вероятность того, что такая защита не сработает?
			+ Во сколько нам обойдется такой сбой защиты?
			+ Насколько сложно будет восстановиться после такого сбоя?
			+ Нежелательное событие может случиться вновь или эта проблема может быть одноразовой?
		* Не нужен математический расчет, важен факт и примерная и понятийная оценка, что риск имеет место быть и к чему он может привести.
			+ Частота сбоев
				# Очень редко
				# Редко
				# Иногда
				# Часто
			+ Степень воздействия
				# Минимальный
				# Небольшой
				# Существенный
				# Максимальный
		
		Итого:
			У насе есть сущности, с которорыми выполняются действия, у каждого действия есть риск. Здесь стоит видимо делать некоторые матрицы. Тем самым определять вес, тех или иных проверок.
		
	- Снижение рисков:
		* Риски полностью не получается устранить, но как правило их удается минимизировать.
			# Проработка пользовательских историй вокруг наиболее рискованных возможностей.
			# Определить самые болезненные пути и попросить программистов внести в эту часть как можно больше проверок.
			# Добавить регрессионный тест, дабы исключить его проявление в дальнейшем.
		* К тестирвоанию стоит подходить от макс. критичности к мин. критичности.
			# Когда спрашивают о готовности продукта хорошо иметь при себе таблицу с критичностью и возможностями, дабы быстро оценить состояние продукта.
		* Для самых рискованных возможностей и пар атрибут/компонент напишите набор пользовательских историй и сценариев использования.
		* Проанализируйте как система ведет себя после возникновения ситуаций с выскоим риском, есть ли восстанавливаемость после факта.
		
	- Пользовательские сценарии/истории
		* Описывают реальные или смоделированные способы - которыми пользователи используют приложение. Они описывают, чего хотят пользователи.
		* Пользователю что-то нужно а истории описывают, как он использует приложение чтобы получить это. Как правило истории описываются более обще, без входных данных, дабы у тестировщика было больше вариантов дял воспроизведения без задания ему рамок. Что позволит проходит тестировщику каждый раз по разному.
		
	- Подход и рекамендации
		* Вообще - есть рекамендация, которая говорит, что нужно писать тест-кейсы в виде общих моментов, что позволит проходит тесты по разному и не будет приводить к нахождению новых дефектов. 
			+ Т.е. много места отводится для исследовательского тестирования или окло того.
			+ С др. стороны при долгой разработке и большой текучке нужен набор что переживет любого участника.
		* Нужно выполнение тестов (и поддержке качества) нужно минимизировать зависимость от конкретных людей.
		* Вытащить тесты что всегда проходят или тесты с низким приоритетом - он должны уйти либо в автотесты либо удалиться.
		* Даже маленькая автоматизация даст понимание по функциональности и работоспособности проекта.
		* Стр. 182 - говорится о притупливании инженеров при постоянном ргрессе.

	- Управление тестировщиками:
		* Воодушевлять но не комнадовать.
		* Технический момент - тест-менеджер и особенно ведущие инженеры должны быть технически сильными.
			+ Им писать прототипы. Они всегда должны стремиться узнать продукт и пльзователй лучше, чем кто либо из команды.
		* Переговоры. Должны вежливо отказывать и уметь вести себя корректно на переговорах.
		* Взаимодействие и внешние коммуникации.
		* Аттестация и оценка персонала
			+ Оценивается раз в крватал и со стороны - что человек сделал за последнее время, что повлияло на качество продукта, для команды или для пользователей.
			+ Не позволяется сотруднику выезжать на прошлых успехах.
	
	- Очень много идет про описание инструментов и как они используют свои приложения и инструменты.
	
	- Google Test Analytics (GTA)
		* Как писал ранее, хорошо соединять АСС и GTA. Т.е. приоритеты и риски указывать для возможностей и для свойств. По сути это обычная приоритезация.
		
	- Партрет тестировщика в Google
		* Инициативен - сами предлогают много что.
		* Общителен имеет лидерские качества.
		* Сам на собеседовании задает много вопросов.
		
	- Подходи
		* Как можно раньше начинают пользоваться продуктом участники проекта. При этом пользоваться в реальной жизни.
		* Система нарезается на компоенты (т.е. декомпозируются), кторые позволяют проще понять систему и которые позвляют проще писать пользовательские истрии.
		* Описываются пользовательские истории в порядке приоритетов.
		* Далее для более сложных функций, требующих пошаговых инструкций пишутся тест-кейсы и связываются с пользователскими историями.
		* Как только составлен фундамент обязательно занимаемся поддержкой в актуальном состоянии.
		* Четко демонстрируются и публикуются те области которые не будут тестироваться. Это должно быть сделано обязательно - нужно быть честным, да и позволит избежать недоверия и неудобных ситуаций, почему в этой обалсти возникают проблемы.
		* Изменять архитектуру тестов итеративно, вместе с самим проектом.
		
	- Туры
		Денежный тур - с фокусом на фичи и связанные с деньгами.
		Тур по достопримечательностям - фокус на важнейшие функции системы.
		Тур по неблагополучному району - фокус на области в которых раньше находились дефекты, или где есть много свежих дефектов.
		Антисоциальный тур - ввод нереальных данных или маловероятных данных.
		Тур навязчивого невроза - поторение одного действия
		Линивый тур - ввод минимально возможных данных и выбор всего по дефолту.
		
Глава_4 Тест-менеджер:
	- Сответы:
		* Знайте свой продукт.
		* Знайте своих людей и их навыки.
			+ Так же стоит помнить, что не нужно нанимать слишком много постоянных тестировщиков - дефицит приносить ясность и обнажает проблемы)
			+ Если есть очевидный недостаток - нужно привлекать специалистов из др. областей - то же внедрение, или внешнее тестирование. Тестирование бизенсаналитиками.
		* Не нужно делать то, что сейчас не приносит ценности.
		* Представлять каждому сотриднику менять проект или область каждый 18 месяцев.
			+ Но это не являетяс обязательным, это просто предоставление возможности. Нет в этом обязательности. если кому-то нарвится мобильные приложения, то пусть он на нем работает всею свою корьеру. Это возможность для тех, кто хочеть узанть нвоое и стать более универсальным специалистом.
		* Нужно избегать зависимости от звездности или завязанности от конкретного тестировщика.	
		* Нужно избегать команд с душком - Если люди не жадтут привлечения в проект тестировщиков, то пусть копают себе могилу дальше.
		* Инженер по тестированию должен оказывать влияние на продукт, а цель тест-менеджера сделать так, чтобы влияние было полезным и продуктивным.
		* Самый сильный вопрос это Почему - почему вы пишите этот тест, почему автоматизируется именно эта часть итд.
		
		* Пишите тесты на том же языке что и пишется сам продукт.
		* 20% всех сценариев использования отражают 80% самого использования. Автоматизируйте эти 20% и не беспокойтесь об остальном. Оставьте их для ручных тестов.
		* Работайте короткими итерациями и двигатйтесь мелкими шагами но двигатейсь.
		
		* Любвая часть автоматизации у которой не было ясной цели - выкидывалась.
		* Все что вы делаете должно приносить максимомум пользы и приносить ее неоднакратно.
		* Нужно избегать больших и сложных тестов. Авто-Тесты должны быть маленькими, быстро разрабатываться. Часто когда что то меняется, все автотесты идут в трубу. стр 246.
		* В Андройд Все занимаются ручным тестированием (даже разработчики в тестировании).		
		* ОФормляется как тетст-кейс только то что относится к специфическим фичам, дабы не забыть.
		
		* Надо пользоваться то что тестируешь!
		
		* Автоматизация недостаточно гибкая. И тут нужно взвешивать. Ведь когда  будут изменения придется все переписывать.
		
Глава_5 Как мы улучшали тестирование в Google.
	- Увеличение Unit-тестов приводит к умеьшению критичности интеграционных тестов, а системное тестирование позволяет сконцентироваться на исследование и ориентацию на пользователе.
	
	- Качество не есть тестирвоание. Качество закладывается при разработке
		* Хватит разделять тестировщиков и программистов. Тестированием должны заниматься и разработчики.
		* Да и тестирвоание как отдельная стизя тоже не приводит к пользе - все мы делаем продукт и все должны работать над улучшением проекта. Не правильно говорить я тестировщик, правильно говоирть я работаю над Chrome.		
		* Цель тестирования не в артефактах а в хорошем продукте.
			+ Часто отдельно выделенная гр. тестирования концентрируется на артефактах тестирования.
		* Разработчик все больше похож на разработчика а инженер по тестированию идет в противоположную сторону становясь ближе к пользователю.
	
	- Хороший вопрос
		* Почему фичами и функционалом управляет рук. проекта хотя разрабатывает код разработчик. А тестами и автотестами занимается тестировщики????
			Ведь это фича продукта и она должна быть подвластна тому же рук. проекта.
		
	- Веб повлиял на тестирование. Теперь поставка ПО от раработчиков сократилась и пришла к виду, когда перед поставкой ПО проверяют пользователи ограниченного круга. Или же внутренним пользователям.
		* Инжерен по тестирвоанию представляется как дизайнер который пытается предугадать сценарии, покрытие тестами, риски (составив карту рисков) - далее передается армии доверенных тестировщиков - получает обратную связь корректирует пересчитывает риски итд.
		* За тестирование должны отвечать люди которые работают с продуктом а не отдельная группа людей.
	
	
	
	Сценарийное тестирвоание.
	Исследовательское тестирование.
	Тестирование на базе пользовательских историй.
	Тестирование на базе оценки рисков.
	Сквозное тестирование.
		
		
		
		
		
		
		
		