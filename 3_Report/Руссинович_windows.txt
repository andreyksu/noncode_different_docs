Руссинович

Основные термины:
		Windows состоит из тысяч служб, которые разбиты на следующие категории
			* Базовые службы
			* Службы компонентов
			* Службы пользовательского интерфейса
			* Графические и мультимедийные службы
			* Обмен сообщениями и совместная работа
			* Сеть
			* Веб службы
			
		.NET
			# Framework Class Library (FCL) - библиотека классов.
			#Common Language Runtime (CLR) - управляемая среда выполнения кода. Своевременная комбияция, проверка типов, сборка мусора, безопасность доступа к коду. 
				* Реализована как классический COM-сервер (как стандартная DLL библиотека, работающая в пользовательском режиме).
				* По сути все службы .NET реализованы в виде DLL-библиотек, пользовательского режима, наложенные поверх WinAPI. Ни один из компонентов .NET, не работает в режиме ядра.
				
		DLL - набор вызываемых подпрограмм, связанных вместе в виде двоичного файла. В памяти только одна копия. В отличии от статических библиотек.
		
		Процессы и потоки:
			Программа это последовательность инструкций.
			> Процесс это контейнер для набора ресурсов, используемых при выполнении экземпляра программы.
				* Закрытое виртуальное адресное пространство. Набор ардесов в виртуальном пространстве, которыми приложение может воспользоваться.
				* Исполняемую программу. Исходный код и данные.
				* Перечень открытых дискрипторов (описателей) различных системных ресурсов - порты, файлы, семафоры итд.
				* Среда безопасности - определяется полномочия, права доступа, сессия итд
				* Уникальный идентификатор - ID процесса.
				* Один поток выполнения.
				# Каждый процесс имеет ссылку на свой родительский процесс. Если род. процесса более нет то информация не обновляется - т.е. мы можем получить идентификатор несуществующего процесса.
					Т.е. если есть цепочка Проц1→Проц2→Проц3 - цепочка запуска, каждый является дочерним. При закрытии Проц2, Проц3 остается, и изменение состояния Проц1 не влияет на Проц3.
			> Поток - выполнение планируется ОC Windows и являтся составляющей того или иного процесса. Представляется из себя:
				* содержимое набора регистров ЦП, отрожающее его состояние
				* два стека - 	1. используется потоком для выполнения кода в режиме ядра
								2. для выполнения кода в пользовательском режиме.
								(получается, что поток имеет два стека в пользовательском режиме и в привилегированном режиме)
				* закрытую область хранения - локальное хранилище потока (thread-local storage TSL). Используется библиотеками времени исполнения и DLL библиотеками. (закрытое адресное пространство - это оно же? стр. 57В)
				* ID потока
				* контекст безопасности или маркер (token)
				# Содержимое регистров, стеки, закрытая область зранения - называются контекстами потока - представляется функцией GetThreadContext.
				
			> При переключении с одного потока на др. задействуется планировщик ядра (что очень дорого). В windows есть два механизма сокращения "накладных расходов"
				user-mode scheduling UMS
				* Волокна
					# Позволяет приложению самому осуществлять планирование раБот своих потоков, не пологаясь на Windows на базе приоритетов.
					# Ядру такие потоки не видны, так как выполняются в пользовательском режиме. Библиотека Kernel32.dll
					# Сначала создается поток, после чего преобразуется в волокно методом ConvertThreadToFiber. Такое волокно может создавать новые волокна методом CreateFiber (у каждого волокна может быть свой набор волокон). Но новое волокно не начинает выполняться как поток, пока не будет выбрано методом SwitchToFiber. Такое волокно будет выполняться пока существует или пока не переключится методом SwitchToFiber.
				* Использовани планировщика пользовательского режима (user-mode scheduling UMS)
					# UMS - доступны только на x64 и избавлены от недостатоков влокон.
					# Видны ядру(имеют свое собственное состояние потоков ядра), что позволяет выдавать блокирующие системны вызовы, совместно использовать и вести борьбу за ресурсы, и иметь собственное состояние для каждого потока.
					# Так же могут работать исключительно в пользовательском режиме, и уступать друг-другу без участия планировщика ядра.
					# Когда UMS-поток выполняет операцию требующую входа в ядро (системный вызов), он переключается на выделенный ему поток режима ядра.
					
				!!! При переключении между UMS или Волокнами - с точки зрения ядра ничего не меняется, он продолжает выполнять все тот же поток.
					
			> У потока имеется свой собственный контекст выполнения, а так же каждый поток внутри процесса имеет доступ к общему адресному пространству внутри процесса и к ресурсам доступным для этого процесса.
			> У процесса кроме закрытого адресного пространства и потоков имеется: 
				* контекст безопасности (маркер доступа - идентификация процесса и полномочия процесса)
				* список открытых дискрипторов:
					$ файлы
					$ общие разделы памяти (дискрипторы виртуальных адресов - структура данных, испльзуемая диспетчером памяти для отслеживания вирт. адресов испльзуемых процессом)
				* мьютексы.
			> Jоb - windows оперирует именно заданиями. Управляет группами процессов, как идинным целым и осуществляет на них единовременное воздействие. Имеет информацию какие потоки сейчас принадлежат заданию, какие принадлежали но сейчас уже нет. Т.е. замена дерева потоков в Unix.
		
		Виртуальная память:
			* Это логическое предсталвение памяти. Позволяющее избегать столкновение процессов (перезаписи адресов итд). У процесса складывается иллиюзия, что вся память его. Так как физ. памяти меньше чем необходимое для процессов происходит постраничный перенос на диск, а при запросе этой стринцы памяти, возврат в RAM. При этом процесс об этом даже не знает.
			* Так как в x86 адресации хватало только на 4ГБ памяти - в Windows есть возможность в основной DDR на 4ГБ хранить ссылки на др. доступную память. Т.е. если вставлено в мать больше 4ГБ.  Но при этом управление адресацией на плечах прикладных программистов. Address Windowing Extension (AWE). Использовалось для СУБД в x32. Когда нужно было много памяти, доставляли новые планки, а текущие 4ГБ просто мапили на дополнительные адреса.
		
		Режим ядра и пользовательский режим:
			* Пользовательский режим - 3ий уроверь. Не имеет доступа к реальной памяти, к устройствам итд.
			* Режим ядра (системные службы, драйверы устройств) - в этом режиме процесс имеет доступ ко всем ресурсам, ко всем инструкциям процессора, ко всей системной памяти.
				$ Код ОС и драйверов так же используют виртуальное адресное пространство. (судя по стр.55 адресное пространство у них одно)
					% Какждая страница в вирт. памяти имеет пометку - в каком режиме доступа может быть совершен процесс чтения или записи. Т.е. в память режима ядра может записать/прочитать только проц соответстующего режим, а в память пользовательского режим - пользовательские процессы.
					% Так же у современных процессеров есть область которую они помечают как неисполняемую.
					
				$ Переход из режима в режим не является переключением контекста.
					
			При попытке в пользовательском режиме прочитать файл, происходит вызов метода ReadFile - который будет выполнен в режим ядра. Т.е. тем самым происходит переход из пользовательского режима в режим ядра. Это осуществляется за счет спец. инструкции процессора, который перехода в режим ядра(в защищенный режим процессора) а после выходит из этого режима. (Далее по книге описано, что процесс пользовательского режима имеет две области памяти, для пользовательского режима и для защищенного режима).

		Службы терминалов и множественные сеансы работы:
			* Сеанс нуль - содержит процессы, в которых реализуются сестемные службы
			* Первый сеанс - сеанс входа в систему на физической консили машины
			* Остальные сеансы образуются при подключении к удаленному рабочему столу или при переключении пользователей через ПУСК.

		Объекты и дескрипторы:
			Объект ядра - является единственным объектом типа времени выполнения определенного в статическом режиме.
			API диспетчера объектов ядра (компонент ядра).
			В Windows не все является объектом - в объект оборачивается только то, что нужно испльзовать совместно, защитить, снабдить именами, или сделать видимыми(через системные службы), для программ выполняемых в пользовательском режиме.
                * Допустим ядра занимается только управлениями потока и занимается он этим на низком уровен, его не заботит многопользовательский доступ итд. Вот компоенты выше, уже заботятся об этом, и все это инкапсулируют в объекты.

		Безопасность:
			* Управление изберательным доступом (discretionary access control)
				При входе пользователя в систему ему предоставляется - набор прав доступа или же контекст безопасности.
					При попытке доступа к объекту, ОС сравнивает контест безопасности объекта и пользователя.
			* Управление привилегированным доступом (priviliged access control)
				По сути это доступ администратора к пользовательским данным/объектам
			* Когда в рамках одной сессии происходит запрет доступа к определенным ресурсам. Т.е. запуск эксплоера в безопасном режиме. Или запрет работы с файлами созданными Админом с расширенными правами, Админу с урезанными правами.

			Аналогичные полномочия и ограничения реализуются и через API, путем размещения в объектах дискрипторов безопасности.

		Реестр:
			Системная база данных - настроек драйверов, оборудования, текущего состояния системы(какие ресурсы испльзуются, какие драйверы загружены)

		Unicode:
			Внутри, все реализованно на уровне Unicode. Есть в API две версии методов - Unicode и ANSI. Но ANSI более медленная так как конвертируется в Unocode а при возврате значения декодируется в ANSI.
				Но Windows никогда не станет конвер-тировать данные внутри файлов: решение о том, в какой кодировки хранить данные: в Unicode или в ANSI, принимается самим приложением.
			
Архитектура системы
	Windows NT
		* Отдельная самостоятельная разработка, начатая после прекращения сотрудничества IBM и Microsoft над OS/2. NT дало началу семейств 2000, XP и до сегодня(7, 8 , 10ка). DOS, Windows3.0 отдельные продукты. У NT первоначально планировалась поддерижвать IPA OS/2 и POSIX а лишь отом добавили Windows API.
		* Вытесняющая многозадачность (переключение между процессами происходит по кванту времени, а квант времени это прерывания от таймера)
		* Гибридное ядро или макроядром.
		
	Модель ОС	
		* В многопользовательских ОС приложения отделены от ОС. Код ядра запускается в привилегированном режиме(режим процессора) и имеется доступ к данным, к оборудованию, а код приложения в пользовательском режиме. Если приложение требует переключения в режим ядра, то он переключается → выполняется, после чего возвращается в пользовательский режим (все это происхоидт на уровне переключения режима ПРОЦЕССОРА).
		* Как и UNIX - ядро ОС и код драйверов совместно используют одно и тоже защищщенное пространство памяти, испльзуемое в режиме ядра.
		
	4ре основных процесса пользовательского режима:
		1. Фиксированные(или реализованные на аппаратном уровени) - вспомогательные системные процессы (вход в систему, администратор сеансов) - все это не входят в службы Windows
		2. Служебные процессы - (диспетчер задач, спулер печати, SQL Server, Exchange server)
		3. Пользовательские приложения
		4. Серверные процессы подсистемы окружения (environment subsystems) (поддержка Posix, OS/2 - т.е. возможность запускать различные приложения под Windows NT написанные для др. ОС: MS DOS, OS/2, Windows3.x, POSIX, Win32).
			# Подсистемы среды - представляют собой процессы Windows NT, эмулирующие среды разнообразных операционных систем. Каждая подсистема начинает работать в пользовательском режиме в бесконечном цикле, сразу после старта ОС. 
			# Каждая подсистема работает как отдельный процесс режима пользователя, причем каждая подсистема защищена от ошибок в других подсистемах: сбой в одной из них не приведет к блокировке других подсистем или модуля Executive. 
			# Каждая подсистема передает запрос Ядру ОС. Все подсистемы среды являются необязательными, и загружаются только в том случае, когда ее сервисы нужны клиентским приложениям. 
			# Наиболее важной подсистемой окружения является Win32 - подсистема, которая обеспечивает доступ для приложений к 32-bit Windows API. Дополнительно эта система обеспечивает графический интерфейс с пользователем и управляет вводом/выводом данных пользователя.
		
		~ Служебные процессы и пользовательские процессы общаются с ядром ОС(привилегированным режимом) только через DLL-библиотеки. Т.е. вызов службы происходит не напрямую а через DLL.
			
	Компоненты в режиме ядра:
		* Исполняющая система Windows - управление памятью, управление процессами и потоками, безопаснось, IO, сеть, связь меж процессами.
		* Ядро Windows - диспетчеризация потоков, диспетчеризация прерывания, мультипроцессорная синхронизация, и др. базовые объекты для испольняющей системы. Представляет набор подпрограмм и базовых обектов используемых остальной исполняющей системой для реализации выскокоуровневых конструтивных элементов.
		* Драйверы устройств
			# Аппаратные драйверы - перевод вызовы функций IO - в запросы IO конкретного аппаратного устройства (трансляция запросов).
			# Неаппаратные драйвера - драйверы файловой системы и сети.
		* Уровень аппаратных абстракций (hardware abstraction layer HAL) - т.е. изалируеет ядро, драйверы устройств и испольняющею систему от аппапратных различий (допустим различие между мат. картами) - по другому называют еще драйвер материнской платы.
		* Система организации многооконного режима (GDI)
		
		Notskrnl.exe 	- исполняющая система и ядра (ИС - верхняя часть, Ядро - нижняя часть).
		Hal.dll 		- уровень аппаратных абстраций (ядро над этой либой)
		Win32.sys 		- часть Windows в работающая в режиме ядра.
		Ntdll.dll		- внутренние вспомогательные функции и заглушки диспетрчера системных служб к исполняющим функциям (все вызовы через нее)
															Ntdll.dll
													---------------Пользовательский режим-------------------
															Исполняющая система (Диспетчер кэш-памяти, Диспетчер объектов, Диспетчер устройств Plug and Play, Диспетчер памяти, Диспетчер процессво, Диспетчер конфигурации) - Подсистемы.
															Ядро		|		Драйверы устройств и файловых систем
															Уровень аппаратных абстракций (HAL)
		
	Платформенная независимость:
		Notskrnl.exe, Hal.dll - являются зависимыми от платформы железа. Но все что сверху является за счет этого платфоро-независимыми.
		От сюда много версий Notskrnl.exe (под одно ядро, под много ядер итд)
		
	Многопроцессорность
		> Windows является симметричной мультипроцессорной системой (symmetric multyprocessing SMP) - т.е. все процессоры используют одно адресное пространство, и в ней нет главного процессора, любой поток может быть спланирован на любом процессоре.		
		> В ассиметричной - код ядра на одном процессоре, а пользовательские на др. процессорах.
		
	Масштабируемость:
		* Возможность запуска ОС на любом доступном процессоре/ядра или на нескольких одноверменно.
		* Выполнение нескольких потоков на разных процессорах при этом потоки отосятся к одному процессу.
		* Тонкая синхранизация внутри ядра (позволяет запукать компоненты на нескольких процессорах).
		
	Версии Windows:
		Различия в версиях винды (сервер или клиент) заключается в том, что она настроенна по разному(опитимирзованна) - для сервера или для графики.
		
	Отладочный режим:
		Есть специальная сборка для отладочного режима.
		Можно загрузиться в режиме отладки и запустить соответствующие инструменты.
		
	Подсистемы среды окружения и DLL-библиотеки подсистемы:
		? Как я понял, это поддержка ПО для OS/2, Unix/POSIX, Win32
		* Роль подсистемы среды окружения заключается в предоставлении прикладным программам того или иного поднабора базовых служб исполняемой системы Windows. Каждая подсистема может предоставить доступ к различным поднаборам служб Windows.
		* Каждый исполняемый модуль .exe привязан к одной и только к одной подсистеме.
			# При запуске образа код создания процесса исследует код типа подсистемы в заголовке образа и уведомляет соответствующею системв о новом процессе.
				kernel32.dll, advapi32.dll, user32.dll, gdi32.dll, psxdll.dll(sua-unix based application)
			# Если функция требует проведения в процесс подсистемы среды окружения некоторой работы, то в этом случае к подсистеме среды окружения делается клиент-серверны запрос посредством отправки подсистеме ссобщения для выполнения той или иной операции. Затем DLL-библиотека подсистемы, прежде чем вернуть управление вызывающему коду, ждет ответа.
	
	Подсистема Windows:
		* Была разработана для поддержки нескольких назависимых подсистем среды окружения (OS/2, POSIX, DOS, Win32).
			# По этой причине много что перенесено в Windows подсистему дабы избежать дублирования (дублирования кода в подсистемах среды окружения)
		
		Подсистема Windows состоит из следующих основных компонентов:
			* Для каждого сеанса экземпляр процесс подсистемы среды (Csrss.exe) загружает три DLL бибилиотке (Basesrv.dll, Winsrc.dll, Csrsrv.dll) обеспечивающие
				# создание и удаление процессов и потоков
				# частей поддерживающих процессы 16-разрядный DOS-машины (только для 32битных версий)
				# др. разнообразные функции: GetTempFile, DefineDosDevice, ExitWindowsEx - и несколько истемных функций поддержки языка.
			* Драйверы устройств режима ядра (Win32k.sys)
				# диспетчер окон, управляет выводом окон, получает ввод с устройств, передает приложениям пользовательские сообщения.
				# интерфейс графических устройств - (Graprhics Device Interface (GDI)) - библиотеки для вывода линий, текста/шрифтов, фигуры и манипулирование граф. объектами.
				# Оболочка для DirectX - реализуемого в др. драйвере ядра (Dxgkrnl.exe)
					$ DirectX представляет собой высокопроизводительный прикладной программный интерфейс, который скрывает от приложения характеристики аппаратных средств и операционной системы. DirectX разработан для обеспечения высокоскоростного пользовательского интерфейса реального времени.
					$ DirectX не взаимодействует непосредственно с аппаратным обеспечением, а взаимодействует через GDI.
			* Хост-процесс консоли (console host process Conhost.exe)
			* DLL-библиотеки подсистем (Kernel32.dll, Advapi32.dll, User32.dll, Gdi32.dll) которые превращают в документированные вызовы функции Windows API в соответствующие и больше частью недокументированные вызовы системных служб режим ядра Ntoskrnl.exe и Win32k.sys
			* Драйверы графический устройств для аппаратно-зависимых драйверов графических дисплеев, драйверов принтеров и драйверов видеомини-портов.
			
			Для создания элементов управления на экране:
				Диспетреч окон передает соответстующее требовнаие GDI а тот передает их драйверам графических устройств.
					Т.е. GDI посредник между приложением и графическим устройством. GDI позволяте коду приложения быть независимым от аппаратных устройств и драйверов.
					
			Подсистема пользовательского интерфейса Windows NT реализует оконный интерфейс:
				Оконная станция - соответствует одному сеансу пользовательского интерфейса Windows NT. При подключении через службу удаленного рабочего стола создается новая оконная станция. Каждый запущенный процесс принадлежит одной из оконных станкций.
				
	
	Ntdll.dll - спец. библиотека системной поддержки, для использования DLL библиотек подсистем. Содержатся функции двух типов.
		* фнкции-заглушки, обеспечивающие переход от диспетчера системных служб к системным службам исполняющей системы Windows (?Как я понял имеется ввиду ntoskrnl.exe эти функции в dll начитанются с Nt, Zw. И функции реализованные в пользовательском режиме Rtl)
			# обеспечивает интерфейс к служебам исполняющей системы Windows - котрые могут быть вызваны из пользовательского режима.
			# при вызове осуществляет переход в режим ядра для вызова диспетреча системных служб - который после проверок, вызывает системную службу ядра, реальный код которой содержится в файле Ntoskrnl.exe (Ntoskrnl.exe - является ядром операционной системы NT. Данный файл запускается загрузчиком ядра NTLDR в безопасносм режиме. При передачи управления от NTLDR - Ntoskrnl инициализирует внутреннюю подсистему с драйверами).
		* вспомогательные внутренние функции, используемые подсистемами, Dll-библиотеками подсистемами и др. исходными образами.
		
		Так же содержит множество вспомогательных функций
			* загрузчик образов префикс(Ldr)
			* диспетчер динамической области памяти и функции для обмена между процессами подсистемы Windows (Csr)			
			* общие подпрограммы подсистемы библиотеки времени выполнения (Rtl) - (?По wiki это либы для пользовательского режима)
			* Отслеживание событий для Windows - (Etw Event Tracing for Windows)
			* Небольшой поднабор подпрограмм времени выполнения языка С (CRT)
			
	Исполняющая система Windows (находится на верхнем уровне файла Ntoskrnl.exe - ядро составляет нижний уровень).		
		Включает функции след. типов:
		* Функции экспортируемые и вызываемые из пользовательского режима - эти функции называются системными службами и экспортируются посредством Ntdll. Большинство служб доступно через Windows API.
		* Функции драйверов устройств, представляет собой интерфейс из пользовтаельского рижема к режиму ядра. Для тех функций в драйверах устройств, которые не связаны с чтением и записью
		* Функции которые могут быть вызываны только из режима ядра (экспортируемые из WDK)
		* Вспомогательные функции вызываемые внутри Ntoskrnl (префикс Iop - внутренние функции поддержики диспетчера IO. Mi - внутренние функции поддержки помяти)
		
		Исполняемая система содержит следующие компоненты:
			* Диспетрче конфигурации - отвечает за реализацию и управление - системным реестром.
			* Диспетрчер процессов - создает, процессы и потоки. Сама реализация в ядре Windows, однако исполняющая система добавляет нектороную семантику и функции.
			* Монитор безопасности (SRM) - обеспечивает политику безопасности.
			* Диспетчер IO - реализует аппаратно независимый IO. И отвечает за направление на соответствующие драйвера устройств, для дальнейшей обработке.
			* Диспетчер устройств PnP - определяет какие драйвера необходимы для поддержки конкретного устройства и загружает эти драйвера.
			* Диспетрчер электропитания
			* Диспетчер кэша - размещает данные полученные с диска в основной памяти. И осуществляет задержку записи - видимо что бы была запись более объемная, а не по мелочи за раз.
			* Диспетчер памяти - реализует вирт. память, схему управения памятью.
			* Логическая предвыборка (Superfetch) - ускоряет загрзку системы и запуск процесса путем отпимизации загружки данных, на которые есть ссылка во время запуска системы или процесса.
			
			И еще много что. см. стр 79-80
		
	Ядро (состоит из набора функций находящихся в файле Notskrnl.exe)
		* Предоставляет сновные механизмы Диспетчеризации и синхронизации потоков - используемые компонентами исполняющей системы.
		* Поддержка архитектурно-зависимого оборудования низкого уровня (диспетчерезация прерываний и исключений).
			- Написан на С и ASM (где требуется доступ к спец. инструкциям и регистрам процессора.)
		
		Ядро не занимается почти ни одним политическим решением за исключением планирования и деспетчеризации потоков.
			Исполняющая система сверху ядра уже представляет потоки и др. объекты совместного использования в виде объектов (с дискрипторами и др. атрибутами).
			
		Область ядра, относящаяся к управлению процессором и блок управления.
			Данные ядра хранятся в:
				KPCR - kernel processor control region (область относящаяся к управлению процессором)
					* процессорная таблица, диспетчеризации прерываний.
					* сегмент состояния задач.
					* таблица глобальных дискрипторов.
				KPRCB - kernel processor control block (блок управления процессором, является закрытой структурой и используется тольок Ntoskrnl.exe)
					* Информация о планировании (текущий, следующий, приостановленный процессы предназначенные для выполнения на процессоре)
					* информация о кэш памяти.		
	
		Ядро так же занимается абстрагированием или изоляций исполняющей системы и драйверов устройств от различий аппаратных архитектур поддерживаемых Windows (HAL-hardware abstraction layer на x64 только один образ Hal.dll - загружаемый модуль режима ядра).
				Advanced Configuration and Power Interface(ACPI) - управление конфигурированием и энергопотреблением
				Advanced Programmable Interrupt Controller (APIC) - усовершенствованным програмируемым контроллером прерываний.
				
			HAL - Обеспечивает низкоуровневый интерфейс с аппаратной платформой, скрывает подробности зависящие от аппаратуры: IO, контроллеры прерываний, механизмы взаимодействия процессоров, любые функции имеющие как архитектурные так и машинные зависимости.
			Т.е. Windows а так же драйверы не обращаются к железу напраямую а через интерфейс HAL.
			
	Драйверы:
		Обеспечивает интерфейс между диспетрчром IO и соответствующим оборудованием(запускаются в режиме ядра).
			* Аппаратные драйверы (через HAL) - запись на физ. устройство и чтение от туда (драйверы шин, драйверы запоминающих устройств)
			* Драйверы файловой системы - транслируют запросы на файловый IO в конкретное устройство.
			* Драйверы протоколов TCP/IP IPX/SPX
			* Драйверы потоковыф фильтров ядра - обработка видио итд.
		
		Драйверы шины - обслуживающий контроллер шины, адаптер, мост или любое устройство имеющее дочернее устройства (PCI, USB). Отправляет в PnP информацию и отчет об устройствах подключенных к его шине.
		Функциональный драйвер - непосредственно сами драйвера.
		Драйвер фильтра - испльзуется для добавления функциональности.
		
		Драйвер это программынй интерфейс для управления устройством. Драйвер общаяется с утсройством через шину, к которой подключено устройство. Запрос к драйверу > драйвер к устройству > обработка устройсвом > устройсово драйверу > драйвер инициатору.

		
	Процесс System:
		Дает начало потоку - системному потоку режима ядра. У потоков режима ядра есть все атрибуты побычных потоков, кроме как адресного пространства пользовательского режима.
		Драйвера, диспетчер памяти  используют системные потоки. для реализации своих функций.
		Системные потоки как правило принадлежат процессу System, однако драйвера могут создавать потоки и в др. процессах
		
		
	Пропустил системные процессы с 96стр. по 102 стр.
		
Системные механизмы:
	Диспетчеризация системных прерываний(прерывания асинхронный процесс, а исключения синхронный процесс):
			> Есть два вида прерываний:
				* Аппаратное
				* Программное
			> При возникновнии аппаратного прерывания или исключения - процессор записывает довольно большой объем информации о состоянии машины в стек ядра того потока, который был пререван, это нужно для возврата к нужной точке потока управления и продолжения выполнения, будто ничего не случилось. Если же поток пользовательского режима, то Windows переключается на режим ядра и записывает в стеке ядра фрейм системного прерывания прерванного потока.
			> При возникновении прерывания от устройства - обработчик аппаратных системных прерываний передает управление процедуре обработки прерываний которую драйвер устройства предоставил для устройства, вызвавшего прерывание (ISR-процедуры interrupt service routine), тот в свою очередь поднимает уровень IRQL до обрабатываемого (это нужно что бы др. прерывания не прервали обработку с приоритетом ниже или равным текущему обрабатываемому). После окончания, диспетчер обработки прерывания понижает IRQL-уровень процессора до значания на котором он был до возникновения прерывания, а затем загружает сохраненное состояние машины. Прерванный поток начинает выполняться с того же места.
				* На одну из линий контроллера прерываний поступает запрос на прерывания, контроллер прерываний запрашивает прерывания у Процессора, когда процессор готов прерваться он запрашивает у контроллера (Interrupt request IRQ). Контроллер прерываний превращает IRQ в номер прерывания, используя этот номре в качестве индекса в структуре под названием таблица диспетчерезации прерываний (Interrupt dispatch table IDT) и передает соответствующей процедуре обработки прерываний.
				* Windows отображает IRQ на IDT. При загрузке Windows заполняет IDT указателями, на процедуры ядра обрабатывающие прерывания и исключения.
				* Драйвер шины (PCI, USB) сообщает информацию PnP-диспетчеру устройств об устройстве. Тот на основе перечня подключенных устройств и др. информации определяет какой урвоень прерываний может генерировать данное устройство. А затем абритр прерываний PnP отображает пререныания на IRQL-уровни.
				* Если это прерывание от системной службы, то обработчик прерываний передает управление конкретной функции системной службы. Обработчик прерываний это обычная функция характерная для того или иного вида прерываний. Получающая управление по вектору.
			> Устройства генерирующие прерывания позволяют эффективно утилизировать процессор. Поток запустивший/запросивший IO у устройства, может выполнять свои задачи, а когда устройство закончит, оно вызовит прерывание.
						
		Контроллеры прерываний x86	
			* От IBM (устаревший Programmable Interrupt Controller --- PIC) - Используется два контроллера суммарно 15 линий (8 и 7 т.е. одна линия второго соединяется с первым конт. по этому 7ми остается) - применяется только на одноядерном/однопроцессорном.
		Контроллеры прерываний x64	
			* Совеременные (Advanced Programmable Interrupt Controller --- APIC) 256 линй прерывания. У каждого ядра свой локальный APIC. Перед APIC ядер стоит ACPI-ввода/вывода (прерываний от устройств).		

		Контроллеры прерываний устанавливают приоритет прерываний IRQ, но в Windows добавлено IRQL
			> Уровни запросов программных прерываний (IRQL) - это уровни прерываний самой Windows, по сути является отражением IRQ но отождествлять нельзя.
			> HAL отображает аппаратные прерывания на IRQL.
				* При этом для каждого ядра процессора свой IRQL.
		
		Объект прерываний:		
			Объект прерываний содержит всю информацию необходимую ядру, что бы связать ISR устройства с конкретным уровнем прерывания, включая адрес ISR, и запись в таблице IDT с которой нуно сопостваить ISR.
			
		Программыне прерывания:
			Диспетчерризируемые прерывания или прерывания отложенного вызова процедуры (Degerred Procedure Call --- DPC)
			Когда ядро понимает что процесс больше не может продолжаться из за окончания или перехода в режим преывания - ядро запрашивает диспетрчер и немедленно происходит переключение контекста.
			Когда же код поток находится во многоуровневом вложении то ядро запрашивает диспетчеризацию но откладывает ее наступление.
			Ядро всегда поднимает процессор до уровня DPC или выше когда ему нужно синхронизировать доступ к общим структурам ядра.

	Пропустил про (121-178 Программыне прерывания, Объекты прерываний, Таймеры, Диспетчеризация исключений)

	Диспетчер объектов:
			Компонент исполняющей системы отвечающий за создание, удаление, защиту и отслеживание объектов. Централизует операции управления над объектаами.
			* Как я понял диспетчер объектов имеет исключительное право на создание объектов и их дискрипторов.
			> Обеспечивает унифиицированный механизм для использования системных ресуросв
			> Изоляция защиты объектов в одном месте Унификация политики доступа к объектам.
			> Мониторинг, ссылок на объекты и отслеживание политики безопасности.
			итд.		

		Три объекта:
			1. Объекты испольняющий системы (диспетчер процессов, диспетчер памяти, подсистема I/O bnl)
			2. Объекты ядра (синхронизация - т.е. то что испльзует исполняющая система)
			3. Объекты GDI/User

		У какждого объекта есть 
			- заголовок объекта 	(управляется диспетчером объектов, независимо от типа объекта. У заголовка есть информационные подзаголовки: названия, квоты, процесса, дескриптора, создателя)
				стр. 180 описание заголовков
			- тело объекта	 		(используетя/управляетя компонентами исполняющей системой, т.е. теми кто их породил)
				при создании объекта та или иная исполняющая система в обязательном порядке наделяет их методами (open, close, delete итд, т.е. )
		
		Дискрипторы объекта и таблица дескрипторов процессора:
			Когда процесс создает или открывает объект по его имени - он получает дискриптор, дающий ему доступ к объекту.
			При этом дискрипторы дает унификацию (единный интерфейс для доступа), не важно дискриптор чего; потока, файла или процесса - нет никакой разницы между ними.
			Таблица дискрипторов содержится в потоке/процессе по которому видно, какие ресурсы/объекты использует данный процессор (так же увеличивается счетчик в заголовке объекта, увеличивает их диспетчер объектов, аналогично и при осовобождении, счетчик уменьшается. А при достежении 0 - диспетчер объектов удаляет имя объекта из глабального пространства имен, что закрывает доступ к нему). При этом те, кто находится в режиме ядра обращаются не по дискриптору а по указателю, соовтетственно перед удалением объекта нужно еще проверять и количество указателей на данный объект.

	Синхронизация:		
		Спин-блокировки
			> Механизм используемый ядром для достижения мультипроцессорной взаимной блокировки, называется спин-блокировкой. Представляет собой блокирующий примитив, связанный с глобальной структурой даных (по сути блокировка на доступ к памяти по определенному адресу)
			> Если спин блокировка занята, ядро предпринимает пропытки ее получения, пока не добъется успеха (т.е. если несколько процессоров то может произойти случай когда они обратся к одной области памяти, что приведет к порче данных, такие ситуации нужно запрещать)
			> На многих архитектурах,есть аппаратная поддержка установки и проверки спин-блокировк (т.е. поддерживается все это на уровне процессора)
			> Есть спин-блокировки с очередью. Встаем в очередь, освобждается блокировка, поднимается флаг, проц предоставляет следующему, потоку возможность поработаь.
			> Находясь в спин-блокировке - процессор не должен прерываться на прерывания. Спин блокировки, в отличии от мьютекса должны быть очень короткими и мгновенно выполняемые без задержек. И область памяти не должна быть выгружаемая.
			> Так как один процессор будет ожидать другой постоянно опрашивая, а не освободилось, он будет работать 100% своей мощности, для этого сделана инструкция pause.
		
		В верхнему уровне блокировка обеспечивается мьютексами, ресурсами исполняющей системы, процессы, потоки, события, семафоры, таймеры, заверешение I/O
			Как вариант, поток можно заствить ждать дискриптор объекта - это заставить ядро перевести поток в режим ожидания - одним словом все на уровне ядра!
				* Объектами диспетчера ядра (kernel dispatcher objects).
				* Пуш-блокировками.
				* Ресурсами исполняющей системы.
			Далее с 239 по 249 описание мьютексов, пуш-блокировок, ресурсы исполняющей системы, критические разделы

	Системные работчи потоки:
		При инициализации Windows в процессе System создается несколько потоков называемые - системными рабочими потоками. Существуют исключительно для выполнения работы по поручению др. потоков.

	Усовершенствованный вызов локальных процедур:
		Для обмена данными между процессами в Windows разработан ALPC(Advanced Local Procedure Call) и заменил собой IPC.
		стр 253 - 265
			
	Wow64	
		Обеспечивает запуск x32 приложений на x64 машине.
		стр 266 - 276
		
	Загрузчик образов
		Выполняется не на уровне ядра а на пользовательском уровне (по большей части)
		Знанимается поиском и загрузкой/выгрузкой требуемых dll библиотек, аллокацией динамической памяти потока (куча)

	Гипервизор (Hyper-V)
		Пропустил (297-321)

Глава4 - Пропустил
Механизмы управления:
	Реестр
	Внутреннее устройства реестра
	Службы

Глава5 - в планах
Процессы, потоки и задания

Глава6 - Похоже пропущу.
Безопасность

Глава7 
Сеть
