=============================================================================
Общее:
			Литерал:
				Это значение указанное непосредственно в тексте программ.
				
			Объект:
				Неупорядоченная коллекция именнованных значений.
				Классы можно представлять как подтипы объектного типа.
				
			Числа:
				Все числа являются вещественными.
				Все операции доступны через функции доступные в Math.
				Переполнение в левую сторону или в правую не генерируют ошибку а возвращают Infinity. Аналогично и деление на ноль.
				Деление 0/0 возвращает NaN или попытка извлечь корень из отрицательного числа.
				Проверка x на NaN > x != x только когда NaN вернет true. Или isNaN().
				Аналогично isFinitive().
				
			Логическое значение:
				Для равенства if (...)
					undefined, null, 0, -0, NaN, "" - дают false
					все остальное дает true

				typeof для null - дает "object", для undefinеd - дает "undefinеd"
				
			Преобразование типов:
				Number("333") но лучше parseFloat() или parseInt(); String(true); Boolean([]); Object(3) =>Number(3)

			Условия:
				Проверка на равенство без преобразование типов (=== и !==)
					(0==false) или 	(''==false)		> true
					(0===false) 					> false

				Доп. моменты:
					(null==undefined)				> true
					(NaN==NaN)						> false
					(NaN!=Nan)						> true

				undefined равен только себе и ничему более. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.
				undefined происходит при:
					обращении к непроинициализированной переменной.
					несуществующему эл. массива
					к параметру функции что не был передан
					при обращении к функции которая не имеет блок return
					null равен только себе и ничему более. Не является «ссылкой на несуществующий объект» или «нулевым указателем». Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».

			Приведение типов к числу:
				undefined	NaN
				null		0
				true/false	1/0


=============================================================================
Область видимости:
	Глобальная переменная перекрывается локальной переменной функции.
	В JS есть понятие видимость в функции, все переменны, объявленны внутри функции, видимы везде в теле функции и во вложенных функциях.
	
	var
		Переменная объявленная как var в for - так же видна во всей функции и за блоком for (что отличается от C подобных языков).
		function a(){
			...
			for (var k=0; k< 100; k++){
				if(k==50){
					var l = "Достигли 50";
				}
				...
			}
			console.log(k);
			console.log(l);
		}	
	
	let
		В указанном примере переменная K объявленная через var будет доступна и за пределами цикла. Но вот если объявить так for (let k=0; k< 100; k++) - то переменная будет доступна только в рамках цикла. Т.е. console.log(k); вывести не удастся. Аналогично и L

	var:
		- ограничена областью видимости функции
		- её значение будет undefined если вы попытаетесь обратиться к ней до её объявления.
		
		- обрабатывается в самом начале работы функции или скрипта, если переменная является глобоальной. И не важно где var переменная объявляется.
			Тут говорят о "всплытии" var всегда поднимается наверх. Однако нужно разделять, объявление переменной и присваивании значения переменной. Объявление выполняется в начале работы функции, а присвоение при доходе до строчки.

	let:
		- ограничена областью видимости блока
		- вы получите ReferenceError если попытаетесь обратиться к ней до её объявления.
			- For "let" and "const" - they will be hoisted but not assigned with the default undefined. Accessing such variables will result in the ReferenceError.

	const
		Объявляет константу. При этом как и в Java сам объект что присвоен по ссылке менять можно, нельзя менять лишь ссылку на него.
		По работе аналогична let.
		
	
			Интересно по инициализации (Execution Context).
				https://ui.dev/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/				
	
	Execution Contexts:
		JS работает с кодом на двух фазах. Creation / Execution (эта часть вполняет строчку за строчкой)
		
		Creation:
			1. Создание глобального объекта (Create a global object i.e., window in the web browser or global in Node.js.).
			2. Создание объекта this (Create a this object binding which points to the global object above.)
			3. Выделение памяти для переменных и для функций (Setup a memory heap for storing variables and function references.)
			4. Назначение объявленным переменным значений по умолчанию т.е. undefined. Размещение/загрузка функций в памяти. (Store the function declarations in the memory heap and variables within the global execution context with the initial values as undefined.)			
			
		Execution
			1. Строка за строкой переменным(для которых уже есть выделенная памят) назначаются реальные значения (During the execution phase, the JavaScript engine executes the code line by line. In this phase, it assigns values to variables and executes the function calls.)
			
	For every function call, the JavaScript engine creates a new Function Execution Context. The Function Execution Context is similar to the Global Execution Context, but instead of creating the global object, it creates the arguments object that contains a reference to all the parameters passed into the function:

	Function Execution Context:
		Creation:
			1. Создаётся объек аргументов arguments.
			2. Создаётся объект this
			3. Выделяет памят для переменных и функций, что находятся внутри метода.
			4. Назначение объявленным переменным значений по умолчанию т.е. undefined. Размещение/загрузка функций в памяти.	

		Execution Context - происходит когда вызывается функция.
		
	Поднятие:
		var
			console.log(discounted) // undefined см. разел Execution Contexts - это происодит так как на этапе Creation уже выделена память, присвоено значение undefined.
			var discounted = []
		let
			console.log(discounted) // NOT OK: ReferenceError
			let discounted = []

=============================================================================
Объект:
	Помимо собственных свойств, объекты могут наследовать свойства от др. объектов, известных как ПРОТОТИПЫ.
	
	Атрибуты свойств:
		writable		- доступность значения свойства для записи
		enumerable		- определяет доступность имени свойства для перечисления в for/in
		configurable	- определяет удаляемость свойства и изменение его атребутов.
	
	Дополнительные имеется три атрибута объекта:
		prototype - ссылку на др. объект, от которого наследуется свойства.
		class - содержит строку с именем класса объекта, и определяет тип объекта.
		extensible - указывает на возможность добавления новых свойств в объект.
	
	Каждый объект имеет второй объект, ассоциированный с ним - это и есть прототип. И первый объект наследует свойства от этого прототипа - т.е. прототип это просто объект (при этом любой объект, а не какой-то особенный).
		Ссылка на прототип хранится в __proto__ - это сеттер и гетер для [[Prototype]]. Т.о. доступ/связь с прототипом осуществляется через эту ссылку.
	
	Для конструкторов:	
		Прототипом объекта arr (созданный как var arr = new Array()) является объект, что находится в поле Array.prototype. А для объекта dat, созданного как var dat = new Date() является объект, что находится в поле Date.prototype.
			- По сути запись выше означает arr.__proto__ === Array.prototype т.е. в __proto__ хранится ссылка на др. объект, что хранится в поле prototype.
			- Нужно обратить внимание, что prototype присутствует только у функций-конструкторов (Array - функция конструктор объектов). По умолчанию "prototype" – объект с единственным свойством constructor, которое ссылается на функцию-конструктор. Rabbit.prototype == { constructor: Rabbit, __proto__ : Object.prototype };
			Опять же constructor присущь тоже только функциям.

			console.log(typeof Array) -> function
			console.log(typeof Array.prototype) -> object (при этом по умолчанию он хранит одно единственное поле - constructor, ну и разумеется прототип __proto__ который ссылается на Object.prototype).
			
			
			let arr = [1, 2, 3];			
			alert( arr.__proto__ === Array.prototype ); // true
			alert( arr.__proto__.__proto__ === Object.prototype ); // true
			alert( arr.__proto__.__proto__.__proto__ ); // null
			
			Можно доработать встроенные прототипы добавив новые методы
				String.prototype.show = function() { //значение prototype используется только при создании нового объекта (т.е. копируются из него поля)
					alert(this);
				};
				"BOOM!".show(); // BOOM!
				
			Заимствование методоов
			let obj = {
				0: "Hello",
				1: "world!",
				length: 2,
			};
			obj.join = Array.prototype.join;
			alert( obj.join(',') ); // Hello,world!

		Все встроенные и пользовательские конструкторы наследуют прототип Object.prototype.	А вот объект Object.prototype не имеет прототипа, у него нет унаследованных свойств.

!!!		Данные и методы хранятся только в объектах, а конструкторы лишь позвляют конфигурировать будущий объект.
			Функция-конструктор имеет свойство prototype, в котором хранится ссылка на объект-прототип. По его образу эта функция будет создавать новые объекты.
!!!			Прототип объекта, хранящийся в его свойстве __proto__, и объект, хранящийся в свойстве prototype конструктора – одно и то же. 

			Array.prototype.__proto__ === Object.prototype;
			Array.prototype - используется только один раз, при конфигурировании нового объекта через new. А дальше уже никак не связан. И дальшейшая работа должна идти через __proto__. 
			При этом функция-конструктор должена содержать ислючительно данные, а все методы должны быть в prototype. Обусловлено это тем, что при каждом вызове черзе new - выполняется тело функции, и соответственно для каждого вызова, будут создаваться ананимные функции, что объявлены в конструкторе (что даст падение по производительности и увеличение потребления памяти).
			
	Для объектов:
		let animal = {
			eats: true,
			walk() {
				alert("Animal walk");
			}
		};
		let rabbit = {
			jumps: true
		};
		
		rabbit.__proto__ = animal; //и снова __proto__ это лишь геттер и сеттер

		for(let prop in rabbit) {
			let isOwn = rabbit.hasOwnProperty(prop);

		if (isOwn) {
				alert(`Our: ${prop}`); // Our: jumps
			} else {
				alert(`Inherited: ${prop}`); // Inherited: eats
			}
		}
		
		А можно и так:
			let rabbit = {
			  jumps: true,
			  __proto__: animal
			};	
	
	Варианты создания объектов:
		1. var empty = { ... };
		2. var o = new Object(); тоже-самое, что и {};	var a = new Array(); тоже-самое, что и []
		3. var obj = Object.create(prot) - создает новый объект, с yказанием прототипа - по сути это есть ссылка на объект. Где create статическая функция.
			var o3 = Object.create(Object.prototype); - по сути полный аналог var o3 = {} или o3 = new Object()
		
	Присвоение значения свойствам:
		Присвоить значение можно только собственным свойствам, но не унаследованным. Если в объекте О есть унаследованное свойство x, то операция O.x = 1 создат новое собственное свойство, перекрыв унаследованное свойство. Т.е. унаследованные свойства можно только читать.
			Опять же, если унаследованное свойство создано только на чтение, то его переопределять собственными свойствами нельзя (т.е. присваивание не будет выполнено) - !!!!Не очень понятно это.
		Всегда создается или изменяется свойство в оригинальном объете и никогда в цепочке прототипов. Т.е. механизм наследования действует при чтении, но не при изменении.
			Аналогично и для метдов get и set стр 145 и 146 внизу.

		o.hasOwnProperty("x"); # вернет true - если свойств является собственным и оно есть у объекта.

		Свойства встроенных объектов не являются перечисляемыми. Свойства созданные обычной программой, являются перечислимыми(если специально не установленно иное).
			o.propertyIsEnumerable("x"); # вернет true если оно является собственным и перечисляемым. Для унаследованного вернет в любом случае false.
			Object.prototype.propertyIsEnumerable("toString"); # всегда вернет false.

	
	Чтение:
		Проверка что объект у которого запрашиваем свойство не null и не undefined
		var len = book && book.subtitle && book.subtitle.length; # правило работы оператор && - возвращает ...
		или
		var len = undefined;
		if (book){
			if (book.subtitle) 
				len = book.subtitle.length;
		}
		
	Удаление:
		delete book.author - удалеят свойство из объекта. Удалить можно только собственные свойства.
			Для удаления наследуемых свойств, нужно удалять в прототипе, но при этом удалится во всех объектах, что наследуют данный прототип.
			
	Геттеры и сеттеры(стр. 152) - методы доступа:
		var o = {
			data_prop:value,
			get accessor_prop(){...}, 		- имя этих методов и есть имя свойства. Вместо function используется get и set
			set accessor_prop(value){...}
		};
		
		r = o.accessor_prop
		
	Получение атрибутов свойств:
		Object.getOwnProperyDescriptor(anObject)	- статический метод.
		Object.getPrototypeOf()						- обход цепочки прототипов.
		Object.defineProperty()/defineProperties()	- добавления свойства к объекту стр. 155(161). Изменяет и добавляет только собственные свойства, но не унаследованные.
			Как можно задать при объявлении свойства, на подобии Java?
			
+++++
	Object.getPrototypeOf(x);

	Объекты-наследование:
		~	Реализуется наследование через неявную(внутреннюю) ссылку одного объекта на другой, который называется его прототипом и в спецификации обозначается [[Prototype]]. Это свойство обычно скрыто от программиста (но браузеры дают доступ через __proto__, да и др. среды тоже предоставляют доступ).
				Свойство __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]]
				Функции Object.getPrototypeOf(obj); Object.setPrototypeOf(obj, proto); современная замена геттеру и сеттеру __proto__
			
		~	В javascript базовое наследование основано не на классах. То есть, нет такого, что классы наследуют друг от друга, а объект класса-потомка получает общие свойства.
				Вместо этого объекты наследуют от объектов без всяких классов. Наследование на классах можно построить(эмулировать), опираясь на базовое наследование javascript.

		~	JavaScript часто описывают как язык прототипного наследования — каждый объект, имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и свойства.
				Точнее, свойства и методы определяются в свойстве prototype функции-конструктора объектов, а не в самих объектах.
				При наследовании свойсва и методы обнаруживаются по цепочке прототипов.
				
		~	При этом нужно помнить, что добавление свойств, изменение свойств, удаление свойств у дочернего объекта не влечет за собой воздействие на родительский объект - т.е. свойства родительского объекта доступны только на чтение. И пытаясь изменить значение свойства родительского объекта - мы лишь создаем аналогичное свойство в дочернем объекте - которое перекроет свойство родительского объекта.
			let a = { first : "first"}
			let b = { second : "second"}
			b.__proto__ = a; а можно было бы так let b = { second : "second", __proto__ : a}
			
		~	this - это всегда текущий объект. Т.е. всегда указывает на текущий объект и так-же изменяет свойства текущего объекта и не влияет на родительский объект. 
				Т.е. если есть родительский объект и в нем есть this. После чего мы наследуемся от него и вызываем некие методы где используется this - то это будет отнесено к тек. объекту а не к родительскому (и все изменения будут отнесены к тек. объекту).
				let animal = {
					walk() {
						if (!this.isSleeping) {
						alert(`I walk`);
						}
					},
					sleep() {
						this.isSleeping = true;
					}
				};

				let rabbit = {
					name: "White Rabbit",
					__proto__: animal
				};

				// модифицирует rabbit.isSleeping
				rabbit.sleep();

				alert(rabbit.isSleeping); // true
				alert(animal.isSleeping); // undefined (нет такого свойства в прототипе)
				
		~	Обход ключей
				for ... in - обходит в том числе и по унаследованным ключам
				Object.keys(myObj) - обходит только собственные ключи.
				
					А еще можно воспользоваться методом myObj.hasOwnProperty(key) для for ... in
					
		~	Пример определения как вызвана функция через new или просто как самостоятельная.
				function User(){
					alert(new.target);
				}		
				User(); - undefined
				new User(); - function User{...}
				
		obj.hasOwnProperty(key);
		Object.create(proto, descriptors);
		animal instanceof Animal

=============================================================================
Функции:
    В JS - функция является объектом Function
        ~     prototype - это свойство доступно только для функций (еще раз, это СВОЙСТВО функции. И содержимое этого свойства будет присвоено в __proto__ создаваемого объекта от этой функции черзе new. Т.е. это поле prototype используется только при создании нового объекта через new - но для самой функции это поле ни на что не влияет)
        ~     По умолчанию "prototype" – содержит объект с единственным свойством constructor - которое ссылается на функцию-конструктор. Т.е. MyFunc.prototype.constructor == MyFunc. И еще в prototype есть поле __proto__.
        ~     Т.е. если ниего не менять, то при создании объекта через эту функцию, новый объект будет наследоваться от этой функции т.е. myObj.__proto__ === MyFunc.prototype а у этого prototype есть поле __proto__ которое будет ссылаться на Object.prototype
        ~     Соответственно, если мы в фуккции к prototype присвоем объект, то мы тем самым потеряем constructor. По этой причине либо добавлять поле в prototype - и туда что то помещать (MyFunc.prptotype.newField = ...). Либо потом добавить constructor: MyFunc.

        ~     var square = new Function('n', 'return n * n;');  - так можно создать новую функцию из строки.
            console.log(square(5));

        ~    Среди свойств объекта Function можно выделить следующие:
                arguments:   массив аргументов, передаваемых в функцию
                length:      определяет количество аргументов, которые ожидает функция
                caller:      определяет функцию, вызвавшую текущую выполняющуюся функцию
                name:        имя функции
                prototype:   прототип функции
            Среди методов надо отметить методы call() и apply().

	Каждая функция имеет свой объект прототипа. Когда функция используется в роли конструктора, вновь созданный объект наследуюет свойства этого прототипа.
			Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта. По сути prototype это поле.
	В качестве прототипа они имеют объект Function.prototype, который в свою очередь наследует от Object.prototype.
	В Function.prototype содержится много дополнительных свойств и методов, которые наследует от него любая функция (call, apply, isPrototypeOf).

	Функции в JS являются объектами.
		По этому можно присвоить значение их свойствам и вызвать их функции.
	Имя функции, это переменная, которой присваивается объект новой функции и можно получить через name. Т.е. myFunc.name
	lenght - содержит количество параметров функции в ёё объявлении
	
	Свои свойства можно задать так:
		function sayHi() {
			alert("Hi");
			// давайте посчитаем, сколько вызовов мы сделали
			sayHi.counter++;
		}
		sayHi.counter = 0; // начальное значение
	Свойство, это не есть переменная.
		
	Пример:
		function m(...) {...}						- Иструкция объявления функции
		var nameFunc = function(...) {...};			- Выражение определения функции
		var nameFunc = function name(...) {...}; 	- имя name доступно только в области видимости функции (допустим для рекурсии).
		data.sort(function(a,b) {return a-b;});
		var f = (function(x){return x}(10));		- тут-же вызвали.
	
	Как методы:
		var calculator={operand1:1,
			operand2:1,
			add:function(){
				this.result=this.operand1+this.operand2; - !!! важно это
			},
			add1(){...} //а можно и так
		};
		calculator.add();
		calculator.result		- важно это
		
	Анонимная функция:
		(function(){...}()); #() - это ее вызов. А вот скобка перед function - добавлена спациально иначе без ( интерпретатор посчитает function как инструкцию объявления функции. А со скобокой - интерпретатор воспринимает как выражение определения функции.

	Замыкания(203(209)):
		Лексическая область видимости: - при выполнении функций действует область видимости переменных, которые имелись на момент их определения, а не на момент их вызова.
			Т.е. функция имеет ссылку на текущую цепочку областей видимости.
			
		У каждой выполняемой функции, блока кода, и скрипта, есть связанный с ними внутренний скрытый объект, называемый лексическим окружением LexicalEnvironment.
			- Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).
			- Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок). Конечным лексическим окружением, является глобальным лексически окружением.
				Т.о. переменная это свойства этого скрытого объекта. И получить или изменить переменную означает получение или изменение свойства этого объекта.
				
		Функция объявленная через Function Declaration можно вызывать до того как оно пределена. В отличии от объявленной через let.
		
		При каждом новом вызове/выполнении функции, создается новое лексическое окружение для хранения локальных переменных и параметров вызова (т.е. между вызовами переменные будут свои и независимые).
			Т.е. если есть внешняя функция и внутренняя, то при получении через return 2х экземпляров внутренний функции у этих 2х экземпляров будет различное состояние переменных внешней функции, и они не будут оказывать влияние друг на друга.
				Т.к. при создании обращении к вншений функции создается новое лексическое окружение.
			
		Когда вызывается функция - интерпретатор создает новый объект, хранящий локальные переменные, и добавляет его к имеющейся цепочке, образуя новую, более длинную цепочку объектов-определяющих переменные, которая представляет область видимости функции.
			Каждый раз, когда вызывается внешняя функция(для нее создается новое лексическое окружение), внутренняя функция объявляется заново (соответственно у внутренней функции имеется своя цепочка объектов). И если происходит возврат внутренней фукцнии из обрамляющей функции - то объекты и переменные обрамляющей функции сохраняются в ссылках внутренней функции. И удаление/очищение происходи, когда перестает использоваться внутренная функция - т.е. удаляется сборщиком мусора - это и есть замыкание.
				Допустим в C подобное не возможно - так как функция находится в стеке вызовов, и при выходе из обрамляющей функции все переменные обрамляющей уничтожаются вместе с этим стэком.
			Лксическая область видимости - при выполнении функций действует область видиомости перменных, которые имелесь на момент их определения, а не на момент вызова. Для этого и создается на текущую область видимости.
			стр. 204(210)
			
		new Function(...)
			Для такой функции, ссылка не на внешнее лексическое оркужение, а всегда на глобальное.
			
		
			with - Добавляет в цепочку поиска переменной еще один объект. #Говорят устаревшая функция.


		Функция получает текущее значение внешних переменных, то есть, их последнее значение.
			- Старые значения переменных нигде не сохраняются. Когда функция хочет получить доступ к переменной, она берёт её текущее значение из своего или внешнего лексического окружения.
			- При запуске функции для неё автоматически создаётся новое лексическое окружение, для хранения локальных переменных и параметров вызова.


	this:
		1. У стрелочных функций нет this - по этой причине всегда берется this из окружающего контекста, где объявлена эта стрелочная функция. И это значение будет всегда с этой стрелочной функцией (как я понял раз и на всегда т.е. постоянная завязка).
		2. Для обычной же фнукции, если ее вызывать как самостоятельную функцию, this всегда берется глобальный для браузера а для NodeJS объемлющей фнукции но там нужно смотреть на наличие свойств. И если это строгий режим, то всегда будем иметь undefined т.к. this в строгом режиме undefined.
			2.1. По этой причине если есть вложенная функция в другую функцию, и эта вложенная функция использует this то у этой вложенной функции, this будет равен глобальному объекту(так как по факту она не вызывается через объект). Если это строгий режим, то undefined.
			2.2. Если мы функцию вызываем через объект, то this будет соответствовать этому объекту.
					Аналогично и с bind. Но bind по факту создает копию функцию, в которой this будет привязан навсегда, и будет являеться тем, что передали в bind.
			2.3. И еще момент, привязка к объекту работает только при указании скобок. Без них произойдет потеря привязки к объекту.
				let a = obj.f(); 
				let b = obj.f;//вот здесь произойдет потеря привязки к объекту.

		let user = { name: "Джон" };
		let admin = { name: "Админ" };

		function sayHi() {
		  alert( this.name );
		}

		// используем одну и ту же функцию в двух объектах
		user.f = sayHi;
		admin.f = sayHi;

		// вызовы функции, приведённые ниже, имеют разное значение this
		// "this" внутри функции является ссылкой на объект, который указан "перед точкой"
		user.f(); // Джон  (this == user)
		admin.f(); // Админ  (this == admin)
------------
	У функции конструктора есть свойство ptototype, которое используется только при создании объекта через new. Т.е. после того как создался объект через new это свойство уже для созданного объекта не имеет ни какого значения/влияния.
		Т.е. происходит следующее, в __proto__ записывается ptototype для создаваемого объекта.

	По умолчанию в свойсве prototype находится свойство constructor - который ссылается на функцию-конструктор, что используется при создании объекта через new.
		Когда мы в функции-конструктор добавляем поля/свойства, мы записываем из в prototype. 

	По этому прямо в свойство prototype ничего не желательно записывать(т.е. никакой иной объект или ссылку на объект), иначе потеряем constructor.
	Если уж хочется записать в prototype что-то, то можно это сделать так Rabbit.prototype.jumps = true. Т.е. добавить еще одно свойство к prototype.

	Задача конструктора, записать в this необходимые значения. Именно выставить поля в нужные значения.

	Если в конструкторе есть return - то будет возвращен не this а объект что возвращаем через return. Если возвращается примитивное значение, то оно будет отброшено! Т.е. вернется this, как и в случае если бы был просто return без всего.

	---
	Функции - это объекты встроенного конструктора Function. Все методы call/apply берутся из Function.prototype.
		По этой причине у функции тоже есть __proto__
		Все что будет записано в prototype будет доступно в созданных объектах.

=============================================================================
Классы:
	Вот что на самом деле делает конструкция class User {...}:
	Создаёт функцию с именем User, которая становится результатом объявления класса. Код функции берётся из метода constructor (она будет пустой, если такого метода нет).
	Сохраняет все методы, такие как sayHi, в User.prototype.
+++++

	Если два объекта наследуют свойства от одного и того же объекта-протоипа, говоря, что они принадлежат одному классу.
	Если два объекта наследуют один и тот же протоитп - означает, что они были созданы и проинициализированны с помощью одного конструктора.

	Получение прототипа:
		obj.constructor.prototype. Объекты созданные с помощью new наследуют свойство constructor - ссылающееся на функцию-конструктор. А вот функция конструктор имеет свойство prototype - которое определяет прототип объеквто созданных с помощью этого конструктора.

		function Range (f, t){
			this.f=f;
			this.t=t;
		}												#На данном этапе, значением свойства prototype является объект, который имеет единственное неперечеслимое свойство constructor. 
														#Значением свойства construcor является объект функции. Т.е. ссылается на конструктор.

		Range.prototype = {								#свойству присваивается новый объект, содержащий методы класса. Так как мы переопределям prototype - у нас теряется constructor.
			constructor = Range;						#Добавим его!
			sum: function(...){return this.f+this.t;},	
			...
		};
		var r = new Range(1,3); 	# новый объект создается автоматически перед вызововм конструктора и доступен в конструкторе как значение this.
		r instanceof Range; 		# проверяет, наследует ли объект свойство Range.prototype.

	Range.prototype.includes = function(x) {return this.x}; # Добавление к прототипу нового метода.

	Классы:
		function Point(x, y){
			this.x=x;
			this.y=y;
		}
		var p = new Point(1, 1);

		Методы объектов определяются за счет присваения функций свойствам объекта-прототипа, ассоциированного с функцией-конструктором.
		Point.prototype.r = function(){
			return this.y+this.x;
		};
		Теперь объект p типа Point (и все последующие объекты Point) наследуют метод r()
		p.r()


	Прототипы
		- Каждый объект имеет внутреннюю ссылку на другой объект, называемый его прототипом.
		- У объекта-прототипа также есть свой собственный прототип и так далее до тех пор, пока цепочка не завершится объектом, у которого свойство prototype равно null.
		- Каждый объект содержит ссылку на свой объект-прототип.
		- При попытке получить доступ к какому-либо свойству объекта, свойство вначале ищется в самом объекте, затем в прототипе объекта, после чего в прототипе прототипа, и так далее. Поиск ведется до тех пор, пока не найдено свойство с совпадающим именем или не достигнут конец цепочки прототипов.

		this - указывает на наследующюий объект и окружение наследующего объекта, а не на прототип, в котором функция является собственным свойством.

	Функция - это тоже объект и ей можно оперировать так же как объектом.

=============================================================================
Promise

	Это объект - который принимат в себя функцию - которая собственно и выполняется сразу же после создания Promis.
		Функция, что передается в Promise - имеет два параметра:
			Первый парамет - олицетворяет функцию, что будет вызвана при успешном выполнении.
			Второй параметр - олицетвоярет функияю, что будет вызвана при неудачном выполнении.
		
		Обе функции-параметры вызываются программистом из кода.
		
		Сама реализация этих функций прокидывается/указывается через then, catch, finally - пропускает ошибку и результат дальше catch или then.
		let a = 'a'
		let prom = new Promise(function (res, rej){ //эта функция называется исполнитель, как только создается Promis эта функция сразу же начинает исполняться. При этом res и rej нужно вызывать в коде самостоятельно.
			//throw new Error("err"); - поймает catch
			if (a=='a'){
				res("Успех")
			}else{
				rej(new Error())
			}
		})
		
		prom.then(funcForRes(...){...}, funcForRej(...){...}) //если промис еще не закончил исполнение, then будет ждать окончания выполнения.
		//.catch(f) это тоже самое, что promise.then(null, f)
		//.finally(f) похож на .then(f, f) // но обработчик вызываемый из  finally не имеет аргументов.
		
		then - возвращает promise. new Promise(...).then(function(res){...; return someRes_1}).then(function(res){...; return someRes_2}) второй(в этом случае в последний) then будут выполняться для Promise результатом someRes_1;
		
		это отличается от prom1.then(..); prom1.then(...) в этом случае все для одного prom1 будет выполнено.
		
		Исключение или ошибка обрабатывается в ближайшем .catch(...)
		
		Если из catch нужно выбрасить исключение для дальнейшей обработки в следующих в цепочке catch то просто выбрасываем throw и все, далее будет обрабатывать следующий cathc. Если не выбросили исключение, то будет работать далше then если он есть.
			.catch перехватывает все виды ошибок в промисах: будь то вызов reject() или ошибка, брошенная в обработчике при помощи throw.
		
	Как правило в rej передается ошибка/исключение - рекамендуется. Да можно передать все что угодно как и в res - но рекамендуется объект Error.
		Аналогично, если в ходе выполнения произойдет исключение - буте перехват catch.
	
	Статья	
		"Разбираемся с Async/Await в JavaScript на примерха"
		
	async-функция всегда возвращает промисы. Даже если возвращаемый объект и есть промис - его результат заворачивается в новый промис.
	
		async function fn(){
			return 'hello';
		}
		fn.then(console.log);
		
	Полностью тождественно:
	
		function fn(){
			return new Promise.resolve('hello');
		}
		fn.then(console.log);
		
	Аналогично если произодейт ошибка, то ошибку нужно по аналогии перехватывать.
		async function foo(){
			throw Error('bar');
		}
		foo().catch(console.log);
		
		// работает только внутри async–функций. Заставляет ждать, пока промис не выполнится.
		let result = await promise;
==================
Пример НЕправильной но возможной работы с функциями как конструкторами.
	function A(){
        this.a = "aaa";
        
        this.inerA = function (){
            console.log("From Function innerA");
        } // говорят, что так делать плохо. Так как при каждом инсанцировании через new, выполняется блок функции "А" и внутри каждый раз для каждый функции создается ананимная функция - что потребляет память. По хорошему все нужно прятать в prototype.
    }
    
    function B() {
        this.b = "bbb";        
        
        this.inerB = function (){
            console.log("From Function innerB");
        }        
    }
    
    function C(name) {
        this.c = "ccc";
        
        this.inerC = function(){
            console.log("From Function innerC");
        }
        this.inerC();
    }
    
    A.prototype.outerA = function(){
        console.log("From Function outerA");
    }
    
    //a = new A();    
    //B.prototype = a; // B.prototype используется одни раз только при new B(); и все, после создания объекта через new изменения в prototype не влияют на созданный объект.
    B.prototype = new A(); // вот здесь мы поетряли конструктор, т.к. объект хранящийся в prototype был перезаписан новым объектом.
    B.prototype.outerB = function (){
        console.log("From Function outerB");
    	}//здесь мы записал в объект "a" фнукцию outerB.  Ибо прототип указывает на объект "а". А вот в объекте "а" есть прототип куда записан outerA()
    //b = new B();    
    //C.prototype = b;
    C.prototype = new B();
    C.prototype.outerC2 = function (){
        console.log("From Function outerC2");
    }
    c = new C();
	
==================
//Второй вариант первого примера. 
//Тоже не является правильным. т.к. в конструктор не нужно добавлять методы.
//Посуть остается как пример.
    var ooo = Object.create(Object.prototype);
    
    function A(){
        this.a = "aaa";
        
        this.inerA = function (){
            console.log("From Function innerA");
        }        
    }
    
    function B() {
        this.b = "bbb";        
        
        this.inerB = function (){
            console.log("From Function innerB");
        }        
    }
    
    function C(name) {
        this.c = "ccc";
        
        this.inerC = function(){
            console.log("From Function innerC");
        }
        this.inerC();
    }
    
    A.prototype.outerA = function(){
        console.log("From Function outerA"); //В прототип конструктора добавил свойство outerA - его больше нигде нет. Он в прототипе конструктора. А прототип констукртора так же имеет ссылку прототип. 
    }
    a = new A();
        
    b = new B();
    b.__proto__ = a; //Прототипом стал объект "a" - который в себе содержит ссылку на прототип конструтора.
    b.__proto__.outerB = function (){ //В объет "а" добавили новое свойство. Т.е. это свойство будет в объекте "а"
        console.log("From Function outerB");
    }
    
    c = new C();
    c.__proto__ = b;
    b.__proto__.outerC = function (){
        console.log("From Function outerC");
    }
    
    //c.__proto__ == b; true
    //c.__proto__.__proto__ == a; true
    //c.__proto__.__proto__.__proto__ == A.prototype; true
    //c.__proto__.__proto__.__proto__.__proto__ == Object.prototype; true
	
=======
  //Самый правильный способо! 
    //Как говорят ребятки, в конструктор не нужно добавлять др. методы, в конструкторе должны содержаться только поля. Обусловлено это тем, что при каждой инициализации объекта через new будет выполняться тело фонуции-конструктора и будут создаваться каждый раз аноноимные функции в таком же кол. сколько их объявлено в конструкторе.
    "use strict";
    
    function A(){
        this.a = "aaa";
        
        this.inerA = function (){ //т.е. вот так делать не хорошо, нужно выносить все в прототип.
            console.log("From Function innerA");
        }
    }
    
    function B() {
        A.call(this);        
        this.b = "bbb";    
    }
    
    function C(name) {
        B.call(this);    
        this.c = "ccc";
    }
    
    A.prototype = Object.create(Object.prototype, {firstProp: {value: "first"}, secondProp: {value: "second"}});//это не нужно делать, добавлено просто для просмотра иерархии.
    //Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors. 
    //Или по другому: Объект, который станет прототипом вновь созданного объекта.
    //firstProp и secondProp - должны быть объектами.
    
    A.prototype.outerA = function(){
        console.log("From Function outerA");
    }
    B.prototype = Object.create(A.prototype); //Здесь по сути создали объект, у которого прототип будет смотреть на 
    //prototype заданный для конструктора используется только один раз, когда выполяется new. Дальше работа идет с __proto__, и prototype никак не влияет.
    B.prototype.constructor = B; //после изменения prototype нужно обновить и конструктор, иначе конструктор у B будет А.
    
    B.prototype.outerB = function (){
        console.log("From Function outerB");
    }
    C.prototype = Object.create(B.prototype);
    C.prototype.constructor = C;
    
    C.prototype.outerC = function (){
        console.log("From Function outerC");
    }
    var c = new C();
	
=================================================================================
'use strict'
var promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("result")
    }, 3000);
});
promise.then((result) => {console.log(result)}, (error) => {console.log(error)});
//promise.then(functionOnResolve, functionOnReject);
function A(someFunction){
    this.someFunction = someFunction;
}
A.prototype.then = function(firstFunc, secondFunc){
    this.someFunction(firstFunc, secondFunc);
}
a = new A((aFunc, bFunc) => {aFunc();});
a.then(()=>{console.log("Hello")},()=>{console.log("Upss")});
=============================================
Статья про память https://habr.com/ru/company/skillbox/blog/554018/


https://habr.com/ru/company/skillbox/blog/512432/

https://habr.com/ru/company/haulmont/blog/443242/


====================================================================================================================================================================================
import name, {name1} from './module.js';

Без скобок указывается, если в импортированном модуле сделано через default:
	export default name;
		При этом default может быть только один.
Если же name1 не экспортируется через default то нужно заключить в фигруные скобки.
	А можно еще так:
		export {sayHi, sayBye};

		import {sayHi, sayBye} from './say.js';
		sayHi(...)
			или так
		import {sayHi as hi, sayBye as bye} from './say.js';
		import * as say from './say.js';
		say.sayHi(...)

		export {sayHi as hi, sayBye as bye};