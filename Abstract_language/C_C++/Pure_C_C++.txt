Основная книга - Харви Дейтел, Пол Дейтел "Как программировать на с++"

Переменные:
	Функция полностью перекрывает именя внешних переменных своими переменными.
	Различают:
		Локальные переменные 	- переменные методов, хронятся в стеке. Не сохраняют свои значения, так как разрушаются при выходе из блока функции
		Глобальные переменные	- переменные объявленные в файле вне метода. Имеют доступ к ним отовсюду + и сохраняют свое значение.

Связи:
	Внешние		- функции и глобальные переменные имеют внешние связи.
	Внтуренние	- глобальные объекты объявленные с спецификатором static имеют локальные связи. Они доступны лишь внутри файла в котором описаны.
	Отсутствие	- локальыне переменные не имеют связи (видимы внтури лишь своего блока).

	extern - указывает что объявляемый объект обладает внешними связями в рамках всей программы.
		определение - выделяет память для объекта.
		объявление - указывает имя и тип объекта.
			В программе может несколько объявленией объекта но лишь одно определение. В программах объявление и есть ее определение.
			extern позволяте объявить ее не определяя. Т.е. что бы обратиться к переменной в др. части программы ее нужно объявить используя спецификатор extern. Часто создают файл с переменными глобальными а в функциях уже ссылаются на них.
			Необходимо когда, переменная опеределена либо в др. файле либо позже по году.

	static
		Локальная - компилятор выделяет для нее место как и для глобальной переменной, но доступ к ней будет локальным. Т.е. это та переменная, что сохраняет свое значением между вызовами фукцнии.
			Локальную статическую переменную можно инициализировать, но инициализация будет выполнена лишь первый раз при входе в блок.
		Глобальная - делает ее глобальной только в рамках текущего файла и делает ее недоступной из др. файлов.


Области памяти (следуют друг за другом):
	- Data - статические и глобальные переменные, которые явно инициализируются значениями. Может быть разбит на RO и RW.
	- BSS(block, started by symbol) - для глобальных или статических переменных без явной инициализации.
	- Куча (heap) - выделяется через malloc и чистится через free
	- Стек вызовов - обычно растёт "навстречу" куче, то есть с увеличением стека адрес вершины стека уменьшается. Набор значений, которые кладутся на стек одной функцией, называются фреймом. После выхода из функции стек освобождается от фрейма. Один фрейм хранит как минимум одно значение - адрес возврата. Каждый раз, когда мы создаём локальные переменные, они располагаются на стеке. Как только мы выходим из функции, стек очищается и переменные исчезают. Вызов функций и передача параметров также происходит через стек.
	- Сегмент кода - или текстовый сегмент, или просто текст, содержит исполняемые инструкции. У него фиксированный размер и обычно он используется только для чтения, если же в него можно писать, то архитектура поддерживает самомодификацию. Сегмент кода располагается после начала стека, поэтому в случае роста он [стек] не перекрывает сегмент кода. 

Классы памяти:
	auto		- Автоматический класс памяти - он по умолчанию, по этому часто не ставится. Время жизни локальное. Относится к переменным функции итд. auto a = 0; Ониже локальные переменные.
	register	- Подсказка для компилятора, что можно поместить данную переменную в регистр. Но само собой, компилятор может проигнорировать исходя из анализа при компиляции. register int counter = 1; т.е. применяют для часто меняющихся значений, это счетчики итд.

	Статический класс, с глобальным временем жизни. Живут с начального момента жизни приложения, память выделяется сразу.
	extern		- Имена функций и глобальные переменные
	static		- Локальные переменные.

true/false:
	В С true все что не 0, как отрицательнрые так и положительные ненулевые значения являются true.

Методы:
	1. Встраиваемые функции inline - используются редко, и подставляются целиком в то место где вызываются. Используются только для мелких функций.
	2. Возможна поддержка методов со значениями переменныех по умолчанию (для конструкторов присутствует аналогичная поддержка).
	3. Возможна работа с шаблонами функций.

Ссылки:
	int a = 1; ссылки по сути являются псевдонимом для исходной переменной. Передача в функцию возможна тремя способами: По ссылке, по указателю по значению.
	int &b = a; по сути аналог записи int & const b = a; - ссылка и так является константной, по этому такая запись не нужна и не используется.
		Ссылка сразу должна быть проинициализированна.


Указатели:
	NULL - нулевой указатель.
		int *prt = NULL;
		if (prt == 0){} - вообще как правило после осовобождения памяти как правило нужно занулять указатель, дабы если вдруг будет повторная попытка освободить память, мы не потерли уже др. данные.

	Константные указатели:
	1.	const char * ptr0 = NULL; - Не могут менять значение того на что ссылаются. Но могут указывать на др. объекты
		char a = 0, arr[] = "Hello";
		prt0 = &a; prt0 = arr;
		
	2.	int *const ptr1 = &a; не может ссылаться на что то другое, но содержимое может меняться.

	3.	const int *const prt2 = &a; не может ссылаться на что-то др., и не может менять значение.

	Приведение типов с указателями:
		const int N=100
		const int M=100;
		int **a = NULL;
		a = (int**) malloc(M*sizeof(int*));
		//много одномерных массивов
		for (int i = 0; i<M; i++){
			a[i] = (int*)malloc(N*sizeof(int));
		}


		a = (int**) malloc(M * sizeof(int*));
		//а здесь мы выделяем за раз всю память для первого элемента, а потом делим его/нарезаем
		a[0] = (int*) malloc(M * N * sizeof(int));
		for (i = 1; i < M; i++) {
    		a[i] = a[0] + i * N;
		}

		а еще быстрее
		a = (int**) malloc(M * sizeof(int*) + N * M * sizeof(int));
		a[0] = (int*)(a + M);
		for (i = 1; i < M; i++) {
    		a[i] = a[0] + i * N;
		}


Массивы:
	Инициализация многомерного массива:
	int a[][2] = {0}; int a[][2][24] = {0};
	int a[2][3] = {1,2,3,4,5,6}; или int a[2][3] = {{1,2,3}, {4,5,6}}; или int a[2][3] = {{1,2,3}, {4,5}}; там где 6 не указана, будет заполнено 0м.


	Одномерный массив всегда выделяется последовательно по адресам. По этому можно подменять имя масива на указатель.
	А вот двумерный массив это последовательно выделенные адреса указателей при этом куда они указывают, может быть неопределенным, по этой причине подмена имени массива на указатель невозможен.

		char b[4] - соответствует строке ниже.
		char *b = (char*)malloc(4);


		char cc [2][2] соответствует строке ниже	

		char **c = (char**)maloc(2*sizeof(char*));
		for (int i =0;i<2){
			c[i] = (char*)malloc(2); //указано число непосредственно, так как  malloc выделяет в байтакх, а у нас char - 1 байт, соответственно под 2а символа, можно было бы c[i] = (char*)malloc(2*sizeof(char));
		}

	Просто массив:
		char *ptrChar = {'a', 'c', 't'};

	Массив указателей:
		char *strinG[4] = {"Один", "Два", "Три", "Четыре"} //при этом char **strinG = {"Один", "Два", "Три", "Четыре"} неверно. Я так и не поля почему, ведь именно здесь я выделил в памяти подрят все переменные. Т.е. по сути одномерный массив с разбивокй на строки.

Указатели ни функции:
	int method1(int, int);
	int method2(char, char, int (*)(int, int));
	int main(...){
		int (*PtrMethod1)(int, int); // объявляем указатель на функцию
		PtrMethod1 = method1;
		PtrMethod1(1, 2);
		int method2('a', 'c', PtrMethod1);  //а можно просто было бы без объявления указателя. Прямо взять и отправить имя int method2('a', 'c', method1);
	}
	...
	int method2(char, char, int (*pMeth)(int, int)){
	... 
		int i = (*pMeth)(1, 2); // а можно int i = (pMeth)(1, 2); первый вариант. дабы показать что происходит разыменовывание.
	...
	}



Классы
	Деструкторы:
		Вызываются после выхода из той области где был объявлен соответствующий объект.
		Как правило имеет смысл, при создании динамической памяти в этом классе или при использовании открытии файла, подключения итд, итп.
		Деструкторы вызываются в обратном порядке по отношению к конструктарами при наследовании.
		А при объявлении допустим в main обратно порядку объявления (т.е. снизу вверх). ?

	Перегрузка операторов:
		Перегрузка рабтает только для типов создаваемых пользователем и не работает с дефолтными типами.
		Перегрузкой невозможно изменить приоритет операций. Нельзя изменять количество перандов, т.е. если была унарная операция или бинарная то так она такой и останется.

		Функции-операции должны быть либо членами либо друзьями. Но для ((),[],->,=) должны быть членами.
		При реализации как член класса, крайний левый элемент или единственный элемент должен быть либо объектом этого класса либо указателем на объект этого класса. Если крайний левый элемент не является (по реализацци) экземпляром тек. класса то данная функция-перация не может быть реализована как функция-элемент (допустим для cout<< classObject когда левый операнд типа ostream, аналогично и для cin << тип должен быть istream), а должна бытьреализована как друженственнная функция.

		friend ostream &operator >> (ostream &, const MyClass &); //переопределяем операнд >>

	Приведение типов:
		Создается спецальный функция-элемент. И данная функция не может быть дружественной, а должна быть нестатической функцией-элементом.
		Называется конструктор преобразования.
		A::operator int() const; 
		A::operator char *() const;
		Самое интересное если компилятор встречает конструкцию вида cout << objA; то он самы вызовит конструктор преобразования.

	this:
		Имеет такой же смысл как и в Java.


	Инициализация в объектах:
		Инициализация полей объекта будет завершена к моменту выполнения входа в конструктор.
		В калссах к моменту вызова конструктора, константы и ссылки должно быть проинициализоврованны. Если они по коду не проинициализированны, то нужно использовать список инициализации.
		Инициализация полей будет выполнена в том порядке в котором они объявлены а не в том, в котором перечислены после конструктора (т.е. инициализаторе элементов).
		class A{
		public:
			const string name;
			int &age;
			А (string = "парампарам", int = 2); //Как я понял, это конструктор поумолчанию. Дейтл, глава 6 стр 430
			A(string str, int i) : age(i), name(str){ //аналогичным образом можно инициализировать поля объекты. Просто в этот конструктор А добавляется поля, что необходимы конструкторам инициализируемых полей. стр. 467 Дейтл

				....
			}
		}

		static
			Статическим данным-элементам можно задать начальные значения один(и только один) раз в области действия файл. 
			К статическим переменным класса как и в ява возможне доступ без объекта а через имя класса. И по аналогии существует до создания объекта данного класса.
			Для работы со статической переменной создается статическая функция в рамках класса, все так же как в Java.
			Обращние к статической функции или полю до создания объекта выполняется как Aclass::NameMethod(); Aclass::NameValue();

		const для методов
			Функция класса объявленная с const, трактует this как указатель на константу.
			Вообще тип this в методе класса X будет X*. Но если метод класса объявлена как const, то тип this будет const X*. 
			В таких методах ничего нельзя присоить переменным, кроме тех что объявлены как static или mutable.
			Также const-функции не могут возвращать не const ссылки и указатели на данные класса и не могут вызывать не const функции класса.

			В классе может быть две одноименных функции но одна с const др. без. И в зависимости от объявления переменной класса, будет выбрана соответствующая функция.

		Объявление вида const CFoo p;.
			Экземпляр класса CFoo, объявленный таким образом, обещает сохранить физическое состояние класса, не менять его. Как следствие, он не может вызвать не const функции класса CFoo. Все данные, не объявленные как const, начинают трактоваться как const. То есть
			int становится int const
			int * становится int * const
			const int * становится int const *const

	Порядок вызовов конструктора и деструктора (Дейтл стр. 436):
		- Для глобальных объектов: конструктор вызывается до момента вызова main. А деструктора, после завершения main.
		- Автоматические локальные переменные: конструктор вызывается при входе в блок и на точке объявления обявления объекта, а деструктор по выходу из блока.
		- Статически локальные перменные: вызываются в блоке в месте где объявлен объект, а деструкторы вызываютяс в момент завершения main, или когда вызывается функция exit().

	Побитовое копирование (присваивание):
		Проблемы возникают, когда внутри объекта выделяетяс динамическая память или присутствуют иные ресурсы.
		Объекты как и др. переменные при передаче функции могут передаваться как ссылка, как указатель, и по значению (вот здесь то и есть побитовое копирование). Возвращение аналогично: ссылка, указатель, по значению. Т.е. по факту создается копия.
		Вообще считается плохим тоном передачи объекта по значению, хорошей альтернативой является передача по ссылке как const.

	Наследование:
		class А : public B{}; //
			Защищенные элементы доступны только элементам самомго класа, наследникам и друзьям.
		Модификатор доступа при наследовании:
			1. Открытое наследование. Т.е. наследуются открытие и защищенные элементы и эти элементы имеют аналогичные спецификаторы доступа в дочернем классе.
			2. При защищенном наследовании открытые и защищенные элементы базового класса становятся защищенными элементами дочернего класса.
			3. При закрытом наследовании открытые и защищенные элементы базового класса становятся закрытыми элементами дочернего класса.

		Общее
			1. Для переопределения функции базового класса, в дочернем классе нет необходимости сохранять аналогичную сигнатуру. Достаточно иметь аналогичное имя. ??? как так?
			2. При использовании функций друзей (не важно это переопределение операций) необходимо ссылаться к переменным класса через переданный объект. Аналогично и с перегрузкой.
			3. Вызов метода базового класса B::methodOfB(); такая запись используется для вызова внутри класса А. А для доступа через объект класса А к этому методу исползуется запсь a->B::methodOfB();

		Порядок вызовов:
			1. Конструкторы вызываются в порядке от базововго класса и так вниз до дочернего.
			2. Деструкторы вызываются в обратном порядке сначала самый дочерний, потом по иерархии вверх до самого базового.
			3. Элементы класса инициализируются в том порядке в котором они объявлены в поределении класса и не зависит от порядка перечисления в инициализаторе
			4. Аналогично и конструкторы базовых классов конструируются в том порядке в котором они перечислены в определнии класса, и не зависиот от того в какой последвоательности перечислены в описании конструктора производного класса.

	Множественное наследование:
		Пропустил

	Виртуальные функции:
		По сути это аналоги абстрактных методов в Java.
			virtual void draw() const;
		- Функция является виртуальной на всех уровнях если ее не переопределяли на одном из уровне наследования. Но некоторые программисты предпочитают описывать ее как виртуальной на каждом уровне, якобы добавляет ясности.
		- При переопределении виртуальной функции кроме сигнатуры функции еще должен совпадать возвращаемый тип.
		- Если дочерний класс не переопределяет эту функцию, то он также является виртуальным.

		Абстрактным класс делается когда одна или более ее функций объявляется чисто виртуальной:
			Т.е. это та функция. у которой в ее объявлении тело определено как 0 (инициализатор равен 0). 
			virtual float method1() const =0;
		

Потоки ввода-вывода IO:
	Поток это просто последовательность байтов. (Из памяти в устройство или из устройства в память)

Умные указатели:
	Реализуются через стандарт. Просто передается в шаблонн объект что хотим создать, а на выходе получаем умный указатель. У него оператор -> перегружен, что дает возможность работать словно мы имеем дело с сырым указателем.
	

QT:
	Слоты - это методы, что обрабатывают сигналы.
	Макрос Q_OBJECT является при этом обязательным, он добавляет метоинформацию об объекте необходимую для работы с сигналами и подменяет объявления signal: для возможности компиляции в с++