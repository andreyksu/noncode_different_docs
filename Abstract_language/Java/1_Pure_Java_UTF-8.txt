a%b = a-(a/b)*b

Package
	Подпакет не является частью пакета, и классы находящиеся в нем, не относятся к пакету, а только к подпакету.
		Для того, чтобы создать подпакет, не надо предварительно создавать пакет. С др. стороны включение пакета не означает включение подпакетов.

	Если член каласса не отмечен ни одним из модификаторов доступа private, protected, public - то поумолчанию к нему применяется пакетный доступ(default access). К такому члену может обратиться любой метод любого класса из того же пакета. Но не методы из родительских пакетов или дочерних пакетов.

	Пакет ограничивает доступ к классу целиком - если класс не помечен модификатором public, то все его члены, даже открытые(public), не будут видны из др. пакетов.


Static
	При использовании статических полей или методов лучше использовать вид nameclass.field а не через экземпляр класса instanceclass.field
	В первом случае более красивее и дает возможнсть компилятору для оптимизации.
	Статические данные существуют на уровне класса, а не статические данные лишь на уровне объекта.
	Не возможно вызвать нестатические методы из статических. Обратное возможно.
	У статических методов нет ссылки this.
	Для статических методов не работает плиморфизм. Т.е. B extends A (у А есть статический метод m. В переопределяет метод статический метод m) А a = new B(); a.m - будет вызван именно метод класса А.

Наследование
	Переопределяются методы, только те, что не являются закрытами или final.
	При наследовании static методы не перекрываются. Т.е. если есть в А классе static method() и в B классе static method() то при записи ниже, будет использоваться метод класса А.
	B extends A; 
	A b = new B();
	b.method();
	!!! Нежелательно использовать в конструкторе А методы, что могут быть переопределены в дочерних классах. Это может привести, к тому что в методе класса B будут использоваться еще непроинициализированные переменные, что приведет к ошибке.

	!!! Для пременных класса, понятие переопределение также не распостроняется. Если в классе А оперделить переменную var, и в классе В определить var, то будет две переменных, и доступ к ним определяется из соответствующей области видимости. Т.е. методы класса А будут видеть только свою переменну и будут работать с ней, так как переменной класса В не видно.

Инициализация
	- Члены класса по умолчанию инициализируются нулями для примитивных переменных или же Null для объектных типов.
	- Для переменных же метода, приметивные типы инициализируются случайным значением. Java в этом случае выдаст ошибку. Т.е. локальные переменные должны быть проинициализированны. Пусть null или 0 но инициализация должна быть.
	- Статические поля инициализируются либо при первом обращении, либо при первой инициализации класса. Если к статическому полю не было обращения, то и инициализация не будет выполнена (при условии что сам класс не был проинициализирован).	
	- Сначала иницилизируются статические поля, потом нестатические поля в порядке их объявления. При этом статические поля инициализируются до.

Операторы
	Операторы == и != сравнивают не объекты, а лишь ссылки. Если ссылки указывают на один объект то == будт true
	Для равнения содердимого используется метод equals. И этот метод в своем классе можно реализовать так как нужно в данном контексте.

Приведение типов
	char a = 1;
	int t = (int)a

Foreach
	Работает для всех объектов что поддерживают\имплементируют интерфейс Iterable

Switch/case
	Работает только с int или char и enum
	Если break нет, то выбор пойдет дальше по перебору.
	
this
	При вызове одного конструктора в конструкторе через this, вызов второго запрещено.
	Более того вызов конструктора в конструкторе должна быть превая операция.
	Аналогично и для super.
	
Порядок инициализации объекта
	public class Child extends Parent
		Статические поля класса Parent;
		Статический блок инициализации класса Parent;
		Статические поля класса Сhild;
		Статический блок инициализации класса Child;

		Нестатические поля  класса Parent;
		Нестатический блок инициализации класса Parent;
		Конструктор класса Parent;

		Нестатические поля  класса Сhild;
		Нестатический блок инициализации класса Сhild;
		Конструктор класса Сhild.
		
	Конструктор по сути я вляется статическим методом (эккель стр.143) - связано с поиском Dog.class
		
Внутренние классы:
	- Внутренние классы (нестатические классы), не могут содержать статические поля. При этом может использовать статические поля внешного класса. Объясняется это тем, что нестатический внутренний план не существует вне объекта внешнего класса, а как следствие и не может содеражть статик. переменные.
	- Для классов созданных внутри метода, можно использовать переменные лишь final.(Внутренние классы, могут работать только с final полями ОБРАМЛЯЕМОГО МЕТОДА).
			- Вычитал в инете - используются final так как создается полная копия переменных для внутреннего/вложенного объекта и соответственно менять внутри объекта такие поля не имеет значения, так как изменение этих копий не приведет к изменению исходных полей, что лишь говорит о бесмысленности подобной операции.
			- Это раскрывается в рамках Лямбд и стримов - т.е. стейтлес. Т.е. когда мы можем потоки форкнуть и соответственно тем самым избегаем порчи данных.
	- Для вложенных классов(статических классов), можно испльзовать как сатичекие поля внешнего класса, так и сам может объявлять статические поля. При этом не может использовать нестатические поля внешнего класса(может обращаться к нестатическим членам родительского класса только через через объект внешнего класса). А внутри у себя может содеражать\объявлять поля не статики. Так же не может быть испльзован this на внешний класс.
	Для того, что бы внутренний static класс мог обращаться к нестатическим полям внешнего класса, необходимо через объект внешнего класса.

Коллекции:
	List - хранит элементы в продяке вставки.
	Set - в таком множестве, нельзя хранить повторяющиеся элементы.
	Queue - хранит элементы в порядке, определяемые спецификацией очереди.

	!!!Для создания коллекции, лучше создать ее пустой, а потом заполнить Collections.addAll(Collection<? super T> c, T... elements). Эккель стр.282.
	
	Есть еще один момент для Arrays.asList() не возможно добавлять элементы, так как внутри лежит массив и менять его размеры нельзя, т.е. add() и delete() приведут к ошибкам времени ИСПОЛНЕНИЯ.
	
	Collection описывает общие свойства коллекций List, Set, Queue.
			List - интерфейс описывающий упорядоченную коллекцию, добавляет методы работы с индексом. Но в отличии от Set - элементы могут повторяться. Vector - одна из реализаций List.
			Set - описывает неупорядоченную коллекцию, новых методов не добаляет к Collection - лишь при add не получится добавить аналогичный объект. Есть упорядоченные SortedSet и NavigableSet
			Queue -	обычная очередь.
	
		List
		ArrayList - быстрый произвольный доступ к элементам, медленные вставки/удаление эл. в середину.
		LinkidList - быстрый последовательный доступ,  быстрая операция вставки/удаления в середину. Медленный произвольный доступ к элементам.


	Iterator и ListIterator
		Первый позволяет идти вперед, второй позволяет идти еще и назад.
	
	При поиске элемента или же его удаления, используется метод equals() сравниваемого объекта;

	Set множество каждый элемент хранится в одном экземпляре. А его реализации просто по разному хранят и обеспечивают доступ. Самая быстрая выборка HashSet. TreeSet хранит объекты в отсортированном виде, по возростанию. LinkedHashSet хранит элементы в порядке добавляения.

	Аналогичная ситуация и для интерфейса Map(содержит только уникальные ключи, но значения могут быть повторяющимися):
		HashMap - содержит хеш-теблицу для хранения, что обеспечивает константное время get() и put(). Не гарантирует порядок элементов.
		TreeMap - хранит карту в древовидной структуре. Гарантирует, что ее ключи будут отсортированы в порядке возрастания ключей.
		LinkedHashMap - Уже гарантирует порядок соответсвующий при вставке. 
	
Строки:
	Полезный класс при работе с Input/OutputStream
		String(byte[] arr, String encoding) - создается Unicode строка из массива байтов который находится в кодировке encoding.
		String(byte[] arr, Charset charset) - аналогично.
		str.getBytes(String encoding); - для получения массива байтов в указанной кодировке.
	
Исключения:
	TODO: Добавить и вспомнить про наследование и ограничение на возбуждаемые исключения.
			Внимательно просмотреть как это в Stream. Говорили, что нельзя выкидывать checked исключения.

Рефлексия:
	.class - только для получения ссылки, не привиодт к автоматической инициализации объекта Class.
		Безопаснее чем forName() так как проверка проводится на этпае компиляции. Так же эффективнее так как не нужно вызывать метод.
	forName() - для получения ссылки на Class, проводит инициализацию.
	
	Метод newInstance() создает экземпляр для класса с конструктором по умолчанию. Если его нет то выкинет исключение (см. Эккель стр.405 - пример как обрабатывать исключения)
	
	Загрузка		- выполяется загрузчиком классов. Находит байт код и создает на его основе объект Class.
	Компоновка		- выделяется память для стат. полей, решаются все ссылки на классы создаваемые данным классом.
	Инициализация	- инициализируется род. класс и выполнение статических инициализаторов

	В классе Class нет конструкторов, экземпляр этого класса создается исполняющей системой Java во время загрузки классов и пердоставляется методом getClass() класса Object.
		У каждого объекта есть ссылка на экземпляр класса Class (видимо имеется только один экземпляр).

	Динамическая прокся.
	Вызов методов и добавление методов.
	
Аннотации:
	TODO: Прочитать и добавить.

Параметризация(обобщение):
	Статические методы, не имеют доступ к параметрам типа, параметризованного класса. Если нужно, то статик метод, параметризуется сам.
		То же касается и статических переменных.
	
	Стирание типа:
		Компилятр сам добавляет приведение типа где нужно для методов что возвращают значение типа, после того как тип сотрется. Либо будут созданны мостовые методы(так как стирание типа и полиморфизм плохо работают). Описано у Шилдта.
		
		Параметризация в работает только на уровне компиляции, т.е проверяются типы итд. Так как во время выполнения вся информация внутри теряется.
			Согласно Эккелю или Хорстманн - в код при компиляции добавляется необходимый cast - допустим при использовании get()  метода, что возвращает параметризованный тип (Эккель стр. 427-430).

		Параметризованный тип присутствует только при статической проверке типов, после чего каждый параметризованный тип в программе заменяется непараметризованным типов или верхним ограничением.
			List<String> и List<Integer> - во время ВЫПОЛНЕНИЯ стираются до своего низкого типа List.
			Это делается для обратной совместимости (т.е. в байт-коде нет информации о параметризации)
		Особоую роль приобретают границы - точки, в которых объект входит и выходит из метода. Именно в этих точках компилятор выполняет проверку типов и вставляет код преобразования.
			В процессе применения обобщения, исключается потребность в явном приведении и ручной проверке типов в прикладном коде.

	Ограничения:
		Для множественного ограничения, при стирании типа, везде заменяется первым ограничением, а компилятор для др. ограничений, кастит к соответствующему типу.
		Если в качестве ограничения служат так же и интерфейсы, то класс должен быть первым в перечислении ограничений.

	Обобщенные методы:
		- Обобщенные методы, могут быть опеределенны как в обобщенном классе, так и в обычном.
		- При необходимости указать явно тип для параметризованного метода(для статика) - NameClass.<Types>Method(Params) или (здесь можно применить и не для статика ВОЗМОЖНО) Method(NameClass.<Types>Params).
		
	Создание массива параметра типа:
		T[] t = new (T)Object[];
		или
		Class<T> type;
		T[] t = (T[])Array.newInstance(type, size);
		
	Создание массива для параметризованного типа:
		ArrayList<Integer>[] al = (ArrayList<Integer>[])new ArrayList[10];
		al[0] = new ArrayList<Integer>();
		
	Метасимволы:
	
			Animal

			MammalAnimal extends Animal			
			
			WildAnimal extends MammalAnimal
												Woolf extends WildAnimal 		Bear extends WildAnimal
												GreyWoolf extends Woolf
												WhiteWoolf extends Wolf

			HouseAnimal extends MammalAnimal

		List<? extends WildAnimal>  wildAnimalList; - К такой записи можно относится как к объявлению переменной. Но лучше относиться как к принимаемому параметру в методе - мы говорим что может быть принято. List содержащий Диких животны и его подклассы.

		ArrayList<Woolf> woolfList = new ArrayList<Woolf>();		ArrayList<Bear> bearList = new ArrayList<Bear>();

		woolfList.add(new Woolf());									bearList.add(new Bear());

		wildAnimalList = woolfList; 			а может 	 		wildAnimalList = bearList;

		Или переменные woolfList/bearList можно передать в метод который ждет List<? extends WildAnimal> - и что мы можем делать с этой переменной в методе, если не знаем, что было передано в этот метод т.е. что по факту находится в переданной ссылке? Это woolfList или bearList?	Как обращаться с этой переменной если мы не знаем что передали. 
			- Т.е. нужно смотреть шире, чем просто коллекция, куда вроде по логике можно засунуть и медведей и волков ведь объвили как дочерние от диких животных. Да даже в рамках коллекции, предположим что есть метод спариться(Е е) и мы получается будем спаривать медвидей и волков, если будет позволино вызывать такие методы.
				Пример:
					 someMethod(List<? extends WildAnimal> listOfAnimal, WildAnimal someWildAnimal){
					 	listOfAnimal.спариться(someWildAnimal);
					 }

					 или

					someMethod(List<? extends WildAnimal> listOfAnimal, Bear someWildAnimal){
					 	listOfAnimal.спариться(someWildAnimal);
					 }

					 и где-то в коде мы вызываем:
					 someMethod(woolfList, new Bear()); //что означает, что мы позволим спариться разным животным.

			- Можно представить просто класс, где вместо метода add(E e) будет метод doSomething(E e) - что по аналогии не будет позволено выполнить/вызвать и передать туда, что-то.
		//animal.add(...); - по этой причине положить туда, что то нельзя --- иначи получится мдеведи и волки внутри.
		animal.get(); - но можно получить, так как мы знаем что вернется WildAnimal.
			~ !!! Cетить не можем, но можем получить.
			~ Еще раз комментарии:
				Так как мы не знаем что лежит в этой пременной, чем она проинициализирована woolfList или bearList, то мы и не можем туда еще что то поместить, но точно знаем что можем получим WildAnimal.
					Т.е. это когда мы получаем подобную переменнну в методе, мы точно не можем знать что там woolfList или bearList - по этой причине вставить нельзя ничего. Т.е. может мы проинициализировали серыми волками, а потом попытаемя положить просто волков - тем самым какбы нарушим целостность объекта.
				Но так как мы знаем что там все что ниже WildAnimal мы можем получить типы WildAnimal через get().


		

		List<MammalAnimal> mammalList = new ArrayList<MammalAnimal>();				List<Animal> animalList = new ArrayList<Animal>();
		mammalList.add(new MammalAnimal());
		mammalList.add(new WildAnimal());
		mammalList.add(new HouseAnimal()); //засунули сюда отдельную ветку от wildAnimal
		mammalList.add(new Woolf()); //можно и допустимо.

		List<? super WildAnimal> wildAnimalList = mammalList; // и здесь теперь есть и MammalAnimal и HouseAnimal

			Т.о. Присвоить к переменной wildAnimalList можем любой объект, что параметризован РОДИТЕЛЬСКИМ или ТЕКУЩИМ классом (в том числе MammalAnimal и Animal и Object).
				Т.е. по другому сказать, мы можем проинициализировать эту переменную объектом, что параметризован текущим или родительским классом. Ведь может быть запись List<? super WildAnimal> wildAnimalList = new ArrayList<Animal>();

			Но добавить в переменную wildAnimalList мы можем только все что ниже WildAnimal по типу. Это делается специально, что бы ограничить на вставку объектов типа Object, Animal к примеру для переменной mammalList.
						> Хотя Object там УЖЕ может быть - т.е. если мы присваиваем такой переменной уже существующею перменнную с Object т.е. List<Object> objectList.
				> К примру, если взять mammalList, то мы можем вставить объекты MammalAnimal, Woolf, Bear - Но не можем Object, Animal. 
				> Так же и для переменной, как <? super WildAnimal> мы не знаем что за объект и что содержит он внутри, но знаем, что безопасно вставлять все что ниже WildAnimal и это не создаст проблем.
				
		Все <? extends> или <? super> - нужно рассматривать еще и в разрезе методов. Т.е. когда метод принимает, что-то с <? extends> или <? super> - и мы работаем с этой переменной, мы находясь в методе не знаем что нам передали.... 

		List<?> list
		List list
			Со знаком ? сильнее проверки, так как внутри кaкой-то конкретный тип, а без ? любой Object.
			По аналогии если указан просто ? то мы не сможем использовать методы аналогичные set...

		Как определить, какое ограничение использовать для дженериков?
			Существует правило PECS - Producer Extends Consumer Super.
			Если аргумент используется как поставщик, то есть нужно что-то взять из объекта, то используется <? extends SomeClass>.
			Если аргумент используется как потребитель, то есть нужно что-то положить в объект, то используется <? super SomeClass>.
			Если аргумент используется как для чтения, так и для записи, то ограничения не накладывается и нужно использовать <SomeClass> или просто <T>.

		Для параметризованных методов вычисление типов не вычисляется ни в каких др. ситуациях кроме как присванивание. Если передать результат вызова aClass.method в качестве аргумента др. методу, то вычисление типа не будет выполнен.
			TODO: Еще нужно разобраться и описать мостовые методы.

		Наследования итд с параметризацией
			Часто смущает такая запись:
				<T extends Comparable<T>> для этого нужно вспомнить как объявляется String implements Comparable<String> т.е. под указанные выше условия подходит String, Integer итд

				<L, T extends BaseStream<L,T>> - аналогично, нужно для понимания создать класс SubBaseStream<L> implements  BaseStream<L, SubBaseStream<L>> - и вот этот этот класс подходит под эти условия SubBaseStream

				<L extends Integer, T extends BaseStream<L,T>> - можно так, но суть не меняется.

				!!!!!Тут важно читать extends не как расширение а как ограничение. Т.е. тип ограничен другим типом.!!!!!!
			стр. 567 Эккель полный перевод.
				

				
			class Transport implements Comparable<Transport> {
				@Override
				public int compareTo(Transport o) {
					return 0;
				}
			}
			class Car extends Transport {}
			class SedanCar extends Car {}
			class BigSedan extends SedanCar {}
			class SmallSedan extends SedanCar {}
			class Truck extends Transport {}

			public static <T extends Comparable<? super Car>> int minSuper(T t) {}
			minSuper(new Transport());
			minSuper(new Car());
			minSuper(new SedanCar()); //Все три легальные.
			
			public static <T extends Comparable<? extends Car>> int minSuper(T t) {}
			а вот сюда ничего не удастся передать.
			
			Аналогично как и:
				Comparable<? super Car> c = new Transport();
				Comparable<? super Car> c = new SedanCar(); //оба допустимо
				
				Comparable<? extends Car> c = new SedanCar();//!!! не допустиом ни при каких видах ни new Сar() ни что то др. А потому что SedanCar - это Comparable<Transport>. Смотрим внимательно как объявляется SedanCar. Он расширяет Car, а Car расширяет Transport а тот class Transport implements Comparable<Transport>


		Захват типа для ? (capture conversion).
			Если передать неспецилизировынный тип методу, использующему/принимающему <?>, компилятор, может автоматически вычислить фактический параметр-тип и вызвать другой метод, использующий точный тип.

			static <T> void f1(Holder<T> holder) {
				T t = holder.get();
				System.out.println(t.getClass().getSimpleName());
			}
			static void f2(Holder<?> holder) {
				f1(holder); // Call with captured type
			}

			Но к сожалению ни запиcать в методе f1 ни получить из метода f1 не удастся т.к. в f2 ничего не известно о T. Т.е. такой подход необходим, когда необходимо работать с точным типом.

				Неуказанный тип маски фиксируется и приобразуется к точному типу.
				стр. 560 Эккель полный перевод.



Ввод/вывод:
	Поток это абстракция которая соединяет память и устройство IO.
	Классический IO
		Общее:
					in	- InputStream - назначен на клавиатурный ввод с клавиатуры
			System  out	- OutputStream (PrintStream) - выходной поток байтов 			PrintStream - байтовый поток вывода, содержащий методы print(), println()
					err	- OutputStream (PrintStream) - выходной поток байтов 			PrintStream extends FilterOutputStream, а FilterOutputStream extends OutputStream
				
				InputStream, OutputStream 	- байтовые потоки abstract
				Read, Write		 			- символьные потоки.
			В программу идет входной поток и читаются данные методами read();
			Из программы идет выходной поток и пишется в этот поток write(), print(), println()
			Поток может быть направлен в разные места - консоль, файл, сеть, строка, область памяти
		
			Read		InputStream
			Write		OutputStream			Все выкидывают IOException
		
			Write и OutputStream - поддерживают буфферизацию. Буффер ждет заполнения данными и выводит по мере достижения, данные в поток. Если не дожидаться то есть метод flush() - все выводит в сразу же в поток. Или же для метода println() то можно поставить true и будет выводиться сразу.
		
			InputStreamReader - преобразует входной байтовый поток в символьный поток.
			OutputStreamWriter - преобразует выходной символьный поток в байтовый поток.
				В обоих конструкторах есть указание кодировки (Важно)!
		
			LineNumberReader - читает входной символьный поток построчно.
			RandomAccessFile - позволяет обратиться к байту непосредственно.
		
			PrintStream, PrintWriter - вывод на строчные устройства - экран и принтер.
							PrintWriter - неявно создает объект класса OutputStreamWriter - с локальной кодировкой для преобразования символьного потока в байтовый поток.
		
			PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out, "Cp866"), true); - для вывода на консль(строчные устройства). true - нужно для принудительного сборса буфера в поток, при использвании метода println(), в ином случае нужно использовать метод flush() - для принудительного сборса буфера. Данный метод нужно использовать всегда для метода print().
														для сборса методом print() нужно всегда применять метод flush(). Ибо метод print - не сбрасывает буфер никогда.
										Так как консоль байтовое устройство - то перед выводом нужно перевести символы Unicode в байты.
			BufferReader br = BufferReader(new InputStreamReader(System.in, "Cp866")); - кроме read есть метод readLine() - возвращает строку или null если нет.
		
		Чтение/запись из/в файл:
			FileInputStream и FileOutputStream
			FileReader и FileWriter - внутри себя содержат  InputStreamReader и OutputStreamWriter, так как их расширяют
			
			FileInputStream fis = new FileInputStream("file.log");
			InputStreamReader isr = new InputStreamReader(fis, "KOI8_R");
			
			FileWrite fw = new  FileWrite("file", true); - если true - то дописываем, false - переписываем
		
		Буфферизованный ввод/вывод:
			BufferReader br = new BufferReader(new InputStreamReader(new FileInputStream(file.java), "Cp866"));
			BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file.java), "KOI8_R"));
			
		Прямой доступ к файлу:
			RandomAccessFile(Streing fileName, String mode); "r", "rwd", "rws"
		
		Обмен данными между потоками:
			PipedWriter			PipedOutputStream
			PipedReader			PipedInputStream
			
		Channel и ByteBuffer
			FileChannel

		I/O
			Поток I/O - это абстракция, которая потребляет или поставляет данные.
				Поток I/O могут привязывается к тому или иному физическому устройствую - но сами потоки ведут себя однинаково.
				Т.о. одни и те же классы и методы I/O применимы к различным устройствам.
			
			InputStream/OutputStream - именно у подклассво этих родительских классов учитываются отличия различных устройств (FileI/OStream, Piped, Byte)
			Reader/Writer - аналогично, но для символьных потоков Unicode.
			
			System.in - InputStream
			System.err/out - PrintStream
			
			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			PrintWriter pw = new PrintWriter(System.out, true);
	


Паралельное выполненине:
	После вызова метода start() класса Thread управление сразу же возвращается порадившему/вызвавшему потоку.
	Процесс порожденного потока заканчивается, когда выходим из метода run(), как вариант через return или по окончанию цикла. Как правило, потоки есть бесконечные(условно) процессы в бесконечном цикле.
			Демон заканчивается сразу после окончания родительского потока при этом даже не выполняется finally.
	
	При этом основной поток по возможности должен заканчиваться последним.
		Можно добиться через методы join() - отпустит, когда закончится поток, вызывается для экземпляра Thread. Или через isAlive().

	Приоритет:
		publuc class A implements Runnable{
		public A(int i){
				int this.prior = i;
			}
		public void run(){
				Thread.currentThread().setPriority(prior);
				....
			}
		}
		....
		ExecuterService exec = Executers.newFixedThreadPool();
		exec.execute(new A(Thread.MAX_PRIORITY));
		
		Подпроцессы поражденные подпроцессом определенного приоритета, будут иметь тот же приоритет, что и родитель.
		Эккель пишет, что игра с приоритетами, является ошибкой в проектировании и не нужно на это пологаться (т.е. нужно избегать этого). Все должно быть запущено по дефолту.
		
	Демоны:
		Демоны завершают свои методы run без выполнения finally. Завершают свою работу сразу с окончанием родительского.
		Подпроцессы рожденные демоном, будут демонами.
		Thread daemon = new Thread(new Runneble());
		daemon.setDaemon(true); вызывается перед start
		daemon.start();
	
	Присоединение к потоку:
		Метод join() позволяет дождаться окончание др. потока. Метод вызывается для того, потока, что ждем. Вызывается в run();
		Зависимость задач от объектов не являющиимися задачами устраняет ситуацию гонок.
		Нельзя делать зависимость одной задачи от др. задачи, так как окончание задач не детерменированн. Лучше сделать зависимость от объекта не являющемся задачей. стр. 579.
	
	Синхронизация процессов:		
		Суть следующая: Если есть некоторый(общий) ресурс к которому будет организован многопоточный доступ (файл, сеть, любой экземпляр с состоянием), то его нужно обернуть в клас, а все методы этого класса, что будут иметь доступ к ресурсу объявить как synchronized-метод. Таким образом получим, что лишь один поток сможет работать с ресурсом одновременно.
			Это позволит осуществить работу с ресуросм в один момент времени, лишь одному потоку.
			
		synchronized(объект){} объект что должен быть синхронизированн. Медленнее чем через синхронизацию метода. При синхронизации, блокируется доступ ко всем методам того объекта что передан как параметр (разумеется идет речь только про синхронизированные методы). 
						Согласно Шилдту стр. 276 этот блок используется в методе run() - т.е. в методе потока.
		synchronized int method(){} при использовании этого метода, блокируется досутп ко всем синхронизированным методам, в отличии от синхронизированного блока, всегда для методов this, т.е. текущего объекта.
						Синхронизированные методы - находятся в объекте который обрабатывает поток. Т.е. в этом случае объект что блокируется для др. потоков является объект, что содержит эти методы.
			
		Далее если требуется сделать взаимную и согласованную работу нескольких процессов/потоков с ресурсом, то необходимо добавить в данные синхронезированные методы/блоки вызовы методов wait() и notify(). 			
			Эти методы могут быть вызваны, только в синхранизированных методах.
			При этом данные методы должны быть подкреплены проверокй в цикле некоторого индикатора. Это рекомендация от Oracle.			
		Согласование процессов:
			wait(); notify(); - можно использовать только в синхронизированных блоках или методах. Если wait() ждет, то он снимает блокировку с объекта, позволяя вызвать др. объектам, другим потокам.
			В отличии от sleep, wait освобождает объект от блокировки. Wait принадлежит Object а не Thread.
			wait() и notify() допускается испльзовать только в синхронизированных блоках или методах.
			notify()  - выводит из ожидания только один, произвольно выбранный процесс. notifyAll() - все потоки, но кто успеет занять, не детерменированно.

			Советуют использовать так:
			public class StateClass {
				private boolean isAllowGet = false;
				private int n = 0;

				public synchronized int get() {
					while (isAllowGet == false) {
						try {							
							wait();
						} catch (InterruptedException exc) {
							log.error("---");
							notify(); - т.е. получили исключение, но поток осовободили.
						}
					}        
					isAllowGet = false;
					notify();        
					return n;
				}
			
				public synchronized void set(int aN) {
					while (isAllowGet == true) {
						// Если брать разрешено т.е. true, то ждем, если брать запрещено, то можно класть и в цикл не попадаем.
						try {						
							wait();
						} catch (InterruptedException exc) {
							log.error("---");
							notify(); - т.е. получили исключение, но поток осовободили.
						}
					}
					n = aN;				
					isAllowGet = true;
					notify();
				}
			}

	Синхронизация через класс Lock.		
		Сонхранизация должна выполняться в виде:
			privat Lock lock = new ReentrantLock();
			public int next(){
				lock.lock();
				try{...
				}finally{
					lock.unlock();
				}
			}
		Такой такой подход позволяет, выполнить разблокировку в любом случае. В общем случае Эккель рекамендует использовать просто synchronized, а класс использовать в тех случаях когда нужны завершающие действия, так как можно использовать finaly или же для мест, где нужно получить блокировку а если не удалось получить блокировку, то забить см. Эккель стр. 583-584.
		
	Остановка процесса:
		publuc class A implements Runnable{
		public A(...){
				Thread go = new Thread(this);
				go.start();
				}
		public void run(){
			Thread th = Thread.currentThread();
			while (go == th){
			....
			Thread.yield();  //Означает, что оснавная задача выполнена, планировщик мжет переключиться на др. поток.
			}
		}
		public void stop(){go=null};
		
	Приостановка процессов через suspend(), resume(), stop() - категарически не рекамендуются. См. Шилдт стр. 312(9изд) - возникали различные проблемы. Да и они были в Java1.1 а в Java2 их признали непригодными для работы.
		Для этих целей рекамендуется испльзовать ту же конструкцию wait(); notify();
			См. Шилдт стр. 285 ("Современный способо приостановки возобновления и остановки потоков").
		
	Рекамендации по избавлению от блокировок:
		Нужно избегать ситуаций, когда есть два объекта (A и B) у них есть синхранизированные методы. Эти два объекта занимаются потоками (1 для А и 2 для B) войдя в синхранизированные методы, дальше каждый поток хочет вызвать синхранизированный метод соседнего объекта. Т.е. 2ой поток методы A, а 1ый методы B - так они будут ждать вечно.
		
	CountDownLatch
		countDown() - не блокирует вызывающею задачу.
		await() - блокирует до момента обнуления счетчика.
		
	ThreadLocal - Данная переменная будет принадлежать одному единственному потоку. Для каждого потока данная переменная будет своя уникальная.
		private static final ThreadLocal<User> threadLocalScope = new  ThreadLocal<>();
		public final static User getLoggedUser() {
			return threadLocalScope.get();
		}	
		public final static void setLoggedUser(User user) {
			threadLocalScope.set(user);
		}
	

	volatile
		Запрещает потокам кэшировать переменную.
			Избагаем ситуацию, когда поток кэширует переменную в своем кэше, и тем самым имеет старую версию значения, так как в др. потоке эта перменная могла уже измениться.
-------------------
Шилдт стр. 870 - очень хорошо описано в части объектов синхранизации.

	Executer - исполнители - предназанчены для создания потока и управления ими (по сути альтернатива/замена Thread).
				void execute(Runnable thr) - запускает указанный поток на исполнение.
		ExecutorService	- 	расширяет Executor - добавляя методы.
							shutdown() - останавливает все потоки, что находятся под управлением данного исполнителя.
			ThreadPoolExecuter
			SheduledThreadPoolExecutor - позволяет планировать исоплнение потоков.
			ForkJoinPoll

		Executors - содержит статик методы(фабрики) для получение вышеперечисленных исполнителей.
			Executors.newCachedThreadPool() - 		- создает для каждой задачи один поток.
			Executors.newFixedThreadPool() - 		- создает пул потоков фиксированного размера. При этом эта опреация довольно дорогая. По этому создают один раз и уже потом пользуются. Зато потом получаем экономию, что уж не создаем потоки а используем уже готовые.
			Executors.newSingleThreadExecutor() - 	- создает один поток, и переданные задачи будут выполняться в той последовательности в которой мы задали. При этом будет завершена одна задача и лишь после этого начнет выполняться следующая задача.
														- Замечательно подходит для синхронизации, дабы избежать конкурентного обращения к объекту. Да и для работы с файловой системой или последовательной обработки тоже подходит идеально.

	Исполнители связаны с Future и Callable
		Future - содержит значение возвращаемое потоком после его выполнения.
		Callable - определяет поток возвращающий значение т.е. аналог Runnable но умеет возвращать значение.
					Содержит один единственный метод "V call()" - этот метод соответствует run().
					Для выполнения Callable вызывается метод submit() определенный в ExecuterSerive: <Т> Future<T> suЬmit (CallaЬle<T> task)
					Далее у возвращенного Future<T> - методом get() - получаем значение. При этом get() заставляет ждать.

	Lock 			- по сути замена/аналог synchronized (но есть полюс в том, что если возникнит исключение в случае с Lock можно их обработать и сделать корректное завершение.
		lock()		- попытка получить блокировку потоком, если уже блокировка есть(кто то уже взял) то текущий поток, что запросил - будет приостановлен.
		tryLock()
		unlock()	- для снятия блокировки. Эккель советует делать lock() потом try-catch и в finally делать unlock().
		newCondition() - возвращает объект Condition - позволяющий добиться большего контроля над блокировками с помощью методов await() и signal(). Аналоги wait() и notify().

		ReentrantLock - реализация Lock

	объекты синхранизации:
		Semaphore		- содержит счетчик, если он больше 0 то разрешен доступ потока к объекту, если 0 то поток начинает ожидать. После того как один из потоков вышел(т.е. счетчик увеличился), ожидающий может начать рабоать.
							Semaphore(int n, boolean mode) - mode определяет будет ли упорядочное ожидание или нет. Если true то потоки будут допущены к работе в порядке их прихода в очередь.
								Запрос разрешения acquire(). Освобождение release().
								При этом можно даже создавать семофор с нулевым количеством потоков. Как бы тем самым создавая для потока просто остановку в этом месте. А другим потоком когда необходимо можно будет отпустить остановленный поток. См. Шилдт стр. про семофор.

		CountDownLatch	- В конструкторе устанавливается количество событий, что должно произойти до момента как второму потоку будет начать работать. Имеет одноразовое использование.
								Вызов await() - заставляет поток начать ждать. Второй поток дергает countDown() - как бы отсчитвая назад от установленного значения к нулу. Как ноль достигнут, поток, что вызвал await() начинает свою работу.

		CyclicBarier	- В конструкторе устанавливается количество потоков, что должны вызвать await() - т.е. он будет блокировать их пока все не достигнут этого - после чего их работа возобновится.
								Так же можно указать в конструкторе Runnable который будет выполнен, когда все потоки дойдут до CyclicBarier. После, выполнения этот объект барьера снова можно использовать.


		Exchanger		- Позволяет обмениваться данными между потоками через метод "T exchange(T значение)" - этот метод ждет пока его вызовут два потока - при этом каждый получит данные, что воткнул др. поток.

		Phaser			- Похоже на CyclicBarier - только можно работать с фазами. Если кол. фаз равно 0 то будет идентичен CyclicBarier.
							- Конструктор Phaser(int num_side) - количество сторон. Объекты регистрируемые синхронизатором фаз - называют сторона.
							- Регистрация потока выполеняется методом registr().
							- Синхронизатор ожидает до момента, пока все стороны не выполнят фазу. Ожидание фазы выполняется методом arrive() - но arrive поток не останавливает И arriveAndAwaitAdvance() - он заставляет поток остановиться и ждать.
								Как все зарегистрированные стороны достигнут этого метода, фаза считается выполненной и происходит переход к новой фазе.
							- Для ожидания и снятия с регистрации используется метод arriveAndDeregistr() - не ожидает завершение фазы.

	Fork/JoinFramework - Как написано у Шилдта - Thread используется в основном не для параллельного выполнения, а для выполнения задач с ожиданием событий, допустим: один поток выполяется, другой ждет события. По стути Thread - для реальной многозадачности в параллельном режимен не подходит. 
							Тут на сцену для таких задач и многоядерных машин выходит соответствющий фраемворк - который оптимизирован под параллельные задачи (Fork/JoinFramework).
								Как я понял основная задача/цель это разделить/раздробить одну задачу на несклько маленьких и запустить их рассчет. При этом запуск этих подзадач происходит внутри этой задачи.
									Т.е. создаем Pool туда передаем задачу. Эта задача внутри себя в методе compute() создает новые задачи и передает методам fork(), join(), invoke(), invokeAll(). Так как изначальная задача выполнялась в потоке Poll - то и новые задачи автоматом будут выполняться в этом Pool.
									От сюда и названия: RecursiveAction и RecursiveTask - мы как бы при выполнении начальной задачи, делим на меньшие подзадачи но похожие по вычислению и вызываем эти подзадачи.
									Метод compute() - называют вычислительной частью.		

		- ForkJoinTask<V>		- абстрактный класс определяющий задачу.
				- RecursiveAction		- Производный от ForkJoinTask<V> класс задач, что не возвращают значения.
				- RecursiveTask<V>		- Производный от ForkJoinTask<V> класс задач, что возвращает значения

		- ForkJoinPool			- Управляет выполнением объекта класса ForkJoinTask
		
		ForkJoinTask - отличается от Thread тем, что представляет из себя облегченную абстракцию задачи - а не поток исполенния. Задачи данного типа выполняются потоками из полуа ForkJoinPool. Такого рода подход позволяют обрабатывать большое количество задач малым количеством потоков.
			Основные методы:
				- ForkJoinTask<V> fork() - передает вызывающую задачу для асинхронного выполенния (возвращает this на объект задачи).
						Как я понял, текущая задача выполняется в потоке из пула потоков, потом в методе compute() - можно вызвать fork() - по сути для запуска исполнения дочерней задачи (помним, что мы дробим задачи на поменьше и их пытаемся выполнять в параллели, вот про эти дробные задачи и идет речь).
				- V join() - ожидает завершение задачи, для которой он вызван.
				- V invoke() - запускает задачу на исполнение и ждет ее окончания (по сути объединяет в себе два метода fork() и join())

		RecursiveAction - расширяет ForkJoinTask - представляет задачу, которая не возвращает результат.
			- Интерес представляет метод compute() - представляет вычислительную часть задачи.
		RecursiveTask<V> - также расширяет ForkJoinTask - представляет задачу, которая возвращает результат.

		ForkJoinPool - выполнение задачи происходит из пула потоков.
				- После создания экземпляра ForkJoinPool - можно запускать на исполнение задачу. Вызывается внутри класса ForkJoinPool метод "<T> T invoke(ForkJoinTask<T> task)". Запускает задачу и возвращает её результат. Т.е. метод заставляет ожидать.
				- Для того что бы не ждать можно вызвать метод "void execute(ForkJoinTask<?> task)"

			Шилд еще говорит про - общий пул. Можно в классе ForkJoinPool вызвать метод commonPoll() - для получения ссылки на общий пул. Общий пул подходит для большенства приложений.
				- Запуск выполняется так же, получаем ссылку commonPoll() - а далее через invoke(...) или execute(...).
				- Второй варинат вызвать из класса ForkJoinTask методы fork() или invoke() - пул будет выбран автоматически. Но этим методы не нужно вызывать в вычислетельной части задачи.
				- !!! Много где написано, что общего пула для 90% задач достаточно, и по ресурсам он оптимален.


	Использование каналов для i/o между потоками:
		PipedWrite 		- позволяте записать в канал
		PipedRead 		- позволяет прочитать из канала другому потоку.
				См. Эккель стр. 601

	Перечисление:
		TimeUnit

	Атомики:
		AtomicInteger
		AtomicLong
		compareAndSet()
		decrementAndGet()
		getAndSet()

	Параллельные коллекции:
		CuncurrentHashMap
		ConcurrentLinkedQueue
		CopyOnWriteArrayList

-------------------

GUI
	Событие - объект который создается в момент изменения состояния источника. Корень всех классов EventObject(Object источник). Для AWT это AWTEvent
	Источник - объект извещающий о событии (создатеся событие на изменение внутреннего состояния объекта).
			Источником может являться кнопки, меню и др. графические элементы. Т.е. все что наследуется от Component
			Каждый вид события имеет собственный вид регистрации (addТипListener(ТипListener el)) el - ссылка на слушателя событий, Тип - имя события.
			Когда происходит событие то извещаются все слушатели что были зарегестированны, и получают копию события(объект события). Источник может извещать о событии нескольких типов. 
	Слушатель - объект уведомляемый о событии. Когда происходит событие, его источник вызывает соответствующий метод определенный в слушателе.
	
	Когда происходит событие, его источник вызывает соответствующий метод, определенный в слушателе(реализующий интерфейс), и передает объект события в качестве аргумента.
	
Date, Calendar, DateFormat:
	- Работаем с Date как источник миллисекунд от 01.01.1970
	- Перед работой с Calendar и DateFormat - сетим им нужную тайм-зону только после этого начинаем работать с ними. Иначе будут неожиданные вещи если у людей разные временные зоны выставленны на машинах.
		Нужно еще посмотреть временные классы в части SQL.

Лямбда и стримы:

	Лямбда-выражение:
		По сути является анонимным(безымяным) методом. Сам по себе не выполняется, и служит для реализации метода, определенного в функциональном интерфейсе.
			Функциональный интерфейс определяет целевой тип лямбда-выражения. Этот интерфейс мы указываем в методе который, принимает объект интерфейса. А лямбда выражение это и есть объект с реализацией.
				Вообще лямбда выражение можно и нужно оценивать как безымяный класс. По сути то, можно взять и прямо в этом месте сделать безымянный/ананимный класс.

			Лямбда-выражение должно быть совместимо по типу с абстрактрым методом, для реализации которого оно предназначено. т.е. семантика метода должна совпадать.

			У лямбда-выражения собственный this отсутствует.
				А this - для лямбда-выражение будет ссылаться на объемлющий класс.

	Функциональный-интерфейс:
		Интерфейс, что содержит один абстрактный метод - т.е. представляет единственное действие.
		Лямбда-выражение можно использовать только в том контексте, в котором определен его целевой тип.
			Один из таких контекстов создается в том случае, когда лямбда-выражение присваивается ссылке на функциональный интерфейс. 
				MyNum myNum;
				myNum = () -> 123.4; //Здесь автоматически создается экземпляр класса, реализующий функциональный интерфейс.
			К числу других контекстов целевого типа относится инициализация переменных, операторы return и аргументы методов.


	Лямбда-оператор:
		-> (буквально означает - становится или переходит)
		Слева любые параметры, требующиеся в лямбда-выражении. Если же параметры не требуются, то они указываются пустым списком.
		Справа находится тело лямбда-выражения, где указываются действия, выполняемые лямбда-выражением.
		
	1. Создается ссылка на функциональный интерфейс:
		Predicate<Integer> isPositive;
	2. Лямбда выражение присванивается этой ссылке на функциональный интрефейсЖ
		isPositive = x -> x > 0;
		Как только лямбда-выражение появляется в контексте совего целевого типа, савтоматом создается экземпляр класса, реализующего функциональный нитерфейс. Лямбда выражение определяет поведение абстрактного метода этого функционального интерфейса.
		А когда этот метод вызывается через эту ссылку, выполняется лямбда выражение. Лямбда выражение позволяет приобразовать сегдмент кода в объект.

	Особое внимание ссылки на конструкторам.
	Активно испльзуется в рамках стримов.

	Stream
		Поток данных предлагается воспринимать как канал передачи данных (т.е. можно воспринимать как последовательность объектов).
		Источником данных потока может являеться массив, коллекция. Сам поток данных не хранит ничего, но может филтровать или обрабатывать данные. Но поток не влияет при этом на источник данных.
		Базовый интерфейс определен в интерфейсе:
			interface BaseStream<T, S extends BaseStream<T, S>>, где Т обозначает тип элеметов в потоке данных, S - тип потока данных.
			class Stream<T> extends BaseStram<T, Stream<T>>

	Лямбда-выражение
		Лямбда выражение, или ссылки на методы нужно принимать как создание объекта. Ведь именно у этого объекта мы потом вызываем метод, что называется функциональным.

		Лямбда-выражение может быть указано в том контексте, в котором определен его целевой тип.
			Контекст создается: при присваивании функционального интерфейса ссылке, инициализация переменных, оператор return и агрументы методов.
		Когда лямбда-вырвжение появляется в контексте своего целевого типа, автоматически создается экземпляр класса, реализующего функциональный интервейс. При этом лямбда-выражение определяет поведелие абстрактного метода, объявленного в функциональном интерфейсе.
		
		У лямбда-выражений собственный this отсутствует. И this будет относится к объемлющему классу.
			===Не удалось в лямбда классе использовать this для получения ссылки на переменные объемлющего экземпляра.
		
		В Лямбда-выражении можно использовать и изменять переменные экземпляра объемлющего класса или же статическую переменную объемлющего класса, и даже вызвать метод.
		Если же Лямбда-выражение использует локальную переменную объемлющей области действия - то это называется захватом переменной. При этом локальные переменные ОБЪЕМЛЮЩЕЙ ОБЛАСТИ должны быть завершенными. И здесь не обязательно final, в данном конкретном случае говорится о неизменяемости переменной после инициализации. При этом переменная не должна подлежать изменению ни в лямбда-выражении ни далее по коду.
		Переменные экземпляра объемлющего класса могут меняться в лямбда-выражении, в отличии от локальных переменных объемлющего класса.
		
		Параметр типа в самом лямбда выражении использовать нельзя.
		
		Если функциональный интерфейс является обобщенным, то целевой тип лямбда-выражений отчасти определяется аргументом типа или теми аргументами, которые указываются при определении ссылка на функциональный интерфейс.

		- Ссылки на статические методы - тут все просто.
		- Ссылки на методы экземпляров - тут все просто.
		- И третья форма: <Имя_класса::Имя_метода_экземпляра> см. Шилдт стр. 454
			Первый праметр метода из функционального интрефейса совпадает с вызывающим объектом(экземпляром, что был создан при создании ссылки на объект), а второй параметр - с параметром, указанным в методе экземпляра.
				Если функциональный интерфейс параметризован, то параметр типа определяется исходя из того, что принимает метод на который была создана ссылка.

	
	
String javaHome = System.getenv("JAVA_HOME"); 	- переменная ОС
String tmp1 = System.getProperty("param");		- переменная -D




=================================================================================
//Т - какой-то тип, который просто является подтипом Comparable, а он Comparable в свою очередь параметризован типом T (если абстрагироваться от Т в параметризации - то можно представить к примеру так <T extends Comparablee<Integer>>
//Т.е. тип Т который расширяет Comparablee - который параметризован этим же типом. 
class Comparablee<T extends Comparablee<T>> {
}
//Но как ранее было сказано, чтоб проще было привыкнуть путь Comparablee будет параметризован др. типом Comparablee<Integer>
class Comparablee<T extends Comparablee<Integer>> {
}
//Нужно это рассматривать так: Stringg это подтип Comparablee который в свою очередь параметризован определенным типом, а именно Stringg  
class Stringg extends Comparablee<Stringg>{    
}
//Т некоторый потдип Box3 и точка!!!! Просто Box3 - параметризован некторым типом. В данном случае Т
class Box3<T extends Box3<T>> {
    T method(T t) {
        return t;
    }
}
=================================================================================