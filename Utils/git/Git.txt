Перед сохранением любого файла Git вычисляет контрольную сумму, и она становится индексом этого файла.(Фактически, в своей базе данных Git сохраняет всё не по именам файлов, а по хешам их содержимого.)

В Git'е файлы могут находиться в одном из трёх состояний: зафиксированном, изменённом и подготовленном.
"Зафиксированный" значит, что файл уже сохранён в вашей локальной базе. 
К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы. 
Подготовленные файлы — это изменённые файлы, отмеченные для включения в следующий коммит.

Каталог Git - это база данных GIT - по сути то что мы получаем когда клонируем репозиторий.
Рабочий каталог - это извлеченная из базы копия определенной версии проекта. Файлы достаются из базы данных GIT на диск для работы с ними.
Область подготовленных файлов - это область в "Каталоге Git" которая говорит что должно войти в след. коммит. (index или staging area)

> Вы вносите изменения в файлы в своём рабочем каталоге.
> Подготавливаете файлы, добавляя их слепки в область подготовленных файлов.
> Делаете коммит, который берёт подготовленные файлы из индекса и помещает их в каталог Git'а на постоянное хранение.

Создать репозиторий для существующего проекта
	git init

Добавить файлы под версионный контроль (т.е. проиндексировать) - выполняется как для новых файлов которые хотим добавить так и после изменения, чтобы изменения попали в коммит.
	git add <list_of_files>  - если указан каталог, то добавляется все рекурсивно.
	
	git add Documentation/\*.txt Note that the asterisk * is quoted from the shell in this example; this lets the command include the files from subdirectories of Documentation/ directory.

Фиксация изменений:
	git commit -m "message"
	
Клонирование репозитория (т.е. получение всех данных репозитория, копия)
	git clone https://github.com/andreyksu/selenium.git
	git clone user@server:/path.git (для клонирования по ssh)
	
Файлы в рабочем каталоге могу быть в двух состояниях:
	отслеживаемые	(те файлы которые были в последнем слепке проекта - snapshot. Могут быть измененными, неизменными, подготовленными к коммиту(staged)).
	неотслеживаемые	(все остальные файлы, кторые не входили в последний слепок, не подготовленнны к коммиту)

Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, т.к. вы изменили их с момента последнего коммита. 
Вы индексируете (stage) эти изменения и затем фиксируете все индексированные изменения, а затем цикл повторяется. 


Для проверки состояния репозитория:
	git status

Для детального просмотра что было измеенено необходимо использовть команды:
	git diff   - для измененных файлов но не проиндексированных
	git diff --cached - или git diff --staged для просмотра измененных и проиндексированных файлов
		Важно что эти команды испльзуются лишь для соответствюущего состояния (git diff не покажет изменений после индексации)

Фиксация изменений (делает снимок моего рабчего каталога - само собой лишь то что проиндексированно):
	git commit
	git commit -a 	- позволяет автоматом проиндексировать все отслеживаемые файлы и совершить коммит.

Для удаления файла из отслеживаемых, т.е. из репозитория.
	git rm <regexp> - пример git rm -r .idea/ и git rm \*.iml
	git rm -r --cached <regexp> - отличие от первой команды, в том что первая команда удаляет файлы и из ФС и прекращает следить за файлами, а вторая просто прекращает следить за файлами. Полезно когда измененеия в gitignore после git add .
	
Получение истории репозитория
	git log 		- показывает краткую инфомацию
	git log -p 		- показывает информацию по коммитам детальную
	git log --stat 	- показывает статистику сколько файлов/строк добавлено или удалено
	git log --pretty - меняет формат вывода
						git log --pretty=oneline - выводит каждый коммит в одну строку
						git log --pretty=format:"%h %s" --graph - формат можно задавать свой + граф строится
						
Изменение последнего коммита:
	git commit --amend
		Пример:
			git commit -m 'initial commit'
			git add forgotten_file
			git commit --amend - т.е. в последний коммит добавим еще и файл.
	
Отмена индексации файла:
	git reset HEAD <file>
	
Отмена изменний файла, т.е. приведение к состоянию последнего коммита - не рекамендуется т.к. можн потерять изменения. Лучше закоммитить в отдельную ветку.
	git checkout -- <file>

Работа с удаленным репозиторием:
	git remote - отобразить репозитории.
		Если вы склонировали ваш репозиторий, у вас должен отобразиться, по крайней мере, origin — это имя по умолчанию, которое Git присваивает серверу, с которого вы склонировали:
	git remote -v 			- как я понял отобразит имя удаленного репозитория и его url (как пример origin  http://git.gosuslugi.local/rmis-n2o/mdm-app.git (fetch) какраз origin это псевдоним репозитория, этот псевдоним можно изменить)
	git remote show origin 	- как я понял отобразит ветки в удаленном репозитории.
	
Получение обновлений из репозитория:
	git fetch 	- После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта.
				- Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем origin. Таким образом, git fetch origin извлекает все наработки, отправленные (push) на этот сервер после того, как вы склонировали его (или получили изменения с помощью fetch).
				- Важно отметить, что команда fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.
	
	git pull 	- извлекает (fetch) данные с сервера, с которого вы изначально склонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.
				- лучше испльзовать ее а не fetch

Заливка изменений на сервер:
	git push [удал. сервер] [ветка]
		Пример git push origin master
		Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а затем команду push выполняете вы, то ваш push точно будет отклонён. Вам придётся сначала вытянуть (pull) их изменения и объединить с вашими. Только после этого вам будет позволено выполнить push. 

Работа с ветками:
	Git хранит данные как последовательность снимков состояния (snapshot).
	Когда вы создаёте коммит в Git'е, Git записывает в базу объект-коммит, который содержит указатель на снимок состояния, записанный ранее в индекс, метаданные автора и комментария и ноль и более указателей на коммиты, являющиеся прямыми предками этого коммита: ноль предков для первого коммита, один — для обычного коммита и несколько — для коммита, полученного в результате слияния двух или более веток.
	При добавлении файлов в индекс для каждого из них вычислится контрольная сумма (SHA-1 хеш, о котором мы упоминали в главе 1), затем эти версии файлов будут сохранены в Git-репозиторий (Git обращается к ним как к двоичным данным), а их контрольные суммы добавятся в индекс.
	https://git-scm.com/book/ru/v1/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B2%D0%B5%D1%82%D0%BA%D0%B0%3F
	
	Ветка это лишь именнованный указатель на коммит. А HEAD это указатель/индикатор того на какой ветке я нахожусь(текущей ветке)
			 _ _ _ _ _ _master
			/
	--------
			\
			 - - - - - - testing
	git branch testing 		- создание ветки testing
							HEAD - указатель на ветку на которой я нахожусь
	git branch 				- отображает ветки
	git branch --merged		- покажет слитые ветки с master но еще недаленные.
	git checkout testing	- переключение на ветку.
	коммит итд делается аналогично как и для мастера.
	
	git checkout -b testing	- создает ветку и переходит на нее.
	При переключении между ветками все изменения и индексы должны быть закоммичены.
	
	Для сливания ветки с master
	git checkout master		- переключились в master
	git merge testing		- сливаем.
	git branch -d testing	- удаляем ветку, так как нам не нужна, master указывает на нее. Ибо мы слили их.
	
	для слития в ветку мастера а не наоборот как был в примере выше
	git checkout testing
	git merge master		- т.е. образом мы слили в ветку testing все из master
	
#Клонировать
git clone http://[npovs.username]@bb.npovs.ru:7990/scm/ncuorf/r50-sandbox.git
#Создать ветку NCUORF-18813
git checkout -b NCUORF-18813
#или
git branch NCUORF-18813
#Выбор/переключение между ветками
git checkout NCUORF-18813
git checkout master
#Удалить ветку NCUORF-18813
git branch -D NCUORF-18813
#Связать локальную ветку с уделенной (нужно например для rebase)
#c веткоой origin/NCUORF-18813
git branch --set-upstream-to=origin/NCUORF-18813
#с веткой origin/master
git branch --set-upstream-to=origin NCUORF-18813
#Показать все ветки включая удаленные
git branch -a
#только удаленные
git branch -r
#только локальные
git branch
#Обновить изменения из удаленного репозитория c rebase изменений в ветке origin/master :
git pull --rebase origin master
#Отправить на сервер изменения ветки NCUORF-18813 на точку монтирования origin
git push origin NCUORF-18813
  
#Отправить
# на сервер изменения ветки NCUORF-18813 на точку монтирования origin со
#всеми коммитами из NCUORF-18813 то есть делает в origin все так же как и
# у вас на локальной ветке включая коммиты. Использовать когда в вашей ветке на сервере оказалось несколько коммитов.
git push origin NCUORF-18813 --force
#Локальный коммит с добавление всех файлов
git commit -a
  
#локальный коммит интерактивный режим - позволяет гибко выбирать что добавить в коммит
git commit --interactive
#Объединение нескольких локальных коммитов в один для того, что бы на сервер ушел 1 коммит.
git rebase -i master
  
#делаем rebase в интерактивном режиме.
#Позволяет объединить истрию коммитов в 1.
#видим список коммитов начинаеся с pick (порядок от нового к старому)
#Нужно заменить у старых комитов pick на squash - это сольет комиит с более новым.
#Сохраняем. Если все прошло успешно, то git log покажет новый объединенный коммит.
 
#если так вышло, что у вас в ветке на сервере уже несколько коммитов их можно объединить в один локально, затем форсированно запушить на сервер новое содержимое ветки
git push origin NCUORF-18813 --force
#история коммитов в текущей ветке
git log
  
#статус индекса в текущей ветке
git status