.include "m8def.inc"			; в это место вставляется файл. Если нужна лишь часть, то в импортируемом файле ставиться .exit
								; в atmega8 нет Jmp, так как RJMP за два прыжка можно все обойти.

; Start macro.inc ===============================================================================================================================================

.MACRO SUBI16					; Start macro definition 
        subi @1,low(@0)			; Subtract low byte 
        sbci @2,high(@0)		; Subtract high byte 
.ENDM                       	; End macro definition
 								; вызов как SUBI16 	0x1234,r16,r17

.MACRO LDIL
	PUSH	R17					; так как в младшие регистры, нельзя впихивать данные напрямую		; записали содержимое регистра в стек
	LDI	R17,@1					; используются старшие регистры, а с них уже в младшие регистры		; записываем константу в R17 (работает только от R16-R31)
	MOV	@0,R17					; 																	; копируем содержимое из R17 в @0
	POP 	R17					; 																	; ну и восстановили значение R17 из стека.
.ENDM							; LDIL	R0,18
								
;= End macro.inc  ===============================================================================================================================================
 
 
; RAM ===========================================================================================================================================================
		.DSEG
;по сути аналог массива, т.е. резервируем память указаннаго размера. 
Var:			.byte 3			;зарезервировали 3 байта ОЗУ начинается с 0x0060 соответственно Var1 начинается с 0x0063
Var1:			.byte 7			;зарезервировали 7 байт

; FLASH =========================================================================================================================================================
		.CSEG
								;область памяти комнад т.e. FLASH. Кодовый сегмент
								;после этой диррективы идет код/команды

								;пошли вектора прерываний.
.ORG 0x000						;
	RJMP 	Inital_Restart		;по сути это адрес 0х0000, сюда приходит проц после рестарта/старта
								; все остальные .ORG нужны для помещения именно туда обработчика прерываний, так как именно по этому адресу приходит проц, при возникновении того или иного прерывания. 
								; по этой причине, мы должны именно туда записать эти значения

.ORG INT0addr
	RETI
.ORG INT1addr
	RETI
.ORG OC2addr
	RETI
.ORG OVF2addr
	RETI
.ORG ICP1addr
	RETI
.ORG OC1Aaddr
	RETI
.ORG OC1Baddr
	RETI
.ORG OVF1addr
	RETI
.ORG OVF0addr
	RETI
.ORG SPIaddr
	RETI
.ORG URXCaddr
	RJMP RX_OK
.ORG UDREaddr
	RETI
.ORG UTXCaddr
	RETI
.ORG ADCCaddr
	RETI
.ORG ERDYaddr
	RETI
.ORG ACIaddr
	RETI
.ORG TWIaddr
	RETI
.ORG SPMRaddr
	RETI

;--------------------------------------------------------------variables-------------------------------------------------------------------------------------

.def trash=R16 					;задает наименование/псевдоним для ресурсов контроллера - порт/регистр
;.undef trash					;удаляет наименвоание 

.equ CONST=20					;задает имя для константы. Компилятор потом везде подставит это значение		

;---------------------------------------------------------------------------------------------------------------------------------------------------

								; рекамендуют делать эти вещи в конце кода.
Constant:	.db 10, 11			; .db массив байтов, .dw массив два байта, .dd массив четрые байта, .dq массив по восемь байт
								; их же можно применять и для EEPROM
Message:	.db "QW"			; запишем сюда символы
Words:		.dw 10, 11, 12		; запишем сюда числа, хотя они бубуд занимать по два байта

Work_With_Const:
			LDI ZL, Low(Constant*2)
			LDI ZH, High(Constant*2)
										; умножение на два тут из-за того, что адрес указан в двубайтных словах, а нам надо в байтах. Поэтому и умножаем на два. 
										;После загрузки адреса можно загружать число из памяти
			LPM	R16, Z



M1:
	;RJMP M2					; ниже идет аналог (этой команды) - т.е. расписали
	LDI		ZL, low(M2)			; получаем нижний адрес m2 метки
	LDI		ZH, High(M2)		; получаем верхний адрес m2 метки
	IJMP						; переход по адресу, что находится в Z, так называемый косвенный переход

M2:
	LDI		R16, 3
	LDI		R17, Constant
	
	CPI		R16, 1				;сравниваем R16 c 1 если равны, то пргыаем на M1. Только для страших регистров.
	BREQ	M1

	; Первый вариант. Загружаем в регистры значения из памяти. Прибавляем единицу, загружаем обратно.
	LDS		R18, Var
	LDS		R19, Var+1
	LDS		R20, Var+2
	
	SUBI	R18, (-1)			; SUBI это вычитание, но -1 дает +. Т.е. в этой операции мы складываем
	SUBI	R19, (-1)
	SUBI	R20, (-1)

	STS		Var, R18
	STS		Var+1, R19
	STS		Var+2, R20

	RCALL	Wait				; переход на Wait, а в стек помещается адрес следующей команды для возврата из фунции.

	; Второй вариант вариант. Косвенная запись через индексный регистр.
	LDI		YL, Low(Var1)
	LDI		YH, High(Var1)

	LD		R18, Y+			; косвенная загрузка
	LD		R19, Y+
	LD		R20, Y+

	SUBI	R18,(-1)
	SUBI	R19,(-1)
	SUBI	R20,(-1)

	ST		-Y, R18			; косвенное сохранение
	ST		-Y, R19
	ST		-Y, R20

	;работаетм со стеком
	LDI		R18, 15			; запихнули в регистр число
	PUSH	R18				; запихнули в стек значение из регистра
	POP		R19				; из стека выталкнули в R19, но в стеке это число осталось, просто SP сместилась на R18. А при следующей записи это число просто перезапишется. Т.е. при выталкивании из стека число не обнуляется.

	RJMP 	M2

Wait:	LDI R16, CONST
M3:		DEC	R16
		NOP
		BRNE M3
		RET					; Вытаскивает из стека два байта и кидает их в PC и прыгает по этому адресу. Т.е. ни в коем случае в стек писать нельзя (а если записали, то нужно извлечь, перед возвратом, иначе из стека вытащится не то). 
							; Ну уж коли нужно, то пишем адрес в регистор, а потом кидаем в стек. Перед RET
							; можно все в макросы. Макрос, это просто копия кода, в нужное место, т.е. без лишних 3х команд RCALL, RET и стек.
	

Inital_Restart:					; Всегда, перед началом работы производим инициализацию. Т.е. это должно быть первое в программе. Без стека ничего работать не будет.
		LDI		R16,Low(RAMEND)													; Загрузаем константу в R16
		OUT		SPL,R16															; Запись из регистра в Порт i/o

		LDI		R16,High(RAMEND)
		OUT		SPH,R16
													
		SEI							; разрешаем глобальные прерывания			; Устанавливает флаг I в регистре SREG
		LDI		R17, (1<<RXCIE)		; разрешаем прерывание по приему байта.		;
		OUT		UCSRB, R17														; 

		RJMP	M1

;---------------------------------------------------------------------------------------------------------------------------------------------------
;RX_OK:	IN		R16, UDR			; бит поднятого прерывания сбарсывается по разному. В этому случае нужно прочитать данные с поля UDR
;		RETI						; где сбрасываетс автоматом при переходе из вектора пререываний, а где нужно что то сделать.
									; при возникновении прерывания, запрещается глобальное прерывание, а по возврату из прерывания разрешается. В этом отличие RETI от RET.
									; если на момент прерывания возникнут др. то они будут обработаны, так как их флаги не будут сброшены. Обработка прерываний должна быть как можно короче
									; потеряются только однотипные прерывания, так как бит то один на всех
									; при возникновении прерывания нужно сохранять все что нужно в стек, в том числе SREG

									; часть прерываний нужно считывать без промежуточных прерываний допустим из 16ти разрядного таймера, когда у нас шина 8разрядная.
									; если позволить прерывания между считываниями, то при считыании старших байт получим невалидны значения, таймер то начикал
									; пререывания можно как можно короче делать, заскочил, обработал, выскочил, если данные есть какие, быстро в буфер скинул, а дальше идем фоново работать/обрабатывать их.


; Правильный обработчик, коли мы используем регистры, нужно прежде сохранить, то что находится в них.
RX_OK:	PUSH	R16		; Сохранили R16
		IN		R16,SREG	; Достали SREG в R16
		PUSH	R16		; Утопили его в стеке
		PUSH	R17		; Туда же утопили R17
 
; Теперь можно со спокойной совестью работу работать. 
 
		IN	R16,UDR
		CPI	R16,10
		BREQ	Ten
		RJMP	Exit
 
Ten:	LDI	R17,'t'
		OUT	UDR,R17
 
; А на выходе вернем все как было. 
; Достаем в обратном порядке
 
Exit:	POP	R17
		POP	R16
		OUT	SREG, R16
		POP	R16
		RETI			; Спокойно выходим. Регистры вернул как было.
;---------------------------------------------------------------------------------------------------------------------------------------------------


; EEPROM ==================================================
			.ESEG			; Сегмент EEPROM
