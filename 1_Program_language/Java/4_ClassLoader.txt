Для получения classLoader загруженного класса нужно вызвать статический метод 
	SomeClass.class.getClassLoader()
		Мы получим ClassLoader через который был загружен текущий класс.
		При этом если в этом классе сделать загрузку ещё одного класса, то он будет загружен через этот же ClassLoader.

1. BootStrap - реализован на уровне JVM и не имеет связи с RunTime. 
	Черзе него грузятся классы из директории $JAVA_HOME/lib
	Управлять загрузкой базовых классов можно с помощью ключа -Xbootclasspath, который позволяет переопределять наборы базовых классов.

2. System Classloader — системный загрузчик, реализованный уже на уровне JRE
	Этим загрузчиком загружаются классы, пути к которым указаны в переменной окружения CLASSPATH.
	Управлять загрузкой системных классов можно с помощью ключа -classpath или системной опцией java.class.path.
	ClassLoader.getSystemClassLoader() - получение системного CL

	Application ClassLoader, также известный как системный загрузчик классов, пожалуй, самый user-friendly из всех. Именно этот загрузчик подгружает ваши собственные реализации и библиотеки зависимостей, которые вы передали JVM (явно или неявно) при старте приложения в качестве -classpath (-cp) параметра.

3. Extension Classloader — загрузчик расширений. 
	Данный загрузчик загружает классы из директории $JAVA_HOME/lib/ext. В Sun JRE — это класс sun.misc.Launcher$ExtClassLoader.
	Управлять загрузкой расширений можно с помощью системной опции java.ext.dirs.

	Platform ClassLoader пришел на смену Extension ClassLoader, который искал в $JAVA_HOME/lib/ext, и использовался в Java 8 и более ранних версиях. Это изменение произошло с появлением Системы Модулей (JEP-261)


Current Classloader — это загрузчик класса, код которого в данный момент исполняется. Текущий загрузчик используется по умолчанию для загрузки классов в процессе исполнения.
	У всех дочерних классах есть родительский Classloader - которому делигируется поиск. И так по цепочке вверх - для осуществления максимальной видимости загруженного класса.


При реализации пользовательских загрузчиков важно помнить следующее:
	1) любой загрузчик должен явно или неявно расширять класс java.lang.ClassLoader;
	2) любой загрузчик должен поддерживать модель делегирования загрузки, образуя иерархию;
	3) в классе java.lang.ClassLoader уже реализован метод непосредственной загрузки — defineClass(...), который байт-код преобразует в java.lang.Class, осуществляя его валидацию;
	4) механизм рекурентного поиска также реализован в классе java.lang.ClassLoader и заботиться об это не нужно;
	5) для корректной реализации загрузчика достаточно лишь переопределить метод findClass() класса java.lang.ClassLoader.

Реализация по-умолчанию подразумевает следующую последовательность действий:
	1) вызов findLoadedClass() для поиска загружаемого класса в кеше;
	2) если класса в кеше не оказалось, происходит вызов getParent().loadClass() для делегирования права загрузки родительскому загрузчику;
	3) если иерархия родительских загрузчиков не смогла загрузить класс, происходит вызов findClass() для непосредственной загрузки класса.
			Т.е. если самый родительский (System CL) ClassLoader не нашел класс - генерируется исключение java.lang.ClassNotFoundException после чего и выполняется поиск непосредственным дочерним классом

	Поэтому для правильной реализации загрузчиков рекомендуется придерживаться указанного сценария — переопределения метода findClass().