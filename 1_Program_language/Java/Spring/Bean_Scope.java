// По умолчанию используется область Singleton. Бины с такой областью создаются ровно один раз за все время существования приложения. Каждая инъекция такого бина использует один и тот же объект.
// Получается что эти бины не должны содержать поля (т.е. иметь свой стейт), а только инжектируемые объекты??? Как и в J2E в StateLess бинах?
		// Spring создает ровно один экземпляр объекта, назначенного этим определением бина. Этот единственный экземпляр хранится в кэше таких бинов-одиночек, а все последующие запросы и ссылки на этот именованный бин возвращают кэшированный объект.
		// Область видимости одиночки в Spring лучше всего описать как per-container и per-bean.
		// Область видимости singleton - это область видимости Spring по умолчанию. 
		<bean id="accountService" class="com.something.DefaultAccountService"/>
		<!-- следующее эквивалентно, хотя и избыточно (по умолчанию используется область видимости singleton) -->
		<bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/>



// Область Prototype означает, что новый бин будет создан на каждый запрос (инъекцию):
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.stereotype.Component;
	// Не-singleton область видимости prototype для развертывания бина создает новый экземпляр бина каждый раз, когда выполняется запрос на этот конкретный бин.
	// То есть бин внедряется в другой бин ИЛИ запрашивается через вызов метода getBean() в контейнере. Как правило, следует использовать область видимости prototype для всех бинов, сохраняющих состояние, и область видимости singleton для бинов, не сохраняющих состояние.
	<bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/>
	// В отличие от других областей видимости, Spring не управляет полным жизненным циклом бина-прототипа. Контейнер создает экземпляр, конфигурирует и иным образом компонует объект-прототип и передает его клиенту, без дальнейших записей об этом экземпляре прототипа. 
	// Таким образом, хотя методы обратного вызова жизненного цикла инициализации вызываются для всех объектов независимо от области видимости, в случае прототипов, сконфигурированные обратные вызовы жизненного цикла разрушения не вызываются. Клиентский код должен подчищать объекты, входящие в область видимости prototype, и высвободить ценные ресурсы, которые потребляют бины-прототипы.
	// В некотором смысле роль контейнера Spring в отношении бинов, входящих в область видимости prototype, является заменой оператора Java new. Все управление жизненным циклом после данного момента должно осуществляться с клиентской стороны. (Подробнее о жизненном цикле бина в контейнере Spring см. в разделе Обратные вызовы жизненного цикла).
	// Если вы используете бины, находящиеся в области видимости singleton, и с зависимостью от бинов-прототипов, помните, что зависимости разрешаются при создании экземпляра. Таким образом, если внедрять зависимость от бина-прототипа в бин, находящийся в области видимости singleton, создается экземпляр нового бина-прототипа, а затем внедряется в бин-одиночку. Экземпляр прототипа - это единственный экземпляр, который предоставляется бину, находящемуся в области видимости singleton.

@Scope("prototype")
@Component
public class PrototypeBean {}


//Область Request означает, что новый бин создается на каждый HTTP-запрос. Актуально только для веб-приложений:
import org.springframework.stereotype.Component;
import org.springframework.web.context.annotation.RequestScope;

@RequestScope
@Component
public class RequestScopedBean {}

// Области видимости request, session, application и websocket доступны, только если вы используете реализацию ApplicationContext в фреймворке Spring с поддержкой веб (например, XmlWebApplicationContext).
				//Если вы обращаетесь к бинам, находящимся в области видимости, в Spring Web MVC, то есть в рамках запроса, который обрабатывается Spring DispatcherServlet, никакой специальной настройки не требуется. DispatcherServlet уже раскрывает все соответствующие состояния.
// Если вы используете эти области видимости с обычными IoC-контейнерами Spring, такими как ClassPathXmlApplicationContext, будет сгенерирован IllegalStateException c сообщением о неизвестной области видимости бина.


// Если вы используете бины, находящиеся в области видимости singleton, и с зависимостью от бинов-прототипов, помните, что зависимости разрешаются при создании экземпляра. Таким образом, если внедрять зависимость от бина-прототипа в бин, находящийся в области видимости singleton, создается экземпляр нового бина-прототипа, а затем внедряется в бин-одиночку. Экземпляр прототипа - это единственный экземпляр, который предоставляется бину, находящемуся в области видимости singleton.



/*
	Жизненный цикл бинов
	Singleton
		Создается один раз при инициализации контекста
		Существует на протяжении всего времени жизни приложения
		Все зависимости внедряются единожды
		Подходит для stateless-сервисов и конфигураций

	Prototype
		Создается заново при каждом запросе
		Не хранится в контексте Spring после создания
		Каждый экземпляр независим от других
		Идеален для stateful-объектов

	Взаимодействие Singleton и Prototype
	Важные особенности взаимодействия:
		Singleton может зависеть от Prototype
		Prototype может зависеть от Singleton

	При внедрении Prototype в Singleton создается только один экземпляр (что может быть проблемой)
*/

//Неправильно:
	@Component
	public class SingletonService {
	    @Autowired
	    private PrototypeBean prototypeBean; // Создается только один раз!
	    
	    public void doSomething() {
	        prototypeBean.process(); // Всегда один и тот же экземпляр
	    }
	}

//Правильно:
	@Component
	public class SingletonService {
	    @Autowired
	    private ApplicationContext context;
	    
	    public void doSomething() {
	        PrototypeBean bean = context.getBean(PrototypeBean.class);
	        bean.process(); // Новый экземпляр каждый раз
	    }
	}