
/*
1. Если у объекта есть несколько критических секций т.е. synchronized или методов synchronized то если один поток зашёл в него, то остальные методы и секции synchronized не доступны для других потоков.
	Т.е. один поток блокирует для остальных потоков все synchronized обласит. При выходе из такой области - разблокируется объект и такие секции доступны для следующих потоков.
2. Все синхронизированные секции и методы должны быть синхронизированны по одному объекту.
	По этому самым разумным выбора для объекта синхранизации является текущий объект т.е. this
*/
	synchronized(this){
		...
	}

/*
Итого:
	Исполнитель-задача
		Runnable - здесь бесконечный обработчик в run()

	Поток:
		Thread - запус исполнителя и предоставление контекста.
			- Запуск start(). Иниацилизация потока и вызов run()
			- Предоставляет возможность задать имя потоку.
			- Задача передается в конструкторе Thread.

		Потоки демоны
			Задаётся в thr.setDaemon(true) перед запуском.

	Исполнители:
		ExecutorService - создаёт необходимый контекст для выпонения Runnable.
			ExecutorService ex = Executors.newCachedThreadPool();
			ex.execute(runnableInstance);
			ex.shutdown(); 	- предотвращает отправку новых задач Executor
							- текущий поток (main) - продолжает выполнять задачи, отправленные до shutdown().
							- программа прекратит выполнение после завершения всех задача, переданных в Executor.
							- shutdownNow() - отпрваляет всем потокам interrupt();
		

				- Автоматизация выполнения объектами Thread (по возможности переиспользует созданные объекты Thread).
					- Советуют использовать FixedThreadPool самый быстры. На старте создаёт нужное число потоков (ресурсозатратное) и работает с ними. CachedThreadPool - можно в отладке/тестировании.
				- Как правило одного Executor достаточно на всё приложение для управления всеми задачами.

				- Если нужно получить конкретный поток и допустим управлять им. Нужно запускать не через execute а через submit. Он вернёт Fiture<?> - и через него можно пытаться управлять/завершать.
					Future<?> f = exec.submit(r);
					f.cancel(true);

				Можно использовать ThreadFactory - позволит передавать свою реализация генерации Thread
					- Для задания потока как Daemon;
					- Для задания обработчика ошибок;
					- Для задания имени потоку.

	
		Завершение заблокированных задач/потоков:
			thr.interapt() - завершает заблокированную задачу (т.е. зашедшую в блок synchronized). Устанавливает состояние прерывания потока.
								- Поток выдаст InterraptedException - если он уже заблокирован или пытается выполнить блокировку.
								- Но если метод стоит на IO (вернее на ожидании io) или пытается получить блокировку, то исключение не выбрасывается - непрерываемая блокировка.
									- Для IO нужно закрывать stream - тем самым высвобождая блокировку на IO
									- Для мьютекса для возомжност прервать нужно испльзовать lock.lockInterruptibly() - если на нём ждём, то будет выкинуто исключение в отличии от synchronyzed или lock.lock()
			exc.shutdownNow() - вызывает для каждого потока метод interapt()

			Можно в потоке проще делать цикл while (!Thread.interrupted()){...}
	

	Синхронизация обеспечивается 
		1. Благодаря секциям synchronized и методам synchronized
		2. Объектам lock
			lock.lock() перед try и lock.unlock() в finally.
		3. Синхронизированным коллекциям, объектам Collection.synckronizedList(new ArrayList<SomeClass>())

		Эккель говорит, нужно использовать синхранизацию везде и избегать полностью полагаться на атомарность.
			volatile - просто искючает эту переменную из локального кеша потока и делает изменения видимыми сразу для других потоков.
				Т.е. обеспечивает видимость изменений для всех сразу.
				Но инкремент все равно будет непотокобезопасным.

				Но лучше для этого использовать AtomicInteger - если нужен какй-то инкремент - он потокобезапасен.

				Синхронизация нужна там, где будет несколько потоков, часть из кторых пишут, а часть читают.


	Локальная память потока:
		Напротив, иногда нужно избежать конкурентной работы потоков с одним объектом.
			Создаётся СТАТИЧЕСКОЕ поле ThreadLocal<Integer> thrl = new ThreadLocal<Integer>(){....}

	Связь потоков.
		wait(), notify(), notifyAll()
			- Вызываютя только в синхронизированных блоках или методах.
			- Освобождают объект блокировки, позволяя др. потокам использовать методы и блоки синхронизированные.
				- sleep() - не освобождает объект блокировки.
			- wait() - поток приостанавливается, а блокировка освобождается.
			- notifyAll() - чтоб задача активировалсь из wait она сначала должна захватить блокировку. Задача не активируется, пока блокировка не станет достпна.


			Рекомендации:
				- Необходимо использовать notifyAll() а каждый поток проверить по условию, ему ли был сигнал.
				- wait() должен быть в while(condition) - дабы когда будет уведомления по notifyAll() поток продолжал после проверки ожидать не выходя из wait - если условия для него не поменялись.


		Но вообще предлагается решать задачу взаимеодействия серез синхранизированные очереди:
			LinkedBlockingQueue - неограниченная по размеру очередь.
			ArrayBlockingQueue	- фиксированный размер.