Bootstrap:
	Сетка Bootstrap 3 имеет 4 уровня (или "точки останова").
		1. Очень маленький (для смартфонов .col-xs-*)
		2. Маленький (для планшетов .col-sm-*)								#на типичной небольшой ширине устройства (> 768 пикселей)
		3. Средний (для ноутбуков .col-md-*)								#на типичной ширине носителя (> 992 пикселя)
		4. Большой (для ноутбуков/настольных компьютеров .col-lg-*).		#на типичной ширине носителя (> 1200 пикселя)

	В Bootstrap 12-колоночная сетка.

	Меньший уровнь определяет размер для большей ширины экрана:
		<div class="col-lg-3 col-md-3 col-sm-3">..</div> - это то же самое, что,
		<div class="col-sm-3">..</div>

HTML
	1. <!DOCTYPE html>
	2. Блочные элементы http://htmlbook.ru/html/type/block:
		- Имеют форму прямоугольника.
		- Всегда начинаются с новой строки.
		- Если вложить один блочный элемент в др. блочный элемент, то ширина внутреннего блочного элемента расчитывается относительного родительского.
		- Ширина блочного элемента СОСТОИТ из:
			Ширины блока - width
			Ширины внешних отступов - margin
			Внутренних отступов (полей) - padding
			Границы блока - border
				Итоговая ширина:	width + margin + padding + border
!!!				Для того что бы width + margin + padding учитывались при задании в % а не только width, необходимо задать box-sizing: border-box

		- По умолчанию занимает всю предоставленную ширину(т.е. 100% по умолчанию). Если ДАЖЕ родителю НЕ задана ширина, то будет взята вся ширина родителя.
				Как-бы ширина родителя всегда является известной. Для высоты все иначе.
		- Высота расчитывается исходя из контента если не задано иначе. Если у родительского высота не задана, и при задании дочерниму высоты в % - высота всеравно будет расчитываться относительно контента а не указанной в % высоты. 
			- По этой причине, если для дочернего элемента высота задается в % то высоту нужно задавать и для родителя (либо в четко пикселях либо в % но при этом если в % то у верхнего родителя тоже должна быть задана высота в %) - (Если по иерархии все в %, то нужно начинать от html и body), либо родителю четкая высота в px а уже дочернему в %.
			- При явном задании высоты, может произойти переполнение, по этой прчине нужно зазадть значение overflow: как поступать с текстом.
	
	3. Строчные элементы:
		- Являются частью др. элемента и используются для изменения части теста или его форматирования.
		- Могут содержать только данные и др. строчные элементы
		- Ширина определяется по их содержимому и отступам и границам
		
	4. Рзаличают физические и логические разметки
		Логические - помогают именно компьютеру определить что есть что а не для физического форматирования

	5. Новые теги из html5:
!!!		Нужно задать их как блочные элементы. Ибо дефолтно являются строчными display:inline
		<style>
  			section, header, nav, article, aside, footer { display: block	| }
		</style>

		<section> - - формирует часть чего-то еще.
		<article>	- это что то, что само по себе. Может быть статьей в журнале/форуме/газете, запись в блоге или др. самостоятельный фрагмент. Блог может содержать публикации, и каждая публикация будет находиться в элементе <article> возможно с одним или более элементами <section>
						Может иметь свой <header>, <footer>, <h>, <nav>
				<article>
					<section>
					</section>

					<section>
					</section>

				</article>

		5.1. Артикль - это статья и внутри должна быть структурированна информация по темам или раздельным частам информации.

		
	align - не рекамендуется в html-5. Нужно через css

CSS
	1.1. Если мы говорим о соседнем селекторе допустим tag1 + tag2 то применится только к tag2 что идет сразу после tag1 т.е. не для верхних соседей и для одного следующего
	1.2. Селектор атрибута
		tagName[atribute] {}
		tagName[atribute="value"]

	2. Приоритет
		Чем специфичнее селектор, тем выше его приоритет.
		По мере убывания:
			а. Идентификатор
			б. Селектор класса, атрибутов, псевдоклассво
			в. селектор типа, псевдо элементов.

		Встроенные селектор приоритетнее внешних. 
			Во внешних можно использовать !important для поднятия приоритета.

		Каскадность:
			Если стили противоречат (при этом специфичность одинаковая) то применяется тот что последний/ниже по коду
			Если не противоречат, то они суммируются.

		Дочерний наследует родительский стиль, но при этом можно задать отдельно для дочернего класса.

		Первым имеет приоритет внутренний стиль, затем глобальный стиль и в последнюю очередь связанный стиль. 

		Если для элемента задано два класса и у этих классов различные значения для одного свойства, то берется то значение, что ниже по коду.

	5. Псевдоклассы:
		Начинаются с двоеточия : 
		Пример span:hover {color:red	|}

----------------------------------------
		display : block;		

		display : inline-block;
			    - Высота и ширина элемента вычисляется браузером автоматически, исходя из содержимого блока.
			    - Размеры содержимого можно устанавливать через свойства width и height.
			    - Ширина блока получается сложением значений width, margin, border и padding.
			    - Высота блока получается сложением значений height, margin, border и padding.
			    - Несколько элементов идущих подряд располагаются на одной строке и переносятся на другую строку при необходимости.
			    - Элементы можно выравнивать по вертикали с помощью свойства vertical-align.
			    - Перенос текста считается за пробел.

----------------------------------------
	На сегодня есть три способа размещения:
		1. postition : static|relative|absolute|fixed

		2. float : left|right|none		- считается устаревшим, но нужно знать, так как до сих пор в старых макетах можно встретить.

		3. display : flex 				- считается текущим майн-стрим.



	POSITION:-----------------------------------

		Позиционирование контролируется через свойство position. Имеет 4 значения: static, fixed, relative и absolute.
		Для указания точного места расположения позиционированных элементов, используются CSS свойства: top, right, bottom и left. Пример top: 0px;

		1. position: static	| - дефолтное позиционирование. Элемент появится на своем обычном месте.
					* позиционируется относительно границ родительского блока.

		2. position: relative	| - относительное позиционирование. Позволяет использовать свойства:  top, bottom, left и right, для расположения элемента относительно того места, где бы он появился при обычном позиционировании, оставляя пустое пространство там где они бы располгалась изначально.
					* Позиционируется относительно границ родительского блока.
					* Не удаляется из общего потока.
					* Не влияют на др. лементы, НО могут перекрывать др. элементы.
					* Примечание: элементы с относительным позиционированием (relative) обычно используют в качестве родителя для элементов с абсолютным позиционированием (absolute).

		3. position: absolute	| - удаляется из документа, и появляется там, где ему скажут.
					* Размещаются относительно окна браузера или относительно ближайшего позиционированного предка у которого свойство position имеет значение отличное от static.
					* Размер блока устанавливается по содержимому.
							Что бы др. элементы не занимали пространство его, добавляют еще один элемент что имеет такой-же размер. Или у соседей играются с margin.
					* В абсолютно-позиционированном элементе можно задавать противоположные значения, что приведет к растяжению left: 10px; right: 10px;
					* По сути элемент удаляется - по этму размеры при задании в % будут вестись относительно экрана/окна - у меня так и было, хотя я задавал родителю значение postion  отличный от static.

		4. position: fixed	| - является подразделом абсолютного позиционирования. Единственное отличие, он находится всегда в видимой части экрана, даже во время прокрутки.
					* Удаляется из общего потока.
					* Располагается на странице относительно окна браузера.
					* Фиксированные элементы могут перекрывать др. элементы.

		5. Назанчив родительскому блоку position: relative, дочерние блоки будут позиционироваться относительно его границ.
			!!!!!При этом родительскому блоку нужно задать фиксированную высоту, что бы следующие элементы не скрылись за ним.


		6. Когда блоки находятся вне общего потока, они начинают перекрывать друг друга. для этого испльзуется z-index.
			* Чем больше значение, тем выше элемент.
				z-index: 2	|

	FLOAT:-----------------------------------

		Свойство float позволяет смещать элемент, и имеет значение: left, right, none
		* Удаляется из основного потока.
		* Примечание: элементы с абсолютным и фиксированным позиционированием игнорируют свойство float.
!!!		* Единственным требованием для любого плавающего элемента является наличие фиксированной ширины (width).
			- Если для плавающего элемента явно не установлена ширина (width), то он сжимается по ширине до размеров содержимого.
		* Плавающие элементы не влияют на высоту родителя, то есть, если есть некоторый контейнер, а в нём находятся только плавающие элементы, то высота контейнера будет равна нулю. Решить данную проблему можно следующими способами:
			- Задать фиксированную высоту - в тех случаях, когда известно какая должна быть высота контейнера.
    		- Применить свойство overflow со значением auto или hidden к контейнеру, тогда плавающие элементы будут учитываться при вычислении высоты контейнера. Этот способ можно использовать когда заранее не известно какая должна быть высота контейнера.
+++   		- Либо добавить в конец <div> у которого будет задано clear: both (т.е. он ляжет в конец но так как содержимого нет, он визуально не будет виден).
    		- Либо добавить псевдоэлемент и скрыть его.
				.clearfix:after {
					content: "."; /* добавить содержимое: "." */
					display: block;  /* сделать блоком, т.к. inline не может иметь clear */
					clear: both;  /* с обеих сторон clear */
					visibility: hidden; /* сделать невидимым, зачем нам точка внизу? */
					height: 0;  /* сделать высоту 0, чтобы не занимал место */
				}

    	* «Плавающий блок» смещается влево или вправо до тех пор, пока его внешний край не коснется края содержащего блока или внешнего края другого плавающего блока.
    		- Если для плавающего элемента недостаточно места по горизонтали, он будет смещаться вниз до тех пор, пока не уместится. При этом остальные элементы уровня блока будут его игнорировать, а элементы уровня строки будут смещаться вправо или влево, освобождая для него пространство и обтекая его. 

		* Когда вы определяете плавающий элемент, вам нужно расположить его в коде прямо под тем элементом, под которым он должен "плавать", всё остальное содержимое расположенное в коде под плавающим элементом будет обтекать его на веб-странице. 
		* Поскольку плавающий элемент исключается из общего потока, то остальные блочные элементы, расположенные в коде после него, загружаются на страницу так, будто этого элемента там и не было.
			- В отличие от блочных, при размещении строчных элементов или простого текста, расположенного внутри блочного элемента, учитываются границы плавающего элемента, поэтому строчные элементы и текст обтекают его.
			- Плавающий элемент находится выше нижеследующих элементов.		
		* В одном ряду можно размещать несколько плавающих элементов, если это позволяет ширина родительского элемента.
		* Назначив блоку float - мы его отклоняем к правлому или левому краю, а следующий за блоком текст будет обтекать его, как картинку.
		* Для отмены обтекания используется clear: left, right, both, none
		* Для колонок с переменной высотой, абсолютное позиционирование не подходит

		В отличии от обычных блочных элементов границы у них не схлопываются(не объединяются).

	FLEX:-----------------------------------

		При использовании flex для внутренних элементов не работает float, clear, vertical-align

		display: flex; - делает дочерние элементы резиновыми - flex, а не инлайновыми или блочными как изначально (т.е. дочерние строчные и блочные элементы ведут себя одинаково. Ширина блоков ровна их содержимому с учетом внутренних полей и рамок элемента.)

			flex - приоритет у раскладки, если ширины недостаточно, контент вылезет за границы.
					flex-wrap: wrap - в случае переполнения, нужно использовать
			inline-flex - приоритет у содержимого, контент расширяет блок до необходимой ширины, чтоб строчки по возможности поместились.
				display : inline-flex - если нужно расставить inline элементы как flex блоки.

		flex-direction: row|row-reverse|column|column-reverse - расположение вложенных блоков.

		flex-wrap: nowrap|wrap|wrap-reverse - переносить на новую строку?

		flex-flow - объединяет в себе два свойства flex-direction и flex-wrap. Можно задать оба flex-flow: column-reverse wrap;

		.flex-container {
			/*генерирует flex-контейнер уровня блока*/
			display: -webkit-flex; 
			display: flex; 
		}

		.flex-container {
			/*генерирует flex-контейнер уровня строки*/
			 display: -webkit-inline-flex;
			 display: inline-flex; 
		}

		.flex-container {
			display: -webkit-flex; 
			-webkit-flex-direction: row-reverse;
			-webkit-flex-wrap: wrap;

			display: flex;
			flex-direction: row-reverse;
			flex-wrap: wrap;

		}

		flex-flow: row nowrap;
		-webkit-flex-flow: row wrap;
		flex-flow - объединяет flex-direction и flex-wrap


		-------Элементы внутри контейнера Flex

		- Если родительский блок содержит текст или изображения без оберток, они становятся анонимными flex-элементами. Текст выравнивается по верхнему краю блока-контейнера, а высота изображения становится равной высоте блока, т.е. оно деформируется.
		- Для flex-элементов блокируется их значение свойства display
		- Пустое пространство между элементами исчезает
		- Абсолютно позиционированный flex-элемент не участвует в компоновке гибкого макета.
		- Поля margin соседних flex-элементов не схлопываются.
		- Процентные значения margin и padding вычисляются от внутреннего размера содержащего их блока.
		- margin: auto; расширяются, поглощая дополнительное пространство в соответствующем измерении. Их можно использовать для выравнивания или раздвигания смежных flex-элементов.
		- Автоматический минимальный размер flex-элементов по умолчанию является минимальным размером его содержимого, то есть min-width: auto;. Для контейнеров с прокруткой автоматический минимальный размер обычно равен нулю.


		Свойство определяет, будет ли flex-контейнер однострочным или многострочным

		flex-wrap : 
					- nowrap //значение по умолчанию
					- wrap //Flex-элементы переносятся, располагаясь в несколько горизонтальных рядов (если не помещаются в один ряд) в направлении слева направо (в rtl справа налево).
						- возмжно тут нужно будет задать минимальную ширину.


		Гибкость:

			- коэффициент растяжения 	Коэффициент увеличения ширины flex-элемента относительно других flex-элементов.
			- коэффициент сужения 	Коэффициент уменьшения ширины flex-элемента относительно других flex-элементов.
			- базовая ширина 	Базовая ширина flex-элемента.

			flex-grow
				Flex-контейнер распределяет свободное пространство между своими дочерними элементами (пропорционально их коэффициенту flex-grow) для заполнения контейнера или сжимает их (пропорционально их коэффициенту flex-shrink), чтобы предотвратить переполнение.

				flex-grow
					- по умолчанию равно 0
					- значение не является абсолютным, а является относительным. Т.е. важно значение у одного по отношению к другому.
					- работает только для главной оси.

				flex-shrink
					- определяет насколько блок можно уменьшить в размерах (используется, когда элмент не вмещается в контейнер)
					- по умолчанию для каждого блока равен 1 (чем выше значение, тем больше он будет сжиматься)

				flex-grow, flex-shrink - отвечают за темпры роста.


				Flex-элемент будет полностью «негибок», если его значения flex-grow и flex-shrink равны нулю, и «гибкий» в противном случае.

				Свойство flex является сокращённой записью свойств flex-grow, flex-shrink и flex-basis. Значение по умолчанию: flex: 0 1 auto;
					Можно указывать как одно, так и все три значения свойств. Свойство не наследуется.
					Пример:
						flex: 2 200px; - сначала задаст минимальную ширину в 200px а потом распределит свободной пространство согласно flex-grow

			flex-basis - отвечает за изначальный размер элементов до того, как они будут изменены другими свойствами CSS Flexbox.
					- Это свойство определяет размер элемента по умолчанию перед распределением оставшегося пространства.
					- Влияет на размер элементов вдоль главной оси.
					- Если установлено значение 0, дополнительное пространство вокруг содержимого не учитывается. Если установлено значение auto, дополнительное пространство распределяется в зависимости от его flex-grow значения. Ключевое слово auto означает «смотри на мое width или height свойство».

		Выравнивание:
			justify-content - выравнивание вдоль главной оси.
					flex-start
					flex-end
					center
					space-between	-	задаёт одинаковое расстояние между блоками, но не между контейнером и блоками
					space-around	-	также задаёт одинаковое расстояние между блоками, но теперь расстояние между контейнером и блоками равно половине расстояния между блоками.


			align-items и align-self - выравнивание вдоль поперечной оси.
				align-items - задается для контейнера и влияет на все элементы
				align-self - для конкретного элемента.

					flex-start
					flex-end
					center
					stretch
					baseline

			Выравнивание строк flex-контейнера: align-content.



------------------------------------------------------------------------------------------
HTML
	Атрибуты:
		1. Атрибуты не чувствительны к регистру
		2. Атрибуты идуте через пробел
		3. Атрибуты, значение которых совпадает с именем называются логичискими или пустыми. Значение можно упустить пример: <input disabled>.
		4. Для логических атрибутов, присутствие атрибута означает true, отсутствие логического атрибута false.
		5. В одном элементе не должно содержаться два одинаковых атрибута (можно проверять в JS перед добавлением).

	Элементы:
		Абзац:
			<p> - Разделяет текст вертикальным отступом. До и после абзаца добавляется пустая строка.
					1em - это единица измерения равная высоте шрифта.
		Ссылки:
			<a href="page.html" style="text-decoration: none	|">Ссылка без подчёркивания</a>

			<a href="httр://www.puzzleweb.ru">
        		<img src="logo.png" alt="ссылка" width="100" height="78"> - картинка ссылка.
        	</a>

        	Ссылка на раздел страницы
        		<h2 id="a1">Заголовок</h2>

        		<a href="#a1">ссылка</a>

        		<!-- Абсолютный адрес -->
				<a href="httр://www.example.com#a1">ссылка</a>
 
				<!-- Относительный адрес -->
				<a href="example/page.html#a1">ссылка</a>


CSS
	
	Встроенный стиль, применяется только к элементу у которого указан, и к дочерним элементам.
		Атрибуты и значения задаются не через = а через :
		Перечисление атрибутов идет через 	|

Блоки:
	Отступы
		- Отступы прозрачны, на них не распространяется цвет фона или фоновая картинка, заданная для блока. Однако если фон установлен у родительского элемента, он будет заметен и на отступах.
		- Отступы в отличие от полей могут принимать отрицательное значение, это приводит к сдвигу всего блока в указанную сторону. Так, если задано margin-left: -10px, это сдвинет блок на десять пикселов влево.
		- Для отступов характерно явление под названием «схлопывание», когда отступы у близлежащих элементов не суммируются, а объединяются меж собой.
		- Отступы, заданные в процентах, вычисляются от ширины контента блока. Это касается как вертикальных, так и горизонтальных отступов.

	Ширина блока:
		Это сумма width+padding+border+margin
		Если width не установлен - то будет заниматься всю ширину предоставленную окном браузера или родителя - т.е. это значение width:auto

	1.
		box-sizing: border-box - ширина начинает включать  padding и border. Но без margin. Но не все барузеры понимают.
			div { 
    			width: 100%; /* Ширина */
    			background: #fc0; /* Цвет фона */
    			padding: 20px; /* Поля */
    			-moz-box-sizing: border-box; /* Для Firefox */
    			-webkit-box-sizing: border-box; /* Для Safari и Chrome */
    			box-sizing: border-box; /* Для IE и Opera */
   			}

   	2.
   		Создается объемлющий div и задается его ширина. А уже для вложенного задается все остаельное - и padding и margin - а сам width задавать не нужно, ибо всю доступную ширину предоставляет родительский div.

   	Высота блока.
   		- Так же это сумма: Высоты контента (height), полей (padding), границ (border) и отступов (margin).
   		- Если же здесь не будет задано, то есть height: auto - то высота будет соответствовать контенту.

   		Для width ширина родителя изветсна, даже если не указана явно, а вот для height несколько иначе.

   		В отличии от width для height высота блока родителя не указывается(вернее не расчтывается), т.е. нужно указывать руками для родителей и для самих блоков. Если не указать для родителей, процент будет указывать высоту относительно контента.
   			   html, body { 
    				height: 100%; /* Высота родителя */
    				margin: 0; /* Убираем отступы у страницы */
   				}
   				div {
    				height: 100%; /* Высота */ 
    				background: #fc0;
    				margin: 10px;
    				padding: 20px;
    				border: 1px solid #000;
   				}

   		Еще момент, для высоты если задано значение, нужно задавать overflow (auto или hidden)- иначе контент при привышении будет выходить за границы.
   	
