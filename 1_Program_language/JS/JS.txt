Мы можем наблюдать две вещи:
    - Функция-исполнитель запускается сразу же при вызове new Promise.
    - Исполнитель получает два аргумента: resolve и reject — это функции, встроенные в JavaScript, поэтому нам не нужно их писать. Нам нужно лишь позаботиться, чтобы исполнитель вызвал одну из них по готовности.
	
- Подведём промежуточные итоги: исполнитель выполняет задачу (что-то, что обычно требует времени), затем вызывает resolve или reject, чтобы изменить состояние соответствующего Promise.
- Свойства state и result – это внутренние свойства объекта Promise и мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы .then/.catch/.finally, про них речь пойдёт дальше.
- Объект Promise служит связующим звеном между исполнителем («создающим» кодом) и функциями-потребителями , которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов .then и .catch.


let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done!"), 1000);
});

// resolve запустит первую функцию, переданную в .then
promise.then(
  result => alert(result), // выведет "done!" через одну секунду
  error => alert(error) // не будет запущена
);

let promise = new Promise(function(resolve, reject) {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});

// reject запустит вторую функцию, переданную в .then
promise.then(
  result => alert(result), // не будет запущена
  error => alert(error) // выведет "Error: Whoops!" спустя одну секунду
);

Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента:
.then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction)

- Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
- Обратите внимание, что finally(f) – это не совсем псевдоним then(f,f), как можно было подумать.

Есть важные различия:

    - Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.
		- Обработчик finally не имеет аргументов, а результат promise обрабатывается в следующем обработчике.
    - Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.
    - Обработчик finally также не должен ничего возвращать. Если это так, то возвращаемое значение молча игнорируется.
		- Единственным исключением из этого правила является случай, когда обработчик finally выдает ошибку. Затем эта ошибка передается следующему обработчику вместо любого предыдущего результата.

Подведем итог:
    - Обработчик finally не получает результат предыдущего обработчика (у него нет аргументов). Вместо этого этот результат передается следующему подходящему обработчику.
    - Если обработчик finally возвращает что-то, это игнорируется.
    - Когда finally выдает ошибку, выполнение переходит к ближайшему обработчику ошибок .catch
		- При этом теряется предыдущая информация???


Например, здесь результат проходит через finally к then
	
new Promise((resolve, reject) => {
  /* сделать что-то, что займёт время, и после вызвать resolve или может reject */
})
  // выполнится, когда промис завершится, независимо от того, успешно или нет
  .finally(() => остановить индикатор загрузки)
  // таким образом, индикатор загрузки всегда останавливается, прежде чем мы продолжим
  .then(result => показать результат, err => показать ошибку)
  
- Если промис в состоянии ожидания, обработчики в .then/catch/finally будут ждать его.
- Иногда может случиться так, что промис уже выполнен, когда мы добавляем к нему обработчик.
	- В таком случае эти обработчики просто запускаются немедленно: