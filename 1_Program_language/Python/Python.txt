Python:
Атрибуты:
        nameModule.name где namе - атрибут модуля, nameModule - объект модуля.
                Имена в модулях, яляются атрибутами модуля и образуют одно пространство имен - глобальное пространство.
                    - Т.е. видимо когда загружается в интерпретатор данный модуль, создается объект модуля.
                    - Объект модуля создается один на запуск программы.
        Под атрибутами понимают, все что идет после точки. Т.о. атрибуты модуля и глобальные имена имеют прямое соответствие, они совместно использую одно пространство имен.
        
        В отличии от классов, объект модуля может существовать в одном единственном экземпляре, по этой причине, необходимо использовать reload для обновления объекта модуля, что бы отобразить внесенные в модуль изменения.

        import sys
        sys.path.append("path") # определяет место, где искать импортируемые модули.

        Выполнение функции - вводит новую таблицу имен, используемую для локальных переменных. Все присвоения переменным в теле функции сохраняются в локальной таблице имен.
            Поиск переменных производится:
                В локальной таблице имен, затем в глобальной, в последнюю очередь в таблиц встроенных имен.        

Различают три пространства имен(области видимости).
        Встроенное     -     это то что относится к python (исключения итд)  и формируется при запуске интерпретатора, и существют на протяжении всего времени выполнения.
        Глобальное     -     это пространство имен модуля совпадающее с пространством атрибутов. Создается при считывании модуля, обычно существует до завершения работы интерперетатора.
        Локальное     -     пространство функции или класса. Для метода пространство создается при вызове метода и удаляется при выходе.
                        Все что вне функции или класса относится к глобальной области.  

        Пространство имен определяет отображение имен в объекты.
        Область видимости - фрамгент программы, в котором пространствен имен непосредсвтвенно доступно, т.е. нет необходимости использовать точку.
            
    Динамический поиск имен:
        1. В локальной области
        2. В голобальной области (если это внутри метода, что внутри класса то: область класса → область модуля)
        3. Во внешней области - область встроенных имен.

    Инструкции выполняемые на верхнем уровне, т.е. читаемые из файла или интерактивно, рассматриваются как часть модуля __main__, имеющего собственное глобальное пространство имен.
        Встроенные имена также находятсяв модуле __builtin__


    global - делает обявляемый атрибут(имя) глобальным. Дефолтно если мы определяем в методе или классе имя оно является локальным, а с данным параметром мы делаем его глобальным (т.е. принадлежащим модулю)
    del - удаляет имя из локального пространства имен. (Удаляет имя а не объект к которому привязано имя)
    nonlocal - делает переменную доступной на уровень выше. Т.е. во вложенной функции, мы делаем переменную доступной в объемлющей функции итд.

    def, class, import, lambda - (функции, модули и классы) представляют собой объекты.

    Модули содержат операторы.
    Операторы содержат выражения.

Модуль:
        Импортирование:
            Выполняются следующие шаги:
            1. Поиск файл модуля
            2. Компиляция
            3. Выполнение кода модуля, для создания объектов, что в нем определени.

            При повторном импортировании, эти три шага пропускаются.
!            Уже импоритованные модули находятся в таблице sys.modules

        Каждый модуль имеет собственное пространство имен, являющееся глобальной областью видимости для всех определенных в нем функций.
            Модуль существует в единичном экземпляре (в отличии от классов и их экземпляров), по этому для модуля при изменени требуется reload.

        Поиск модулей:
            1. Ищется в текущем каталоге (каталог запускаемого модуля)
            2. Потом в PYTHONPATH (т.е. то что хранится sys.path)
            3. Каталог стандартной библиотеки.
            4. Содержимое любых файлов .pth
            5. Подкаталог site-packages, где размещаются сторонни расширения.

            Объединение пяти пунктов образует sys.path.
            Будет выбран первый найденный файл совпадающий с именем модуля.

        Операция импортирования происходит однократно.
            Операторы import и from по аналогии с def являются исполняемыми. Они могут быть вложены в if
                import - присваивает имени объект целевого модуля.
                from - присваивает одному или несколькоим именам объекты с таким же именами из др. модуля (по сути происхоидт КОПИРОВАНИЕ в одноименные переменные).
                    - Имена КОПИРУЮТСЯ с помощью from становятся ссылками на разделяемые объекты (как к примеру a=list() и b=a и изменения в b будут влиять на a - так как это ссылки на один объект)
                    - Но вот для обычных переменных (для примера: x=1) все это по другому.
                        -- Через from мы скопировали переменную, и при изменении в этом модуле, изменения в исходном модуле влиять не будут.
                        -- Для этого нужно с помощью import получить имя модуля и выполнить изменение в исходном модуле.

                        Пусть текущий модуль moduleB. 
                            А moduleA содержит две переменные x=1 и y=[1, 2, 3]

                            from moduleA import x, y
                            x=42    #Предположим, что мы находимся в moduleB и следовательно эти изменения в будут только в модуле moduleB и не повлияют на moduleA. Это касается простой переменнной.

                            import moduleA
                            moduleA.x=42 #А вот в этом случае, изменяя х мы изменим х в moduleA (так как в этом случае не проиходит копирование, а происходит работа с переменной moduleA)

    Пакеты:
        import dir1.dir2.mod
        form dir1.dir2.mod import x

        import dir1.dir2.mod as modd
        form dir1.dir2.mod import x as xxx


        В этих каталогах должны быть __init__.py

        -----
        from package import item    #item может быть модулем, подпакетом, функцией, классом или переменной. Интерпретатор, проверят определено ли имф item в пакете. если нет, считает его модулем и пытается загрузить.
        #from Sound.Effects.echo import echofilter - импортируется конкретная функция.

        import item.subitem.subsubitem #каждая единица, кроме последней, должна быть пакетом. Последняя единица может быть модулем или пакетом, но не может быть классом, функцией или переменной, определенной в предыдущей единице.

    Перезагрузка модулей:
        Перезагрзука модулей выполняется через reload.
            При этом содержимое модуля будет выполнено повторно.

        reload - является функцией а не оператором.

        В отдельно взятую программу импортируется только одна копия каждого модуля. reload - обновляет разделяемый объект единственного экземпляра на месте.

Справка:
    s = 'a'
    dir(s) - выведит перечень имен атрибуты свойственных объекту.
    help(s.replace) - выведет подробную справку по методу. help - это по сути PyDoc

    также обе принимают и типы данных str, list, dict
    
Классы:
    Все атрибуты класса, включая поля данных являются открытыми, а все методы виртуальными.
        Виртуальные функции — специальный вид функций-членов класса. Виртуальная функция отличается об обычной функции тем, что для обычной функции связывание вызова функции с ее определением осуществляется на этапе компиляции. Для виртуальных функций это происходит во время выполнения программы.
            Виртуальная функция — это функция, которая определяется в базовом классе, а любой порожденный класс может ее переопределить. Виртуальная функция вызывается только через указатель или ссылку на базовый класс.

    Имя атрибутов экземпляров перекрывают имена методов классов. По этому для избежания конфликтов нужно именовать по разному, или прийти к соглашению о приставках/суффиксах.

    В python3 классы наследуются от object при этом object явно указывать не нужно. А вот в python2 нужно явно указать object.

    - Есть понятие объект класса и объект экземпляра:
        ! Класс - играет роль фабрик экземпляров. Их атрибуты - данные и функции, наследуются всеми экземплярами, созданными от них.
        ! Экземпляр - конкретный экземпляр.
            ! Экземпляр из себя представляет новое пространство имен.
        ! Атрибуты классов ведут себя как статические атрибуты их экземпляров (то есть общие для всех экземпляров данного класса).
            - Однако присвоить такому атрибуту новое значение Вы можете, только обратившись к нему как атрибуту того класса, в котором он определен (в противном случае Вы лишь создадите новый атрибут экземпляра с таким же именем. Т.е. нужно так так ClassName.field=x а не так self.field=x или instance.field=x).
!           - Унаследованные атрибуты класса присоединяются только к классу, они не копируются в экземпляры.
                - Для доступа к атрибутам класса через __dict__ нужно получить у экземпляра объект класса через __class__, потом использовать __dict__ и при необходимости подняться вверх __bases__ и повтороить все занова.
        ! Атрибуты класса обычно присоединяются к классам путем присваивания внутри class, а не во вложенных def
        ! Атрибуты экземпляра обычно присоединяются к экземплярам путём присванивания значинй специальному аргументу с именем self.
            !!! Нужно учитывать, что подобно простым переменным, атрибуты классов и экземпляров не объявляются заранее, а появляются, когда им впервые выполняется присваивание значений.
                Т.е. ниже по тексту до вызова setParam2 в экземпляре класса переменной param еще не существует.
            - Каждый объект экземпляра наследует атрибуты класса и получает собственное пространсово имен.
                - Объекты экземпляров начаниают свое существование пустими, но наследует атрибуты, имеющиеся в объектах классов, из которых они были сгенероированны.
            - Объекты экземпляров - является уникальным пространсвом имен.
        ! Так же как и инструкция def, инструкция class является выполняемой инструкцией. Когда она выполняется, она создает новый объект класса и присваивает его имени, указанному в заголовке инструкции class. Кроме того, как и инструкции def, инструкции class обычно выполняются при первом импортировании содержащих их файлов.
        
    - Инструкция def - является оператором присваивания. Он присваивает объект функции - имени фнукции.
    - Инструкция class - создает объект класса и присваивает ему имя (по сути создается объект и имени передается ссылка) отличие от Java в том что class в Java является объявлением а в Python инструкцией.
        ~ Как и в случае def выполняется при загрузке(при первом обращении к модулю).
        ~ Присваивания внутри инструкции class создает/формирует пространство имен атрибутов объекта класса.
        ~ Когда выполняется оператор class (не вызов класса для создания экземпляра), он запускает все операторы, в теле с начала и до конца. Присванивания, происходящие во время такого процесса, создают имен в локальной области видимости класса, которые становятся атрибутами в ассоциированном объекте классат.

??? Самое важное, что методы в классах не обладают собственной областью видимостью(имен).
        - Вызов объекта класса (как метода - по сути в Java это называется конструктор) возвращает объект экземпляра. 
            ~ Какждый экземпляр приобретает свое собственное пространство имен.
            ~ Каждый экземпляр НАСЛЕДУЕТ атрибуты класса.
            ~ self создает или изменяет данные экземпляра а не класса (т.е. сохраняет значение в пространстве имен экземпляра на не класса.).
                При этом конкретного экземпляра а не родителя.
            ~ Атрибуты экземпляра переопределяют/перекрывают атриуты класса и методы.
                Т.е. изменять нужно переменные только через методы. Это будет изменять только значния экзмпляра, но не объекта класса. А все поля нужно делать приватные.
                class MyClass2:
                        param2 = 2
                        
                        def getParam2(self):
                                return self.param2

                        def setParam2(self, varr):
                                self.param = 1
                                self.param2 = varr

                        def setParam2(self, varr): #Здесь показывается, что метод имеет доступ к глобальным атрибутам, как обычная функция модуля. Так как он определен в классе, его глабальными атрибутами является определение классa.
                                MyClass2.param2 = varr

                В python нет перегрузки методов, но сделано для примера. Эти методы будут менять разные переменные. Т.е. первый set для экземпляров будет менять значение, а второй для класса.
                Это видно при получении через getParam и через получение по АТРИБУТУ класса.

                Переменные экземпляра переопределяют перменные класса и методы.
                    Как и в Java - переменная класса доступна для всех экземпляров.
      
    Множественное наследование:
            Поиск имен итд идет слева на право. mro()

    Super:
        Для обращения к методам или полям родителя используется метод super().            
        
            Для множественного наследования:
                - Поиск будет осуществляться согласно mro - method resolution order
!               - Для класса можно вывести этот порядок SomeClass.mro()

    Вызов метода экземпляра:
        1. instance.method()
        2. ClassName.method(instance)

    Атрибуты класса и экземпляра:
        Атрибуты присоедененные к классам - доступны всем подклассам и экземплярам.
            Атрибуты класса формируются на верхнем уровне т.е. сразу после class, а не в def.

        Атрибуты присоедененные к экземплярам - доступны только этим экземплярам.
            Атрибуты экземпляра формируются в def путем присваивания self
                Вложенные в class операторы def присваивают имена внутри класса, они в итоге присоединяют к объекту класса атрибуты, которые будут наследоваться всеми экземплярами и подклассами.
    
    Методы:
        Методы отмечанные в виде __X__ могут перехватывать операции.
        К примеру:
            __add__ вызывается когда с объектом вызывается +
            __str__ когда требуется выводить объект на пчать.

    Вызов родительского метода:
        class B(A):
            def method(self, ...):
                A.method(self, ...)

            Внимательно читаем II том Лутц 5изд - "Расширение методов. Хороший способ".
                Написано следующее:
                    Обращение через имя класса, отменяет поиск в иерархии наследования и запускает вызво выше в дереве КЛАССОВ чтобы выполнить специфическую версию.
                    Так рекамендуется вызывать методы вверх.

        Да можно через super но она плохо работает с множественным наследованием, и методами операций такими как __add__ итд.
        Лутц рекамендует обращаться по именам к суперКлассам.

        еще один пример работы с super
            super(SomeClass, self) #SomeClass - класс с которого будет выполняться поиск и выше. Можно указать текущий класс, а можно указать любой вверх по иерархии.

    Возможно два вида вызовов методов:
        экземпляр.медот(аргументы...)
        класс.медот(экземпляр, аргументы...)


    экземпляр.__class__
    объект.__dict__     #выведет переменные экземпляра.

    Абстрактные классы:

        from abc import ABCMeta, abstractmethod

        class Super(metaclass=ABCMeta):
            def delegate(self):
                self.action()
            @abstractmethod
            def action(self):
                pass

        Либо можно объявить метод, который будет выкидывать исключение. И если его не переопределить, то будет генерироваться исключение.

    В python не возможна перегрузка методов. Т.к. def только присваивает объект функции имени, что указано после def. Т.е. последнее присваивание и будет являеться реализацией.


    Новые классы python3:

        Методы __x__ - т.е. те что используеются для прехвата операций такие как __getitem__ при поиске пропускают экземпляры и ищут только в классах.
            - Т.к. методы __getattr__ и __getattribute__ больше не вызываются для поиска в методах вида __x__. (Нужно напомнить, что __getattr__ вызывается, когда обращаемся к переменной которой нет в классе или объекте. А __getattribute__ вызывается каждый раз, вне зависимости есть эта переменная или нет).
                -- Это может привести к нюансам в метаклассах.
                    См. Work_with_class/search_default_method.py
                        См. Лутц II-том стр. 225  
                        X[I]
                        > X.__getitem__(I)            #Python2
                        > type(X).__getitem__(X, I)   #Python3
            - Но обращение по явным именам, методами __x__ по прежнему обрабатывается и выполняется.
        




Структура каталогов проекта Python

    Project/
    |-- bin/
    |   |-- project
    |
    |-- project/
    |   |-- test/
    |   |   |-- __init__.py
    |   |   |-- test_main.py
    |   |   
    |   |-- __init__.py
    |   |-- main.py
    |
    |-- setup.py
    |-- README


Исключения:
    Цепочка исключений работает так же как и в Java (по этому очредность располагаем так же от специфического к общему).


With...as
    with <Выражение>[ as <Переменная>]:
        <Блок, в котором перехватываем исключения>

    Вначале вычисляется <Выражение>, которое должно возвращать объект, поддерживающий протокол. Этот объект должен иметь два метода: __enter__() и __exit__(). Метод __enter__() вызывается после создания объекта. Значение, возвращаемое этим методом, присваивается переменной, указанной после ключевого слова as. Если переменная не указана, возвращаемое значение игнорируется. Формат метода __enter__():

    __enter__(self)

    Далее выполняется выражения внутри тела инструкции with. Если при выполнении возникло исключение, то управление передается методу __exit__(). Метод имеет следующий формат:

    __exit__(self, <Тип исключения>, <Значение>, <Объект traceback>)

    Значения, доступные через последние три параметра, полностью эквивалентны значения, возвращаемых функции exc_info() из модуля sys. Если исключение обработано, метод должен вернуть значение True, в противном случае - False. Если метод возвращает False, то исключение передается вышестоящему обработчику.

    Если при выполнении выражений, расположенных внутри тела инструкции with, исключение не возникло, то управление все равно передается методу __exit__(). В этом случае последние три параметра будут содержать значение None. 


Строки:
    Строки Unicode:
        s = u'SomeString'
        s = ru'SomeString' - необрабатываемая строка. Так же и с R

        Для перевода из одной кодировки в Unicode используется метод unicode(). Пример s = unicode("Привет", "KOI8-R").
        Метод encode() позволяет преобразовать строки в Unicode в обычные строки в указанной кодировке. Пример: s.encode("KOI8-R")

        len(s)

Кортежи:
    (1, 2, 3) или tuple("spam")

List:
    Списки - это изменяемые объекты.
        a = [1, 2, 3, 4] или list(...)
        a[0:2] = [5, 6] - замена, с нулевого до второго(исключительно). Даст [5, 6, 3, 4] - а можно и больше вставить, чем удаляем.
        a[0:2] = [] - удаление, с нулевого до второго. Даст [3, 4]
        a[1:1] = [6, 7] - вставка (вставит между нулевым и первым). Даст [3, 6, 7, 4]
        a[:1] = a - вставка, все что до 3го удалит и вставит содержимое a
        len(a)

        [3*x for x in vec if x > 3]
        [{x: x**2} for x in vec]
        [x*y for x in vec1 for y in vec2] #Если в конструкторе указано несколько блоков for, элементы второй последователь-ности перебираются для каждого элемента первой и т. д., то есть перебираются все комбинации.

Set
    set('abc') или {'a', 'b', 'c'}

Словари:
    {'a':1, 'b':2} или dict('a'=1)

Множественное присвоение.
    a, b = 1, 2

Распаковка:
    t = (1, 2, 3)
    a, b, c = t #Распаковка требует, чтоб слева стояло столько же элементов сколько в кортеже.


For:
    for i in a:
        ....

    range() - #В Python3 она полностью совпадает с поведением xrange.
    xrange() - #Удалена в Python3.

    else - выполняется, когда цикл (while/for) заканчивается в обычном/нормальном режиме. Если срабатывает break - то else не выполняется.

Функции:
    def - является исполняемым кодом. Пока интерпретатор не дошел до этого места, о функции еще не известно (это позволяет вкладывать функции в if итд).
        - сздает объект и присваивает его имени (имя функции это по сути ссылка на объект функции).

    Определение фунции, вводит имя этой функции в текущую таблицу имен. Значение имени функции имеет тип, распознаваемый интрпретатором как определенная пользователем функция, это значени может быть привоено другому имени.

    При вызове функции другой функцией, создается так же новая таблица имен.

    При рекурсивном вызове создается собственное локальное пространство имен для каждого вызова.


    Значения по умолчанию, вычисляются один раз, только в месте определения фунцкции.
        i = [1, 2, 3]
        def func2(arg = i):
            length = len(arg)
            arg[length:] = [4, 5]
            print "arg =====", arg

        func2()
        i = [100, 200, 300] #т.е. эта строка не оказывает влияния. Аналогично, даже если это было просто int. Но особую проблему несут именно если задан объект.
        func2() # [1, 2, 3, 4, 5, 4, 5]

    Именованные переменные:
        Именованные переменные всегда указываются после неименованных. Как при описани функции, так и при вызове функции.

        def func(param_1, param_2, preDef_1=4, preDef_2=5):
            ...

        func(1, 2, preDef_2=6)
        func(preDef_2=6, param=1) #В общем, в списке аргументов именованные аргументы должны следовать после по-зиционных. Не имеет значение, имеет НЕименованный аргумент значение по умолчанию или нет.


    Произвольное число аргументов:
            В position будет находится tuple - содержащий позиционные аргументы, что не входят в список формальных параметров.
            В maned будет находится словарь, содержащий все именованные переменные, что не входят в формальные параметры.    

                def func4(formal, *position, **maned):
                    print "formal =====", formal
                    for i in position:
                        print "position =====", i
                    for kw in maned.keys():
                        print kw, "=====", maned[kw]

                Пример:
                    def func3(param, *args):
                        for ii in args:
                            print ii

                    func3(1, 2, 3, 4) #В args будет 2, 3, 4


    Функции
        filter(), map(), zip() и reduce()

        map(func, list_1, list_2, ..., list_N) #func должна принимать столько аргументов, сколько коллекций передается в map.

Lambda:
    lambda - возвращает значение (новую функцию), которую дополнительно можно присвоить имени.
        def - всегда присваивает объект функции имени в своем заголовке вместо возвращения ее в виде результата.

    Тело lambda похоже на то, что было бы указано в операторе return внутри def. При этом явно возвращать не нужно что либо.

    def f(x, y, z): retrun x+y+z
    f = lambda x, y, z: x+y+z           # а можно даже указать дефолтное значение f = lambda x=1, y=2, z=3: x+y+z

    f(1, 2, 3)

    У lambda область видимости такая же как и у обычного def. Имеет свои локальные переменные и видит объемлющие.

Yield
        --- В первый запуск вашей функции, она будет исполняться от начала до того момента, когда она наткнётся на yield — тогда она вернёт первое значение из цикла. На каждый следующий вызов будет происходить ещё одна итерация написанного вами цикла, возвращаться будет следующее значение — и так пока значения не кончатся.
        --- Генератор считается пустым, как только при исполнении кода функции не встречается yield. Это может случиться из-за конца цикла, или же если не выполняется какое-то из условий «if/else».
        
        - Yield – ключевое слово, которое используется вместо return. С его помощью функция возвращает значение без уничтожения локальных переменных, кроме того, при каждом последующем вызове функция начинает своё выполнение с оператора yield.
        - Когда программа доходит до yield, то функция переходит в состояние ожидания и продолжает работу с того же места при повторном вызове.

    Yield
        Отправляет результирующий объект вызывающему коду, но запоминает место где он остановится. При этом происходит запоминание локальных переменных (локальной области видимости).

        Оператор yield выдает значение, а не возвращает его. Оператор yield приостанавилвает функцию и отправляет значание обратно вызывающему коду, но сохраняет достаточный объем состояние, чтобы предоставить функции возможность возобновить работу с места. кторое она покинула.

    - Итератор — это объект, позволяющий «обходить» элементы последовательностей.
            У Итератора есть метод __next__ который либо возвращает очередной элемент либо генерирует исключение StopInteration - для остановки итерации (протокол итерации).
            Итератор итерируемого объекта первноначально извлекается с помощью встроенной функции iter().
                D = {'a':1, ...., 'd':4}
                I = iter(D) # словарь стал итерррируемым.
                next(I)

    - Генератор это итерируемый объект, но прочитать можно один раз. Это связано с тем, что они не хранят значения в памяти, а генеруриет их на лету.
            Функция содержащая yield по сути возвращает объект, с ожидаемыми методами из протокола итерации.

        - При последующем вызове они возвращют объект генератор, который поддерживает интерфейс итерации с автоматически созданными методом по имени __next__, который предназначен для запуска или возобновления выполнения.
        - Генераторные функции могут также иметь оператор return, который нарряду с перемещение за конец блока def прсото прекращает генерацию значений - формально за счет иницирования исключения StopIteration.


        Тип полученного значения при вызове функции – это генератор. Один из способов получения значений из генератора – это их перебрать в цикле for.

    Итератор    
        mylist = [x*x for x in range(3)] - это по сути создание списка. #type(mylist) ---> <class 'list'>

        for i in mylist :
            print(i)

    Генератор
        mygenerator = (x*x for x in range(3)) - а это по аналогии с созданием списка - создание итератора (различие в круглых скобках) #type(mylist) ---> <class 'generator'>
        for i in mygenerator :
            print(i)

        #mygenerator - это по сути НЕ список как в случае с итератором а фактичеки объект, который возвращает новое значение генерируя каждый раз когда к нему будут обращаться. Т.е. при этом в памяти по сути ничего не будет храниться.

        а можно и так:
    --->print(next(out)) - но если вызвать больше чем в генераторе значений, то будет выбрашено исключение StopIteration
            next(f) - python3
            f.next() - python2

        list(mygenerator) - получим из генератора новый список.

        Всё то же самое, разве что используются круглые скобки вместо квадратных. НО: нельзя применить конструкцию for i in mygenerator второй раз, так как генератор может быть использован только единожды: он вычисляет 0, потом забывает про него и вычисляет 1, завершаяя вычислением 4 — одно за другим.

    Каждый объект имеет встроенный метод __next__, который и обеспечивает обход элементов в цикле. Функция next() просто вызывает __next__.


    Для сравления:
        class AP:
            def __init__(self, a1, d, size):
                self.ele = a1
                self.diff = d
                self.len = size
                self.count = 0

            def __iter__(self):
                return self

            def __next__(self): 
                if self.count >= self.len:
                    raise StopIteration             <<<<<< вот она генерация исключения.
                elif self.count == 0:
                    self.count += 1
                    return self.ele
                else:
                    self.count += 1
                    self.ele += self.diff
                    return self.ele

            for ele in AP(1, 2, 10):
                print(ele)

    И------------------------
        def AP(a1, d, size):
            count = 1
            while count <= size:
                yield a1
                a1 += d
                count += 1

        for ele in AP(1, 2, 10):
            print(ele)




Ввод/вывод:
    str() - переводит в строковое представление.
    repr() - тождественно ``

    str().rgust(3) / ljust() / center()
    print '%2d %3d %4d' % (x, x*x, x*x*x)

    f = open('/tnp/workfile', 'wb') # w - только для записи, r - только для чтения, a - для дописывания в конец, r+ для чтения и записи.


Stepik

        Операции
            Целочисленное деление // (усечение в меньшую сторону -5//2 = -3)
            Остаток от деления %
            Возведение в степень **

        Вечественные числа
            Записываются через точку.
            Вещественное деление через / (т.е. обычное деление)
            5e-1 = 0.5

Числа:
    Преобразования:
            int(3.14) => 3        
            float(3) => 3.0
            str(3.14) => 3.14
            3.14 + 4 => 7.14

    Округления
        import math
        math.floor(2.5) => 2 Ближайшее меньшее значение,
        math.floor(-2.5) => -3

        math.trunc(2.5) => 2 Усечение дробной части в строну нуля
        math.trunc(-2.5) => -2

        round(2.567, 2) => 2.57 #до двух знаков после запятой.

    Системы счисления
        oct(64), hex(64), bin(64) => ('0o100', '0x40', '0b1000000')
        int('64'), int('64', 8), int('64', 16)


Множества:
    По множествам МаркЛутц 2019 стр. 196






Декораторы:
    Декараторы применяются как к методам так и к классам.
    Декараторы являются прокси по отношению к классу или методу (и имя этого декаратора такое же как и декарируемый класс или метод - Так называемое ПОВТОРНОЕ ПРИВЯЗЫВАНИЕ).

    Повторное привязывание происходит на этапе определиния метода или класса.
        Вспоминая что def и class это по сути объявлние переменной, то можно говорить, что привязывание происходит в конце операторов def и class.

    Декаратор это сущеность времени выполнения.

    Декораторы функций:
    #--------------------------------------------------------------------------------------
        def my_shiny_new_decorator(function_to_decorate): # Внутри себя декоратор определяет функцию-"обёртку". Она будет обёрнута вокруг декорируемой, получая возможность исполнять произвольный код до и после неё.

            def the_wrapper_around_the_original_function():             #the_wrapper_around_the_original_function(arg1, arg2) или #stand_alone_function(*args)
                print("Я - код, который отработает до вызова функции")
                function_to_decorate() # Сама функция                   #function_to_decorate(arg1, arg2)
                print("А я - код, срабатывающий после")

            return the_wrapper_around_the_original_function # Вернём эту функцию
        

        def stand_alone_function():                                     #stand_alone_function(arg1, arg2)                
            print("Я простая одинокая функция, ты ведь не посмеешь меня изменять?")

        stand_alone_function()
        stand_alone_function_decorated = my_shiny_new_decorator(stand_alone_function)
        stand_alone_function_decorated()

        stand_alone_function = my_shiny_new_decorator(stand_alone_function)
        stand_alone_function()

        @my_shiny_new_decorator
        def another_stand_alone_function(): #По судит вызывается следующее: another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)
            print("Оставь меня в покое")

        another_stand_alone_function()
    #--------------------------------------------------------------------------------------
        class decorator:
            def __init__(self, func):       #func
                self.func = func

            def __call__(self, *args):      #self - экземпляр декоратора т.е. класса decorator. Но момент в том что *args не содержит экземпляр что нужен для func т.е. к какому экземпляру класса "С" будет вызов этой функции func. Т.е. это вызывает проблемы для функции из класса/экземпляра
                ...                         #__call__ вызывается перед вызовом любого метода экземпляра данного класса.
                self.func(*args)
                ...

        @decorator
        def func(x, y):         #func = decorator(func)
                                #func передается __init__ а когда происходит вызов внутренней функции класса, происходит вызов __call__ который собственно и является оберткой.
            ....

        func(6, 7)


        Но с методами экземпляров классов работать не будет. Допустим для:
        class C:                    #См. выше. Т.к. в __call__ не будет передан self класса С т.е. в *args не будет передан self (хз почему так, но так).
            @decorator
            def method(self, x, y):
                ...

    #--------------------------------------------------------------------------------------
        Для поддержика и функций и методов, нужно использовать вложенные функции

        def decorator(F):
            def wrapper(*args): #Для метод экземпляр класса находится в args[0]. В отличии от __call__ в *args будет передан и self.
                F(*args)
            return wrapper

        @decorator
        def func(x, y):
            ...

        class C:
            @decorator
            def method(self, x, y):
                ...

        func(6, 7)
        X = C()
        X.method(6, 7) #по сути будет вызов (X, 6, 7)
    #--------------------------------------------------------------------------------------
        def decorator(cls):
            class Wrapper:
                def __init__(self, *args):
                    self.wrapped = cls(*args):

                def __getattr__(self, name):                #метод вызывается, когда у экземпляра не найден такой атрибут. А так как у этого Wrapper нет такого атрибута, мы однозначно попадем в этот метод.
                    return getattr(self.wrapped, name)      #getattr(object, name) возвращает значение атрибута объекта object по его имени name.

            return Wrepper  #Возвращаем объект класса Wrapper (по сути в питоне это фабрика экземпляров для класса Wrapper). См. метаклассы.
                            #Т.к. это является объект, то по этой причине мы спокойно можем передавать эту ссылку и возвращать из метода эту ссылку.
                            #А тип у него будет type.

        @decorator
        class C:
            def __init__(self, x, y):
                self.attr = 'spam'      #Здесь пример дан для атрибута класса, а как с методами и перехватом вызовов метода?

        x = C(6, 7)
        print(x.attr)


Дескрипотры:
    Дескриптор это атрибут объекта со “связанным поведением”, то есть такой атрибут, при доступе к которому его поведение переопределяется методом протокола дескриптора. Эти методы  __get__, __set__ и __delete__. Если хотя бы один из этих методов определен в объекте , то можно сказать что этот метод дескриптор.

    Класс определяющий методы:
            __get__             # descr.__get__(self, obj, type=None) -> value
            __set__             # descr.__set__(self, obj, value) -> None                
            __delete__          # descr.__delete__(self, obj) -> None
        Может называться дескриптором.

            class NonNegative:
                def __init__(self, name):               # Python 3.6+ в место инит может использоваться __set_name__
                    self.name = name
                def __get__(self, instance, owner):
                    return instance.__dict__[self.name]
                def __set__(self, instance, value):
                    if value < 0:
                        raise ValueError('Cannot be negative.')
                    instance.__dict__[self.name] = value

            class Order:
                price = NonNegative('price')
                quantity = NonNegative('quantity')

                def __init__(self, name, price, quantity):
                    self._name = name
                    self.price = price
                    self.quantity = quantity

                def total(self):
                    return self.price * self.quantity

            apple_order = Order('apple', 1, 10)

        Python позволяет перехватить выше упомянутые попытки доступа к атрибуту и переопределить связанное с этим доступом поведение. Это реализуется через механизм протокола дескрипторов. 
    

Метаклассы:
    https://habr.com/ru/post/145835/

    Метакласс - это сущность, что создает классы.
        MyClass = MetaClass()
        MyObject = MyClass()
        
    А по сути это и есть type:

        MyClass = type('MyClass', (), {}) #Т.е. функция type является метаклассом.


    По сути когда пишем "class NameOfClass:" мы создаем объект, который будет создавать экземпляры класса.
        По этой причине NameOfClass можно присвоить новой переменной, копировать, можно передать функции в качестве аргумента, можно вернуть из функции.

    type(<имя класса>,
        <кортеж родительских классов>, # для наследования, может быть пустым
        <словарь, содержащий атрибуты и их значения>)

    def echo_info(self):
        ...
        print "Info"

    class Bar:
        ...
        pass

    class Foo(Bar):
        ...
        bar = True

    можно переписать как
    Foo = type('Foo', (Bar, ), {'bar':True, 'echo_info': echo_info})


    Еще одно есть одно поле 
        __metaclass__

        - При создании объекта-класса ищется данное поле, в самом классе, в классе родителя, если не найдено данное поле, то будет создан объект-класса без поля __metaclass__ - т.е. в стандартном режиме. Если же будет найдено в любом классе (текущем или родительсокм) то будет создан объект исходя из значения поля __metaclass__
        - Если данное поле указано в сомом модуле, то будет использоваться для всех классов данного модуля. Это поле в модуле задается в глобальной области (т.е. не в нутри чего либо).

    __new__


Многопоточка
Unicode
with ... as