# Задача решена с учётом порядка подачи материала (методов, массивов/коллекций еще не было). Решал так если бы не знал перечисленного.

# Реализация моя, но догадался не я в части 256. Хотя ведь знал. что *2 это смещение влево на 1ну позицию.
# Здесь вариант работы с битами/байтами вычесленного блока.
# b = h + r * 256 + m * 265^2 - здесь по аналогии с умножением на 2 это сдвиг влево на 1 позицию. 256=2^8 это по сути сдвиг влево на 8 позиций или на байт.
# Т.е. можно сделать вывод, что h - у которого ограничения [0, 255] - он без сдвига => соотносится с первым байтом
# r тоже имеет ограничение [0, 255] и тоже укладывается в байт, но при этом смещен влево на байт => соответственно, соотносится со вторым байтом.
# m - сдвинут влево на два байта, соответственно, всё что в старших байтах (старше 2х байт) - это m - и может занимать сколько угодно байт.


count_of_block = int(input())

h_1 = 0
count = 0

for i in range(0, count_of_block):
    count = i
    block = int(input())
    # print(bin(block))
    h = block & 0xFF
    # print(bin(h))
    tmp = block >> 8
    r = tmp & 0xFF
    # print(bin(r))
    m = tmp >> 8
    if i == 0:
        h_i = (37 * (m + r)) % 256
    else:
        h_i = (37 * (m + r + h_1)) % 256
    b_i = camputed_b_n = h_i + r * 256 + m * 256**2
    # print(f"block = {block}    h = {h}      r = {r}     m = {m}")
    # print(f"b_i = {b_i}    h_i = {h_i}")
    if h_i < 100 and h_i == h and b_i == block:
        h_1 = h_i
        continue
    else:
        break
else:
    count = -1

print(count)

"""
Хайпанём немножечко!
Блокчейн (blockchain) переводится как «цепочка блоков». Это способ хранения данных, защищённый от подделки. Он лежит, например, в основе криптовалюты биткоин.

Блокчейн — это действительно последовательность блоков, а в каждом блоке находится некоторая полезная информация. Так последовательность биткоина — список транзакций за определённый период времени: кто, кому, когда и сколько денег передал. Этот список снабжён случайным числом и некоторыми служебными данными, в том числе хэшем — числом, которое по определённой формуле зависит от остальной части блока и хэша предыдущего блока.

Хэш должен быть меньше определённого числа. При этом формула, по которой вычисляется хэш, устроена так, что невозможно получить достаточно маленький хэш иначе, чем перебирая различные значения случайного числа. Поэтому если злоумышленник решит подделать блокчейн — например, вставить в его середину блок с записью о том, что все люди передали ему все свои деньги, — то столкнётся с проблемой. Ему придётся подобрать новое случайное число не только в поддельном блоке, но и во всех последующих, ведь хэш каждого следующего блока зависит от хэша предыдущего.

Это требует невероятно больших вычислительных мощностей, поэтому блокчейн в целом защищён от подобных атак.

Напишите программу, которая проводит проверку правильности хэшей в модельном блокчейне с простой хэш-функцией. Блок 

bn с номером n включает полезную информацию mn , представленную натуральным числом, rn — случайное число от 0 до 255 и hn — хэш (целое число от 0 до 255). У каждого блока хэш вычисляется по формуле hn =37×(mn + rn +hn−1) (по модулю 256), при вычислении хэша начального блока
h0 вместо хэша предыдущего блока берётся ноль. При этом каждый блок представлен одним числом bn = hn + rn × 256 + mn × 256^2. Также требуется, чтобы хэш hn был меньше 100.

Формат ввода
На первой строке вводится натуральное число N — количество блоков. Далее следуют N чисел bn, каждое на отдельной строке.

Формат вывода
Следует вывести номер первого блока, у которого неправильный хэш (не меньше 100 или не совпадает с вычисленным по указанной в условии формуле), или -1, если все хэши в блокчейне правильные. Нумерация блоков идёт с нуля, так что они имеют номера от 0 до N-1.

Пример 1
    Ввод
        5
        6122802
        14406496
        15230209
        2541121
        1758741
    Вывод
        -1

Пример 2
    Ввод
        5
        1865535
        13479687
        16689153
        1839958
        5214020
    Вывод
        3
"""
