Исходники для Lutz - https://resources.oreilly.com/examples/0636920028154

Python:
Параметры запуска:
    sys.argv - агрументы запуска командной строки.

СПРАВКА:
    s = 'a'
    dir(s) - выведет перечень имен атрибутов, свойственных объекту (при этом в отличии от __dict__ выведет и унаследованные атрибуты)

    help(s.replace) - выведет подробную справку по методу. help - это по сути PyDoc

    class someName:
    """Here should should be placed the PyDoc of class"""

        #....Other parts of class

    is - проверяет ссылаются ли ссылки на один объект. Работают по id(instance)
    == - равны ли они см. __eq__(self, other)

-------
АТРИБУТЫ:
        nameModule.name где namе - атрибут модуля, nameModule - объект модуля.
                Имена в модулях, яляются атрибутами модуля и образуют одно пространство имен - глобальное пространство.
                    - Т.е. когда загружается в интерпретатор данный модуль, создается объект модуля.
                    - Объект модуля создается один на запуск программы.
        Под атрибутами понимают, все что идет после точки. Т.о. атрибуты модуля и глобальные имена имеют прямое соответствие, они совместно использую одно пространство имен.
        
        В отличии от классов, объект модуля может существовать в одном единственном экземпляре, по этой причине, необходимо использовать reload(modName) для обновления объекта модуля, что бы отобразить внесенные в модуль изменения.

        import sys
        sys.path.append("path") # добавляет путь для поиска модулей
        sys.path                # определяет место, где искать импортируемые модули.

-------
ПРОСТРАНСТВО ИМЁН:

    Различают три пространства имен(области видимости).
        Встроенное      -     это то что относится к python (исключения итд) и формируется при запуске интерпретатора, и существют на протяжении всего времени выполнения.
        Глобальное      -     это пространство имен модуля совпадающее с пространством атрибутов. Создается при считывании модуля, обычно существует до завершения работы интерперетатора.
        Локальное       -     пространство функции или класса. Для метода пространство создается при вызове метода и удаляется при выходе.
                            Все что вне функции или класса относится к глобальной области.  

        Пространство имен определяет отображение имен в объекты.
        Область видимости - фрамгент программы, в котором пространство имен непосредсвтвенно доступно, т.е. нет необходимости использовать точку.
            
    Динамический поиск имен:
        1. В локальной области
        2. В голобальной области (если это внутри метода, что внутри класса то: область класса → область модуля)
        3. Во внешней области - область встроенных имен.

            - Поиск переменных производится:
                -- В локальной таблице имен, затем в глобальной, в последнюю очередь в таблиц встроенных имен.

    Есть правило "LEGB" - для функций, можно почитать у того же Лутца. Области видимости разделены на уровне функций, классов, модулей.
        - Присвоение имён по умолчанию создают либо изменяют локальные имена;
        - ссылки на имена прозводятся поиск в 4х областях видимости: локальной(L-Local), объемлющие функции (E-Enclosign class/def/lambda), глобальная  область видимости(G-Global) и наконец во встроенной видимости(B-Build-in) - и останавится где первый раз встретится целевое имя.
        - имена, объявленные в операторах global и nonlocal, отражают присвоенные имена на области видимости включащего модуля или функцию соответственно.

        Scope is delineated by function and class blocks. Both functions and their scopes can be nested.

    Инструкции выполняемые на верхнем уровне, т.е. читаемые из файла или интерактивно, рассматриваются как часть модуля __main__, имеющего собственное глобальное пространство имен.
        Встроенные имена также находятся в модуле __builtin__

    global - делает обявляемый атрибут(имя) глобальным.
        - Дефолтно если мы определяем в методе или классе имя оно является локальным, а с данным параметром мы делаем его глобальным (т.е. принадлежащим модулю)
            - Таким образом сможем глобальной переменной присвоить значение (в ином случае будет создана в функции новая локальная переменная с таким же именем).
            - Т.е. при получении значения - берётся внешнаяя переменная (если не объявлена с аналогичным имененем локальная переменная), а при присваивании внутри функции будет создана новая переменная с таким же именем что и внешняя переменная. Для того, чтоб задать присвоить значение именно 
    del - удаляет имя из локального пространства имен. (Удаляет имя а не объект к которому привязано имя)
    nonlocal - делает переменную доступной на уровень выше. Т.е. во вложенной функции, мы делаем переменную доступной в объемлющей функции итд.
        А если в методе верхнего уровня седлать так, то переменная станет глобальной?
            Нет, будет ошибка, т.е. не может привязать такую перменную. Видимо из за того, что верхней функции нет. И не к чему привязывать. При оборачивании внешней функцией - все Ок.

            def myfunc1():
                  x = "John"
                  def myfunc2():
                    nonlocal x  # Аналогично помечается и global
                    x = "hello" # Меняем переменную функции myfunc1, а не myfunc2
                  myfunc2()
                  return x

            print(myfunc1())

    def, class, import, lambda - (функции, модули и классы) представляют собой объекты.
!!!     Т.е. это инструкции/операторы, которые создают/возвращают объекты.

    - Модули содержат операторы.
    - Операторы содержат выражения.

    - Выполнение функции - вводит новую таблицу имен, используемую для локальных переменных. Все присвоения переменным в теле функции сохраняются в локальной таблице имен.
    - Аналогично и для класса - класс создает новую таблицу/пространство имён.


        Время жизни пространства имён:
            - Встроенное пространство - создается при старте интерпретатора и удаляется при завершении работы интерпретатора.
                __builtin__ - встроенные имена находятся в этом модуле.
            - Глобальное пространство имён модуля создается, когда он считывается, и, обычно, также существует до завершения работы интерпретатора.
                __main__ - инструкции читаемые из файла сценария находятся в этом модуле.
            - Локальное пространство имён функции - создается при вызове функции и удаляется при выходе из неё.
                При рекурсии создается собственное пространство имён для каждого вызова.

            Область видимости - фрагмент программы, в котором пространство имён непосредственно доступно и нет необходимости прибегать к точке.

            Поиск происходит снизу вверх, от локального к глобальному и далее к встроенному.

            Присваение всегда происходит в локальной области видимости, если не было целенаправленно вызвано через инструкцию global.
            del x - удаляет имя х из пространства имён, соответствующий локальной области видимости.


====================================================================================================
МОДУЛИ: 
    list(moduleName.__diсt__.keys())) - переменные модуля хранятся в виде словаря в переменной __dict__
    В пределах модуля его имя доступно в глобальной переменной __name__.

    Модуль может содержать любые инструкции, предназначенные для инициализации, а не только определения функций. Они выполняются, только когда модуль импоритуется первый раз.

        Импортирование:
            Выполняются следующие шаги:
            1. Поиск файл-модуля
            2. Компиляция
            3. Выполнение кода модуля (модуля, который импортируется), для создания объектов, что в нем определени.
                т.е. операции верхнего уровня не вложенные в class и def будут выполнены. Допустим невложенный в def --- print() выведет на консоль при имопртировании.
            4. Любой модуль импортируется один раз на процесс. Все остальные импорты ранее импортированного модуля пропускают 1-3 шаги и используют уже загруженный в память модуль.
                Для обновления содержимого уже импортированного модуля используется imp.reload

            При повторном импортировании, эти три шага пропускаются.
!               Уже импоритованные модули находятся в таблице sys.modules

        Каждый модуль имеет собственное пространство имен, являющееся глобальной областью видимости для всех определенных в нем функций.
            Модуль существует в единичном экземпляре (в отличии от классов и их экземпляров), по этому для модуля при изменени требуется reload(moduleName). #Или aliace если импорт через as.

        Поиск модулей:
            1. Ищется в текущем каталоге (каталог запускаемого модуля)
            2. Потом в PYTHONPATH (т.е. то что хранится sys.path)
            3. Каталог стандартной библиотеки.
            4. Содержимое любых файлов .pth
            5. Подкаталог site-packages, где размещаются сторонни расширения.

            Объединение пяти пунктов образует sys.path.
            Будет выбран первый найденный файл совпадающий с именем модуля.

        Операция импортирования происходит однократно.
            Операторы import и from по аналогии с def являются исполняемыми. Они могут быть вложены в if
                import - присваивает имени - объект целевого модуля.
                from - присваивает одному или несколькоим именам - объекты с таким же именами из др. модуля (по сути происхоидт КОПИРОВАНИЕ в одноименные переменные).
                    - Имена КОПИРУЮТСЯ с помощью from становятся ссылками на разделяемые объекты (как к примеру a=list() и b=a и изменения в b будут влиять на a - так как это ссылки на один объект)
                    - Но вот для обычных переменных (для примера: x=1) все это по другому.
                        -- Через from мы скопировали переменную, и при изменении в этом модуле, изменения в исходном модуле влиять не будут.
                        -- Для этого нужно с помощью import получить имя модуля и выполнить изменение в исходном модуле.

                        Пусть текущий модуль moduleB. 
                            А moduleA содержит две переменные x=1 и y=[1, 2, 3]

                            from moduleA import x, y
                            x=42    # Предположим, что мы находимся в moduleB и следовательно эти изменения в будут только в модуле moduleB и не повлияют на moduleA. 
                                    # Это касается простой переменнной и ссылки. Здесь важно, что такая форма записи создаёт новую переменную. Для ссылочной аналогичная ситуация - объявляется новая перменная.
                            y[-1:] = [5, 6] - а так не объявление переменной, а работа сосылкой.

                            import moduleA
                            moduleA.x=42 #А вот в этом случае, изменяя х мы изменим х в moduleA (так как в этом случае не проиходит копирование, а происходит работа с переменной moduleA)

        Перезагрузка модулей:
            Перезагрзука модулей выполняется через reload(module).
                При этом содержимое модуля будет выполнено повторно.

            reload - является функцией а не оператором, по этому требует скобки, а в скобках указание наименования уже импортированного модуля.
                В Python3 reload переехал в модуль imp а с 3.4 в importlib
                    import scrtpt_name
                    import imp #Старше 3.4 следует использовать importlib
                    imp.reload(scritp_name)

            В отдельно взятую программу импортируется только одна копия каждого модуля.
                reload - обновляет разделяемый объект единственного экземпляра на месте. При этом при reload заново выполняются все инстркции и обновлюятся значения переменных модуля.

====================================================================================================
ПАКЕТЫ:
        Структура каталогов проекта Python:
            Project/
            |-- bin/
            |   |-- project
            |
            |-- project/
            |   |-- test/
            |   |   |-- __init__.py
            |   |   |-- test_main.py
            |   |   
            |   |-- __init__.py
            |   |-- main.py
            |
            |-- setup.py
            |-- README

    Импортирование:
        import sys
        sys.path.insert(0, 'startPath/Project') # Или перменная export PYTHONPATH=’startPath/Project’ # Или sys.path.append()

        import dir1.dir2.mod        # Указывается относительно того, что задано в sys.path. Т.к. в проекте sys.path указан корень проекта, то и путь указывается относительно корня проекта.
        form dir1.dir2.mod import x # Можно еще делать относительный импорт, через . или ..

        import dir1.dir2.mod as modd
        form dir1.dir2.mod import x as xxx

            # В Python3 в этих каталогах должны быть __init__.py

        -----
        from package import item    # item может быть модулем, подпакетом, функцией, классом или переменной. Интерпретатор, проверят определено ли имя item в пакете. Если нет, считает его модулем и пытается загрузить.
        # from Sound.Effects.echo import echofilter - импортируется конкретная функция.

        import item.subitem.subsubitem #каждая единица, кроме последней, должна быть пакетом. Последняя единица может быть модулем или пакетом, но не может быть классом, функцией или переменной, определенной в предыдущей единице.

        ---------------
        # importing the importlib.util module
        import importlib.util        
         
        # passing the file name and path as argument
        spec = importlib.util.spec_from_file_location("mod", "D:/projects/base/app/modules/mod.py")    
         
        # importing the module as foo 
        foo = importlib.util.module_from_spec(spec)        
        spec.loader.exec_module(foo)
         
        # calling the hello function of mod.py
        foo.hello()

====================================================================================================
ФУНКЦИИ:
    def - является исполняемым кодом. Пока интерпретатор не дошел до этого места, о функции еще не известно (т.к. это оператор, его можно вложить в if.).
            - в отличии от компилируемых ЯП, в Python функция не оценивается, пока исполнение не дошло до этой функции.
        - сздает объект и присваивает его имени (имя функции это по сути ссылка на объект функции).


    Определение фунции, вводит имя этой функции в текущую таблицу имен. Значение имени функции имеет тип, распознаваемый интрпретатором как определенная пользователем функция, это значени может быть привоено другому имени.

    Выполнение функции вводит новую таблицу имен, используемую для локальных переменных.
        При ссылке на переменную, её поиск производится сначала в локальной таблице имент, затем в глобальной и, в последнюю очередь, в таблице встроенных имен.
        Глобальным переменным нельзя прямо присвоить значение в теле функции (без global), хотя без global можно ссылаться.
    При вызове функции другой функцией, создается так же новая таблица имен.

    При рекурсивном вызове создается собственное локальное пространство имен для каждого вызова.

        # *arguments - возвращает кортеж переменных, что не входит в список формальных переменных. Сбор перечисленных аргументов.
        # **keywords - словарь, содержащий все именованные аргументы, чьи имена не соответствуют формальным параметрам.

        Ordering Arguments:
            1. Formal positional arguments
            2. *args
            3. Keyword arguments
            4. **kwargs

            def aMethod(a, b, *args, c=5, d=6, **kargs):
                print(a, b, args, c, d, kargs)

            aMethod(7, 8, 9, 10, c=11, d=12, e=13, f=14) #OUT:> 7 8 (9, 10) 11 12 {'e': 13, 'f': 14}

    def example(formal, *arguments, **keywords):
        for arg in arguments: print arg       
        for kw in keywords.keys():
            print kw, ’:’, keywords[kw]


    Значения по умолчанию(аргументы), вычисляются один раз, только в месте определения фунцкции.
        i = [1, 2, 3]
        def func2(arg = i): # Обратите внимание: значение по умолчанию задаётся один раз при объявлении функции. При последующих вызовах оно не меняется.
            length = len(arg)
            arg[length:] = [4, 5]
            print "arg =====", arg

        func2()
        i = [100, 200, 300] #т.е. эта строка не оказывает влияния. Аналогично, даже если это было просто int. Но особую проблему несут именно если задан объект.
        func2() # [1, 2, 3, 4, 5, 4, 5]

        # Эту реализацию
        def add_value(x, list_arg=[]):
            list_arg += [x]
            return list_arg

        # Заменить на
        def add_value(x, list_arg=None):
            if list_arg is None:
                list_arg = []
            list_arg += [x]
            return list_arg

    Именованные переменные:
        Именованные переменные всегда указываются после неименованных. Как при описани функции, так и при вызове функции.

        def func(param_1, param_2, preDef_1=4, preDef_2=5):
            ...

        func(1, 2, preDef_2=6)
        func(preDef_2=6, param=1) # В общем, в списке аргументов именованные аргументы должны следовать после по-зиционных. Не имеет значение, имеет НЕименованный аргумент значение по умолчанию или нет.


    Произвольное число аргументов:
            В position будет находится tuple - содержащий позиционные аргументы, что не входят в список формальных параметров.
                * - позволяет собрать в tuple, а если еще раз применить * то разобрать из tuple
            В maned будет находится словарь, содержащий все именованные переменные, что не входят в формальные параметры.

            def func4(formal:str, *position:int, **maned):
                print("formal ===== ", formal)
                print(*position)
                for i in position:
                    print("position =====", i)
                for kw in maned.keys():
                    print(kw, "=====", maned[kw])
                    
            func4("first", 1, 2, 3, 4, k='a', b='cc')
            Выдаст:
                # formal =====  first
                # 1 2 3 4
                # position ===== 1
                # position ===== 2
                # position ===== 3
                # position ===== 4
                # k ===== a
                # b ===== cc


    Именованные параметры:
        def welcome(first_name:str, last_name:str):
            print('Welcome, ' + first_name + ' ' + last_name + '!')

        welcome(last_name='Chekhov', first_name='Anton')


    Функции
        filter(), map(), zip() и reduce()

        map(func, list_1, list_2, ..., list_N) # func должна принимать столько аргументов, сколько коллекций передается в map.

        В Python3:
            - map() returns a map object (an iterator), which we can use in other parts of our program. We can also pass the map object to the list() function, or another sequence type, to create an iterable.
                - возвращает объект, который генерирует значение по запросу (итератор).
                    - Чтоб собрать нужно воспользоваться list(...)  передав туда результат функции map(...)
                - Итерируемым объектом считается, если он физически является хранящей последовательностью, или объектом, который производит по одному результату за раз в контексте итерационного инструмента, подобного циклу for (т.е. вычисление по требованию). Тотже yield.
            - map() can also take multiple iterables as arguments to the function by sending one item from each iterable to the function at a time.

    Локльные переменные:
        def list_modify():
            param = sample_0 # А здесь мы получим значение из глобальной переменной (т.е. при получении мы обращаемся к внешней переменной, а при присвоении мы создаём новую локальную переменную).
            sample_1 = [4, 5, 6] # Здесь будет создана новая локальная переменная а не присвоено значение глобальной перменной. Для привоения нужно прибегнуть к оператору global.

        sample_0 = [1, 2, 3]
        sample_1 = [1, 2, 3]
        list_modify()
        print(sample_1) # Вывод будет [1, 2, 3]

Lambda:
    lambda - возвращает значение (новую функцию), которую дополнительно можно присвоить имени.
        def - всегда присваивает объект функции имени(переменной) в своем заголовке, вместо возвращения ее в виде результата.
    lambda - представляет собой выражение, а не оператор. Является одиночным выражением, а не блоком операторов.

    Тело lambda похоже на то, что было бы указано в операторе return внутри def. При этом явно возвращать не нужно что либо.
        Из за однострочности, не удастся оформить что то сложнжое внутри lambda.

    def f(x, y, z): retrun x+y+z
    f = lambda x, y, z: x+y+z           # а можно даже указать дефолтное значение f = lambda x=1, y=2, z=3: x+y+z
                                        # аналогичным образом задается значение, что принимается внешней функцией, и нужно передать в lambda в качестве параметра.
    f(1, 2, 3)

    У lambda область видимости такая же как и у обычного def. Имеет свои локальные переменные и видит объемлющие.

    def make_incrementor(n):
        return lambda x, incr=n: x+incr # Т.к. лямбда не имеет доступа к аргументам объемлющей функции. You can "capture" the n when creating the lambda

    # LEGB
    def outer():
        y = 1
        action = (lambda x : x + y) # А можно по аналогии с обычной функцией задать и значения по умолчанию. action = (lambda x=2 : x + y)
        return action

    innerFunc = outer()
    print(innerFunc(2))

    (lambda x, y, z: x + y + z)(3, 8, 1)

    -------
    А можно даже сделать так
    listt = [lambda x: x*x, lambda x: x+x, lambda x: x/x]
    for f in listt:
        print(f(2))



Yield
        --- В первый запуск вашей функции, она будет исполняться от начала до того момента, когда она наткнётся на yield — тогда она вернёт первое значение из цикла. На каждый следующий вызов будет происходить ещё одна итерация написанного вами цикла, возвращаться будет следующее значение — и так пока значения не кончатся.
        --- Генератор считается пустым, как только при исполнении кода функции не встречается yield. Это может случиться из-за конца цикла, или же если не выполняется какое-то из условий «if/else».
        
        - Yield – ключевое слово, которое используется вместо return. С его помощью функция возвращает значение без уничтожения локальных переменных, кроме того, при каждом последующем вызове функция начинает своё выполнение с оператора yield.
        - Когда программа доходит до yield, то функция переходит в состояние ожидания и продолжает работу с того же места при повторном вызове.

        Yield - при вызове функции код в теле функции не исполняется. Функция просто возвращает объект-генератор. Код вызывается каждый раз, когда for обращается к генератору. При первом запуске функции она будет исполняется, пока не дойдёт до yield, после чего вернёт первое значение из цикла. При каждом последующем вызове будет происходить следующая интерация и возрвщаение заначения цикла. Так продолжается пока генератор не будет пустым (т.е. если не встречается yield или не будет условия if-else)

    Yield
        Отправляет результирующий объект вызывающему коду, но запоминает место где он остановится. При этом происходит запоминание локальных переменных (локальной области видимости).

        Оператор yield выдает значение, а не возвращает его. Оператор yield приостанавилвает функцию и отправляет значание обратно вызывающему коду, но сохраняет достаточный объем состояние, чтобы предоставить функции возможность возобновить работу с места. кторое она покинула.

    - Итератор — это объект, позволяющий «обходить» элементы последовательностей.
            У Итератора есть метод __next__ который либо возвращает очередной элемент либо генерирует исключение StopInteration - для остановки итерации (протокол итерации).
            Итератор итерируемого объекта первноначально извлекается с помощью встроенной функции iter().
                D = {'a':1, ...., 'd':4}
                I = iter(D) # словарь стал итерррируемым.
                next(I)

    - Генератор это итерируемый объект, но прочитать можно один раз. Это связано с тем, что они не хранят значения в памяти, а генеруриет их на лету.
!!!       Функция содержащая yield по сути возвращает объект, с ожидаемыми методами из протокола итерации.
            Т.е. если получить у тип после её вызова, то мы получим <class 'generator'>. При этом генератор - сам является итератером.
                def numbers_range(n):
                    print("In function")
                    for i in range(n):
                        print("In For")
                        yield i
                a = numbers_range(4)
                print(type(a))              # !!!!! <class 'generator'>. Соответственно этот объект имеет __next__. next(х) вызывает х.__next__() в Py3
                print(type(numbers_range))  # <class 'function'>
                for b in a:
                    print(b)

        - При последующем вызове они возвращют объект генератор, который поддерживает интерфейс итерации с автоматически созданными методом по имени __next__, который предназначен для запуска или возобновления выполнения.
        - Генераторные функции могут также иметь оператор return, который нарряду с перемещение за конец блока def прсото прекращает генерацию значений - формально за счет иницирования исключения StopIteration.


        Тип полученного значения при вызове функции – это генератор. Один из способов получения значений из генератора – это их перебрать в цикле for.

    Итератор    
        mylist = [x*x for x in range(3)] - это по сути создание списка. #type(mylist) ---> <class 'list'>

        for i in mylist :
            print(i)

    Генератор
        mygenerator = (x*x for x in range(3)) - а это по аналогии с созданием списка - создание генератора (различие в круглых скобках) #type(mylist) ---> <class 'generator'>
        for i in mygenerator :
            print(i)

        G = (c*4 for c in 'SPAM')
        iter(G) is G   # True # Итератером генератора является сам генератор. G имеет метод __next__

        #mygenerator - это по сути НЕ список как в случае с итератором а фактичеки объект, который возвращает новое значение генерируя каждый раз когда к нему будут обращаться. Т.е. при этом в памяти по сути ничего не будет храниться.

        а можно и так:
    --->print(next(out)) - но если вызвать больше чем в генераторе значений, то будет выбрашено исключение StopIteration
            next(f) - python3
            f.next() - python2

        list(mygenerator) - получим из генератора новый список. list(...) позволяет выпустить генератор все элементы сразу.
                - Генератор создавался для того, чтоб не хранить в памяти всё всё, а выпускать элементы по мере затребования.

        Всё то же самое, разве что используются круглые скобки вместо квадратных. 
            НО: нельзя применить конструкцию for i in mygenerator второй раз, так как генератор может быть использован только единожды: он вычисляет 0, потом забывает про него и вычисляет 1, завершаяя вычислением 4 — одно за другим.
                Генераторные функции и генераторные выражения сами представляют собой птератиры и потому поддерживают только одну активную итерацию.

    Каждый объект имеет встроенный метод __next__, который и обеспечивает обход элементов в цикле. Функция next() просто вызывает __next__.


    Для сравнения:
        class AP:
            def __init__(self, a1, d, size):
                self.ele = a1
                self.diff = d
                self.len = size
                self.count = 0

            def __iter__(self):
                return self

            def __next__(self): 
                if self.count >= self.len:
                    raise StopIteration             <<<<<< вот она генерация исключения.
                elif self.count == 0:
                    self.count += 1
                    return self.ele
                else:
                    self.count += 1
                    self.ele += self.diff
                    return self.ele

        for ele in AP(1, 2, 10):
            print(ele)

    И ------------------------
        def AP(a1, d, size):
            count = 1
            while count <= size:
                yield a1
                a1 += d
                count += 1

        for ele in AP(1, 2, 10):
            print(ele)

====================================================================================================
КЛАССЫ:
    Термины
        Класс = объект класс
        Экземпляр = Объект экземпляр

    - Оператор class создаёт объект класса и присваивает его имени. Точно так же как и def. Выполняется при первом импортировании файлов/модуля, где они находятся (но не ранее).
    - Каждый оператор class генерирует новый класс-объект (создается экземпляр от type или его наследников)
        -- Когда выполняется оператор class - Python запускает все операторы в теле класса от начала до конца.
            --- И присвание имён на этом этапе создаёт пространство имён класса (атрибуты-данных и атрибуты-методы)
                ---- Все что не вложено в def внутри класса, создаёт атрибуты класса (атрибуты класс-объекта)
                    ---- Атрибуты класса-объекта разделяются между всеми экземплярами создаваемыми из класса.
                ---- Оператор def определяет методы, которые обрабатывают экземпляры.
            --- В класс могут быть вложены любые операторы: if, print итд
            --- В самом конце вызывается метатайп (на данном этапе происходит создание объекта класса)
                ---- Под метатайп следует понимать наследников от type. Мета-тайп это то что создаёт объект класса. Метатайп - наследуется от type. А нужен метатайп для настройки создания класса.
    - При каждом обращении к классу (как к функции) он генерирует новый объект-экземпляра (экземпляр)
        -- Каждый объект экземпляр создаёт своё пространство имён. Атрибуты наследуются из класса.
    - Экземпляры автоматически связываются с классами, из которых они были созданы
    - Классы автоматически связываются со своими суперклассами, в соответствии со способом их перечисления внути круглых скобок в строке заголовка class;
        - Порядок слева направо здесь даёт порядок в дереве.
    - Объекты-экземпляры начинают своё существование пустыми, И наследуют атрибуты, имеющиеся в объектах-классах, из которых они были сгенерированны.
    - В python не возможна перегрузка методов.
        - Т.к. def только присваивает объект-функции имени, что указано после def. Следовательно последнее присваивание и будет являеться реализацией.
    - Имя атрибутов экземпляров перекрывают имена методов классов. По этому для избежания конфликтов нужно именовать по разному, или прийти к соглашению о приставках/суффиксах.
    - В python3 классы наследуются от object при этом object явно указывать не нужно. А вот в python2 нужно явно указать object.
    - Классы наследуют атрибуты от сових суперклассов.
    - Каждый экземпляр получает имена от класса, из которого он сгенерирован, а также от всех суперклассов этого калсса.
        - При поиске проверяется экзепляр, затем класс, и накоенц все суперклассы.
            - Сюда входят ссылки сделалные за пределами операторов class. (Допустим ClassName.attribute = ... или instance.attribute = ...)


    # Псевдокод конструирования объекта:
    def make(the_class, some_arg):
        new_object = the_class.__new__(some_arg) # Класс не передаётся явным образом, т.к. передаётся автоматом.
        if isinstance(new_object, the_class):
            the_class.__init__(new_object, some_arg)
        return new_object

        # следующие предложения приблизительно эквивалентны
        x = Foo('bar')
        x = make(Foo, 'bar')


    Вот пример для класса:
        class A():
            def __new__(cls, *param, **param1):
                print("That is the __new__ = " + str(cls))
                return object.__new__(cls)
                # return super().__new__(*param)
            
            def __init__(self, param):
                self.param = param
            
            def printt(self):
                print(self.param)
                
        # Такое создание:
        a = A("Pr") # Выдаст "That is the __new__ = <class '__main__.A'>"
                
        # Эквивалентно такому, но в ручном режиме.
        instanceA = A.__new__(A, "Pr")
        if isinstance (instanceA, A):
            A.__init__(instanceA, "Pr") # Эквивалентно instanceA.__init__("Pr") 
        instanceA.printt()



    Порядок инициализации и вызова инициализирующих методов:
        __init__ и __new__
        Сначала вызывается __new__, потом __init__
        __new__ создаёт и ВОЗВРАЩАЕТ новый объект экземпляра, который передаётся в __init__ в виде self для инициализации.
            - У __new__ имеется встроенная реализация и переопределяется очень редко.
            - Является методом класса, хотя к нему @classmethod не применяется.
            - Первым параметром передаётся объект класса для которого создаётся инстенс. При этом *args, **kwargs переданные в __new__ те же самые, что и передаются в __init__
            - __new__ - в object реализован на C и именно он создаёт объект. По этому если мы у себя реализуем __new__ мы должны вызвать object.__new__(...)
        __init__ ничего не возвращает, это инициализатор. А конструктором его назвали для совместимости с др. языками.

        ------------
        NB!!! Не стоит путать __new__  обычных классво с __new__ у метаклассов. Они отличются по сигнатуре. Да и __call__ отличается по сигнатуре. Но лучше __call__ у метаклассов не переопределять (всё сложно).
        
        class SomeUser:
            def __new__(cls, *args, **kwargs):          # Не стоит забывать, что cls - это объект-класс. Он уже создан к моменту создания инстенса.
                print("вызов __new__ для " + str(cls))
                instance = super().__new__(cls)         # В этом случае можно сделать object.__new__(cls) ведь поумолчанию класс наследуется от object. А у object.__new__ реализованно в недрях на C.
                return instances                        # Т.е. в нашем случае это будет object.__new__(SomeUser), и объект построенны object - является экземпляром SomeUser. Атрибут __class__ нового экземпляра содержит ссылку на SomeUser.

            def __init__(self, ...):
                # some action

            Т.о. при создании экземпляра вызывается __new__ который и создаёт и возвращает экземпляр (self), а потом передаёт в __init__ и на этом этапе происходит уже наполнение объекта/экземпляра.
                При этом, следует обратить внимание, что у __new__ - self отсутствует. Т.е. что свидетельствует о том, что на этом этапе объект-экземпляр еще не создан.
                    Т.е. __new__ похоже на @classmethod - здесь аналогия лишь по аргументу cls.


    По мнению многих авторов, __new__ - практически не переопределяется (Что Бизли что Лутц) говорят об одном.
        При этом можно увидеть переопределение это в двух случаях:
            - Когда расширяем, насдледуемся от неизменяемых (встроенных) классов.
                    # Пример взят из Бизли:
                    class Upperstr(str): # Расширяем, наследуемся от встроенного неизменяемого класса.
                        def __new__(cls, value=''):
                            return str.__new__(cls, value.upper())  # Вот для этого места можно переопределить.
                                                                    # А где вызов __init__ у родителя??? Получается что не нужно, когда вызоваем __new__ ?
                        
                    u = Upperstr('hello') # Вернёт значение "HELLO"

            - При объявлении метаклассов.

    Получение ссылок на класс(объект-класса):
        x.__class__ is type(x)  # True. т.е. ссылки на один объект. is проверяет ссылки. __class__ возвращает ссылку на объект-класса.
        x.__class__ is str      # Или можно указать тот же str (или int или иной тип) т.к. имя класса хранит ссылку на объект-класса. Т.е. имени классу присванивается объект-класса.

            type(object) # Вернёт <class 'type'> - т.е. object - тоже создан от type

            - Как я понял функция type(object) возвращает класс/тип любого объекта (который тоже является объектом - ведь класс это объект).
                - Т.е. type(SomeClass) и type(SomeClass(...)) вернёт разные классы/типы(в Py3 понятия тип и класс совпадают). В первом случае будет <class 'type'>(метакласс) а во втором <class '__main__.SomeClass'> - здесь тип инстенса/объекта.
            - И object.__class__ возвращает класс/тип.
                - В Python3 и type и __class__ возвращают классы/типы, из которых создан экземпляр, а не обобщённый тип экземпляра.
                    - Классы, являются экземплярами класса type.


            print(type(MyClass))        <class 'type'>
            print(type(MyClass()))      <class '__main__.MyClass'>

            print(MyClass.__class__)    <class 'type'>
            print(MyClass().__class__)  <class '__main__.MyClass'>


    Встроенные атрибуты классов:
        экземпляр.__class__ - ссылка на объект-класса, с которого был создан объект-экземпляр.
        экземпляр.__bases__ - последовательность, предоставляет доступ к классам.
        экземпляр.__class__.__name__ - имя класса.
        экземпляр.__dict__ - словарь атрибутов

    Можно получить тип/класс у метода:
            def someMethod():
                pass

            type(someMethod)
                <class 'function'> - класс метода. А далее будет уже класс type, если еще раз вызвать type(). Ведь метод это тоже объект.

    Инструкция class создаёт объект:
        - Этот объект можно присвоить переменной
        - Можно скопировать
        - Можно добавить к нему атрибут
        - Можно передать функции в качесвет аргумента.


    Обращение к атрибутам и их эквивалентные глабальные функции:
        a.x <==> getattr(a, 'x') # У объекта 'a' будет вызван/найден атрибует x. Целевой атрибут нужно передавать именно как строку.
        a.x = 1 <==> setattr(a, 'x', 1) # Не влияют на класс объекта, а меняют атрибуты/переменные экземпляра. Если такого атрибута в экземпляре не было, то будет создан такой атрибут.
        del a.x <==> delattr(a, 'x')
            Зы:
                - Не путаем их с __getattr__, __setattr__, __delattr__ - эти методы являются по сути дескрипторами класса.
                - А методы перечисленные выше, это глобальные???? методы для работы с любым объектом. 
                    - Именно благодаря им при работе с методами __getattr__ - происходит переадресация целевым объектам.

    Поиск, порядок поиска атрибутов:
        - Если у объекта-экземпляра вызвать метод/атрибут, то python ищет этот метод/атрибут у объекта-экземпляра, а потом у объекта-класса, от которого он создан, а потом у родительских объектов-классов.
            -- И останавливается на первой встрече.
        - Всегда будет вызван метод __getattribute__(attr_name) для любого атрибута (метода или филда)
            -- Дабы избежать рекурсии должен быть вызван и возвращён родительский метод.
                --- return super().__getattribute__(attr_name) или return object.__getattribute__(self, attr_name)
        - Если такой атрибут не найден, то будет вызван метод __getattr__(attr_name)
            - при желании можно добавить такой атрибут self.__dict__[attr_name] = 0 или "" в зависимости от типа. Но не вызывать self.attr_name иначе рекурсия.
        - Для __setattr__ внутри этого метода также следует использовать self.__dict__[attr_name] = ... иначе будет рекурсия.
!!!!    - В Py3 ни метод __getattribute__ ни метод __getattr__ не (перехватывают вызов/не вызываются) для функций-операций __add__, __repr__ итд.
            -- Для Python2 такие метды перехваются/выполняется.

    Пример как объекту делегировать вызов (вызов, что заранее не известен):
        def __getattr__(self, attr):
            return getattr(self.person, attr)
                # Предположим, что это класс обёртка поверх person и мы хотим всё что есть в person в части атрибутов переправлять в person. И вот такой спсобо позволят сделать так. Т.е. если такого атрибута в текущем классе нет, то будет вызван такой метод __getattr__ что обратиться по ссылке person.
                # Но методы вида __add__ так вызываться не будут и будут игнорироваться. Т.к. они ищутся именно в классе а не в экземпляре класса.

    Добавление экземпляру нового атрибута-метода:
            class A:
                def someMethod(self):
                    self.field = "someValue"
            a = A()
            a.someMethod()

            # А можно взять и добавить уже непосредственно объекту-экземпляру новый атрибут прямо на месте. И этот атрибут будет доступен только в этом объекте экземпляре.
            def someMethod(self):
                pass
            a.newMethod = someMethod    # Еще раз, присвоение всегда выполянется для экземпляра и он не будет искаться в классах, а поиск выполняется в экземпляре, а потом в классах.
                                        # Присванивание всегда выполянется для текущего экзмпляра, а поиск/получение выполнятся вверх.

    Наследование:
        - Производные класс может переопределить любые методы базовых классов.
            - В Python переопределение есть, а вот перегрузки нет.
        - Из метода дочернего класса можно вызвать метод с тем же именем у родительского/базового класса просто нужно указать перед методом наименование родительского/базового класса.
        - Метод объявляется с явным первым аргументом, представлюяющим сам объект и подставляемым автоматически при вызове.
        - При множественном наследовании поиск атрибутов производится вглубь, потом слева направа.

        - Унаследованные атрибуты класса присоединяются только к классу, они не копирются в экземпляры.
            - Для доступа к ним нужно получить ссылку на класс __class__ и использовать __dict__. 
                - А затем __bases__ дабы получить родительские классы.
                - Или просто, вместо __dict__  можно использовать dir(SomeClass) - он само подниитмся.
                    Или vars(SomeClass)

    Аналогия из С++
        Все атрибуты класса, включая поля данных являются открытыми, а все методы виртуальными.
            -- Виртуальные функции — специальный вид функций-членов класса. Виртуальная функция отличается об обычной функции тем, что для обычной функции связывание вызова функции с ее определением осуществляется на этапе компиляции. Для виртуальных функций это происходит во время выполнения программы.
            -- Виртуальная функция — это функция, которая определяется в базовом классе, а любой порожденный класс может ее переопределить. Виртуальная функция вызывается только через указатель или ссылку на базовый класс.

    - Есть понятие объект-класса и объект-экземпляра:
        - Класс - играет роль фабрик экземпляров. Их атрибуты - данные и функции, наследуются всеми экземплярами, созданными от них.
        - Экземпляр - конкретный экземпляр.
            -- Экземпляр из себя представляет новое пространство имен.
        - Атрибуты классов ведут себя как статические атрибуты их экземпляров (то есть общие для всех экземпляров данного класса).
            - Однако присвоить такому атрибуту новое значение Вы можете, только обратившись к нему как атрибуту того класса, в котором он определен (в противном случае Вы лишь создадите новый атрибут экземпляра с таким же именем. Т.е. нужно так ClassName.field=x а не так self.field=x или instance.field=x).
!           - Унаследованные атрибуты класса присоединяются только к классу, они не копируются в экземпляры.
                - Для доступа к атрибутам класса через __dict__ нужно получить у экземпляра объект класса через __class__, потом использовать __dict__ и при необходимости подняться вверх __bases__ и повтороить все занова.
        - Атрибуты класса обычно присоединяются к классам путем присваивания внутри class, а не во вложенных def
        - Атрибуты экземпляра обычно присоединяются к экземплярам путём присванивания значинй специальному аргументу с именем self.
            ~ Нужно учитывать, что подобно простым переменным, атрибуты классов и экземпляров не объявляются заранее, а появляются, когда им впервые выполняется присваивание значений.
                = Т.е. ниже по тексту до вызова setParam2 в экземпляре класса переменной param еще не существует.
            ~ Каждый объект экземпляра наследует атрибуты класса и получает собственное пространсово имен.
                = Объекты экземпляров начаниают свое существование пустими, но наследует атрибуты, имеющиеся в объектах классов, из которых они были сгенероированны.
            ~ Объекты экземпляров - является уникальным пространством имен.
        ! Так же как и инструкция def, инструкция class является выполняемой инструкцией. Когда она выполняется, она создает новый объект класса и присваивает его имени, указанному в заголовке инструкции class. Кроме того, как и инструкции def, инструкции class обычно выполняются при первом импортировании содержащих их файлов.
        
    Описание инструкций:
        - Инструкция def - является оператором присваивания. Он присваивает объект функции - имени.
        - Инструкция class - создает объект класса и присваивает ему имя (по сути создается объект и имени передается ссылка) отличие от Java в том что class в Java является объявлением а в Python инструкцией.
            ~ Как и в случае def выполняется при загрузке(при первом обращении к модулю).
            ~ Присваивания внутри инструкции class создает/формирует пространство имен атрибутов объекта-класса.
            ~ Когда выполняется оператор class (не вызов класса для создания экземпляра), он запускает все операторы, в теле с начала и до конца. Присванивания, происходящие во время такого процесса, создают имен в локальной области видимости класса, которые становятся атрибутами в ассоциированном объекте-класса. Т.е. формируется пространство атрибутов класса.

    Еще раз повторение
        - Вызов объекта класса (как метода - по сути в Java это называется конструктор) возвращает объект экземпляра.
            ~ Какждый экземпляр-класса приобретает свое собственное пространство имен.
            ~ Каждый экземпляр-класса НАСЛЕДУЕТ атрибуты объекта-класса.
            ~ self создает или изменяет данные экземпляра-класса а не объекта-класса (т.е. сохраняет значение в пространстве имен экземпляра-класса на не объекта-класса).
                При этом конкретного экземпляра а не не одного из родителя.
            ~ Атрибуты экземпляра перекрывают атриуты класса и имена методов.
                Т.е. изменять нужно переменные только через методы. Это будет изменять только значния экзмпляра, но не объекта-класса. А все поля нужно делать приватные.
                class MyClass2:
                        param2 = 2 #Переменная класса. В методе, доступ к ней осуществляется через MyClass2.param2. При этом если в методе сделать self.param2 то создастся переменная экземпляра. А переменная объекта-класса - останется прежней и доступной через имя класса.
                        
                        def getParam2(self):
                                return self.param2

                        def setParam2(self, varr):
                                self.param = 1
                                self.param2 = varr

                        def setParam2(self, varr): #Здесь показывается, что метод имеет доступ к глобальным атрибутам, как обычная функция модуля. Так как он определен в классе, его глабальными атрибутами является определение классa.
                                MyClass2.param2 = varr

                В Python нет перегрузки методов, но сделано для примера. Эти методы будут менять разные переменные. Т.е. первый set для экземпляров будет менять значение, а второй для класса.
                Это видно при получении через getParam и через получение по АТРИБУТУ класса.

                Переменные экземпляра перекрывают атрибуты класса и имена методов (имена методов тоже являются атрибутами класса).
                    Как и в Java - переменная объект-класса (атрибут класса) доступна для всех экземпляров-класса.
      
    Множественное наследование:
            Поиск имен итд идет слева на право.
                ClassName.mro()

    Вызов метода экземпляра вне класса:
        1. instance.method()
        2. ClassName.method(instance) # При этом  интерпретатора сам подставляет (трансформирует в такую запись)

    Атрибуты класса и экземпляра:
        - Атрибуты присоедененные к классам - доступны всем подклассам и экземплярам.
            - Атрибуты класса формируются на верхнем уровне т.е. сразу после class, а не в def (внутри def нельзя создать атрибут класса, хотя def создаёт имя функции, чьё имя является атрибутом класса).
            - Вложенные в class операторы def присваивают имена внутри класса, они в итоге присоединяют к объекту класса атрибуты, которые будут наследоваться всеми экземплярами и подклассами.
                - Т.е. def - объявяет имя метода и добавлят к классу, получаем атрибут класса, который является функцией.
        - Атрибуты присоедененные к экземплярам - доступны только этим экземплярам.
            - Атрибуты экземпляра формируются в def путем присваивания self
        
    
    Методы:
        Методы отмечанные в виде __X__ могут перехватывать операции.
        К примеру:
            __add__ вызывается когда с объектом вызывается сложение через оператор +
            __str__ когда требуется выводить объект на пчать.

            Но вызов таких методов не перехватывается методами вида/группы __getattribute__

    Вызов родительского метода:
        class B(A):
            def __init__(self, ...):
                A.__init__(self, ...)

            def method(self, ...):
                A.method(self, ...) 
                # Можно так super().__init__(...) аналогично и для методов. #Так можно только внутри методов. Т.е. без передачи self см. 279-280. Тут автомато будет передан self. А если из @staticmethod @classmethod
                # Или так super(А, self).__init__(...)
                # Самое интересное, если вызвать метод класса А у инстенса B (т.к. instanceB.method(...)), то будет по сути следующее A.method(instanceB, ....) т.е. по сути self указываеющий на instanceB
                            # Возможно два вида вызовов методов:
                                # экземпляр.медот(аргументы...)
                                # класс.медот(экземпляр, аргументы...)

                #Три способа вызова метода род. класса
                #super().targetMethod()                     #Через super сам Лутз не рекамендует. Есть шераховатости при наследовании и поиске. Лучше через имя класса.
                #super(CurrentClass, self).targetMethod()   # Не родительский класс, а текущий класс. Но этот вид для Py2
                #ParentClass.targetMethod(self)
                    # А вообще вызов вида: instance.method(args...) всегда транслируется в targetClass.method(instance, args...)

            Внимательно читаем II том Лутц 5изд - "Расширение методов. Хороший способ".
                Написано следующее:
                    Обращение через имя класса, отменяет поиск в иерархии наследования и запускает вызов выше в дереве КЛАССОВ чтобы выполнить специфическую версию.
                    Так рекамендуется вызывать методы вверх.

        Да можно через super но она плохо работает с множественным наследованием, и методами операций такими как __add__ итд (это по мнению Лутц)
            Лутц рекамендует обращаться по именам к суперКлассам.
            Да и при одинаковых методах в родительских классах при работе через supper будет проблема/неодназначнось.


    Абстрактные классы:

        from abc import ABCMeta, abstractmethod

        class Super(metaclass=ABCMeta):
            def delegate(self):
                self.action()
            @abstractmethod
            def action(self):
                pass

        Либо можно объявить метод, который будет выкидывать исключение. И если его не переопределить, то будет генерироваться исключение.

    Статические методы и методы класса:
    from datetime import date 
 
        class Person:
            def __init__(self, name, age):
                self.name = name
                self.age = age
         
            # a class method to create a Person object by birth year.
            @classmethod
            def fromBirthYear(cls, name, year): # Имеет доступ к состоянию класса(т.е. к атрибутам-класса). Можно обращаться к атрибутам-класса и даже создавать объект. Используется как билдер или фабрика.
                return cls(name, date.today().year - year)
         
            # a static method to check if a Person is adult or not.
            @staticmethod
            def isAdult(age):#Не имеет доступа к состоянию класса (т.е. к атрибутам класса). И его испльзуют, там где по логике этот метод может находится в этом классе. Допустим, проверка чего-то.
                return age > 18
         
         
        person1 = Person('mayank', 21)
        person2 = Person.fromBirthYear('mayank', 1996)

    Связанные методы:
        - Связанными называют методы, что вызываются через объект экземпляра.            
            Почему связанные? Да потому что мы можем сделать так:
            newName = instanceOfObject.metod # И здесь привязка к инстансу объекта экземпляра остаётся. И дальше мы уже можем передавать newName куда угодно, инстансОбъектаЭкземпляра
        - Несвязанными называтся методы, что вызываются через имя класса и передачи объекта экземпляра как аргумента метода.
            ClassName.method(instanceOfOjbect, ...)
            И когда мы делаем так
            newName = ClassName.method #Связки у newName нет.


    Новые классы python3 (методы перегрузки операций):
        Методы __x__ - т.е. те что используются для прехвата операций такие как __getitem__ или __add__ при ИХ поиске пропускают экземпляры и они ищутя только в классах от которых созданы экземпляры (речь идет при вызове их через операторы т.е. для __add__ через '+').
            - Т.е. методы __getattr__ и __getattribute__ больше не вызываются для поиска атрибута-метода вида __x__ (видимо если это происходит неявно, т.е. при вызове  __add__ через "+") 
            - При этом? при явном вызове этих методов __x__ поиск будет вестись так же через методы __getattr__ и __getattribute__
                См. Лутц II-том стр. 225 и 227.
                # Т.е. выражение вида X[i] будет эквивалентно:
                    > X.__getitem__(i)              # Для Python2
                    > type(X).__getitem__(X, i)     # Для Python3. Т.е. получили класс type(X) и у класса будем вызывать __getitem__(X, i)
                        # где i Это индекс.
                        # Т.е. теперь инспектируются только словари имён классов, от которого наследуемся.

                    Т.е. если теперь сделать:
                        - X.__add__ = lamdba y: 2 + y # То так X+1 работать не будет # Неявное обращение к __add__, обращение через оператор '+'
                        - X.__add__(1)  # А так будет, работать будет. # Явное обращение к __add__

                        Т.е. явное обращение выполняет поиск с экземпляра, для функций-операторов, а неявное выполняет поиск с классов.

            Методы:
                - __getattr__ вызывается, когда обращаемся к переменной которая не наследуется ни из одного класса или нет в экземплряе. 
                - __getattribute__ вызывается каждый раз, вне зависимости есть эта переменная или нет.
                    - Нужно быть внимательным, чтоб избежать рекурсии.
                        Приведёт к зацикливанию:
                            def __getattribute__(self, name):
                                x = self.name
                                # Т.к. __getattribute__ вызывается при любом обращении к атрибуту, то вызов self.name приведёт к еще одному вызовыу __getattribute__ и так пока память не закончится.
                                # Нужно так: object.__getattribute__(self, attr)
                    - Перехватывает только операции извлечения, но не присванивания. Для присванивания используется __setattr__
                - __setattr__ - вызывается при любом присванивании. Даже в __init__
                     __setattr__(self, name, value): # Тоже приведёт к зацикливанию. 
                        self.other = value
                - Оба принимают так же self как и обычные методы.
            - Не работают для неявных вызовов (для операции '+' происходит неявный вызов __add__ метод перегрузки операции), но обращение по явным вызовам (по именам)  (т.е. прямому obj.__add__(...)), перехват по прежнему обрабатывается и выполняется.
                - Т.е. методы перегрузки операций ищутеся только в классах. И полностью пропускают экземпляры. А методы перегузки работают именно с экземплярами.
            - Вообще методы __getattr__ и __getattrib__ должны возвращать из себя.
                def __getattr__(self, attr):
                    return getattr(targetObj, attr)

                def __getattribute__(self, attr):
                    if attr in ['name1', "name2"]:
                        return object.__getattributre__(self, attr)
                    else:
                        return getattr(targetObg, attr)


    Call
        В Python классы, функции, методы и экземпляры - все это объекты. И каждый раз, когда мы ставим скобки после их имени, мы вызываем их метод __call__ # Это вроде относится к type(....), когда создаётся объект, а не получается тип?
        foo = Foo()
        Так что foo(1, y=2) — это эквивалент foo.__call__(1, y=2). Причём метод __call__  объявлен в классе Foo объекта foo.

        В первом случае __call__ вызывается когда мы хотим испльзовать объект-экземпляр как функцию.
            Допустим 
                class Foo:
                    def __init__(self):
                        pass
                    def __call__(self, someValue):
                        return self.sameValue * 2

                foo = Foo()
                foo("Name") # Вернёт NameName


    Слоты Slots
        Позволяет указать какие атрибуты могут быть у клсса:
            class A:
                __slots__=['firstField', 'secondField']

            a = A()

            a.firstField = 1
            a.thirdField = 2 # Недопустимо, т.к. в slots нет такого поля.

        Но есть проблемы с __dict__ короче, нужно читать детальнее.

    ДЕКОРАТОРЫ:
    см. стр. 528

        - Вставка автоматически запускаемого кода в конце оператора определения функций и классов - в конце def для декораторов функций и в конце class для декораторов классов.
        - Декораторы - повторно привязывают имя (класса, функции) к результату функции - которая выполняет роль декторатора.

        См. стр. 273 - декораторы функции. и стр. 274
        См. рис. 275 - декораторы классы.

        См. стр. 597 - как пример в середине страницы.

        Декоратор классов:
            def decorator(aClass): ...

            @decorator
            class C: 
                ...

        # Транслируется в:
            C = decorator(C)

        Декторторы функций:
            @decorator
            def func(args): ...

        # Транслируется в:
            func = decortor(func)

        class Person:
            @property
            def name(self): ...

            # Эквивалент: Во время выполнения декорированынй метод автоматически передаётся в первом аргументе встроенной функции property
            class Person:
                def name(self): ...
                name = property(name)

    Декоратор функция
            def decorator(F):
                def wrapper(*args):
                    # Дополения/вычисления и вызов исходной/переданной функции F(*args)
                    ...
                return wrapper

            @decorator
            def func(x, y):
                ...

            func(6, 7)

    Аналог через класс: # Cм. пример decorator1.py
        class decorator: # Этот пример хорошо работает для обычных функций, но не для методов классов. Причина в том, что экземпляр целевого класса нигде не передаётся см. 510-511
            def __init__(self, func):
                self.func = func
                ...

            def __call__(self, *args):
                #self.func(*args)
                ...

        @decorator # Т.о. для каждой функции создается свой экземпляр.
        def func(x, y):
            ...

        func(6, 7)



    Много пропущено с 
        стр. 280-300 там нюансы по super
        
    Похоже взято из описания мета-классов (стр. 606 Базовый метакласс).    
            Foo(*args, **kwargs) эквивалентно Foo.__call__(*args, **kwargs).
            Так как объект Foo — это экземпляр класса type, то вызов Foo.__call__(*args, **kwargs) эквивалентен type.__call__(Foo, *args, **kwargs).
            type.__call__(Foo, *args, **kwargs) вызывает метод type.__new__(Foo, *args, **kwargs), возвращающий obj.
            obj инициализируется при вызове obj.__init__(*args, **kwargs).
            Результат всего процесса — инициализированный obj.

    Порядок вызывов методов внутри обычного класса:
            __new__ - вызывается перед __init__
                class SomeClass:
                    def __new__(cls, *args, **kwargs):
                        instance = super().__new__(cls) #Так можно только внутри методов класса. #Если родитель явно не указан, видимо можно указать вместо super() объект object
                        # В этом месте можно настроить свой экземпляр...
                        return instance
                    def __init__(self, val):
                        self.val = val

    Управляемые атрибуты:
        атрибут = property(fget, fset, fdel, doc) # Ни одна из переменных не является обязательной. Присваивается None и при обращении генерируется AttributeError
            # Здесь используются методы класса, т.е. те что с self.
            # Применяется к атрибуту класса??? см. Лутц 5изд. стр. 458
            # Вызов встроенной функции property возвращает объект свойства, который приваиваем имени атрибута. подлежащиго управлению в области видимости класса, где он будет наследоваться каждым экземпляром.

        https://proproprogs.ru/python_oop/svoystva-property-dekorator-property

            class Person:
                def __init__(self, name, old):
                    self.__name = name
                    self.__old = old
             
                @property
                def old(self):
                    return self.__old
             
                @old.setter
                def old(self, old):
                    self.__old = old

                 @old.deleter
                    def old(self):
                    del self.__old

            class BaseClass(object):
                @property
                def foo(self):
                    return # some_calculated_value()    
                @foo.setter
                def foo(self, value):
                    return # do_something_with_value(value)

            class DerivedClass(BaseClass):
                @BaseClass.foo.setter
                def foo(self, value):
                    return # do_something_different_with_value(value)

    Декскриптор - это класс с точным набором методов. Которые вызываются автоматически.
        class Descriptor:
            def __get__(self, instance, owner): ... # Возвращание атрибута. owner (class_Of_Instance) - это класс в котором используется этот дескриптор. instance - экземпляр от этого класса.
            def __set__(self, instance, value): ... #Ничего не возвращает.
            def __delete__(self, instance): ... #Ничего не возвращает.
            # Т.е. owner - это класс в котором объявлена переменная с дескрипотором. attr = Descriptor()


    Дескрипторы работают для атрибутов классов и не будут работать для атрибутов-экзмпляров. стр. 465 снизу.
        Но через дискрипторы можно менять атрибуты-экземпляра, т.к. дескриптор получает ссылку instance (экземпляра) и через него можно управлять атрибутами экземпляра.
    У дескриптора есть своё состояние, но одно на все экземпляры.
        Т.к. мы привязываем к атрибуту класса - а атрибут класса один и он созётся один раз (по аналогии со static field в Java).
        Получается, что дескриптор один на все экземпляры класса клиента и его состояние одно на все экземпляры.





Наследование и экземпляр(стр. 613);
Методы метаклассов (стр. 623);
Пример: добаления методы в классы (стр. 626);
Пример: применение декораторов к методом (стр. 634);

====================================================================================================

Метаклассы:
    - Типы определяются классами, кторые унаследованы от type
    - Определяемые польззователем классы являются экземплярами класса type
    - Определяемые пользователем классы представляют собой типы, которые генерируют собственные экземпляры.

    Классы по умолчанию создаются из корневого класса type.
        - Классы имеют __class__ который казывает на метатип из которого он был создан.
        - Метаклассы являются подптипами type, т.е. наследуются от type.
            - type - является классом, который генерирует классы, определяемые пользователем.


    Оператор class:
        Когда интерпретатор добирается до оператора class он выполняет его вложенные блоки кода, создаёт атрибуты класса, выполнение def - которые тоже становятся атрибутом класса.
        В конце оператора class и после выполнения всего вложенного в него кода, Python Обращается к объекту type для создания объекта class.

            cl = type(class_name, superClasses, attrDict)   # class_name - в виде строки

            - type(...) по сути производит вызов __call__ который взывает по очереди два др. метода.
            - type.__new__(class_type, class_name, superClasses, attrDict)      # Создаёт и возвращает новый объект класса. (Все как для обычных инстенсов). Где class_type - это класс-метакласс. Т.е. тот, что указан в metaclass=Meta.
            - type.__init__(target_class, class_name, superClasses, attrDict)   # Инициализирует созданный объект-класс что передан в виде аргумента target_class.

        # Пример
            class Meta(type):
                def __new__(meta_cls, className, supers, classdict):
                    print("Hello from new of the __new__ meta: className = " + className)
                    print("Hello from new of the __new__ meta: meta_cls = " + str(meta_cls))
                    return type.__new__(meta_cls, className, supers, classdict)

                def __init__(obj_cls, className, supers, classdict):
                    print("Hello from new of the __init__ meta: className = " + className)
                    print("Hello from new of the __init__ meta: obj_cls = " + str(obj_cls))

            class TargetClass(metaclass=Meta):
                print("In targetClass --- First")
                classField = 'class_field'
                def mehtod(self):
                    pass
                print("In targetClass --- Second")

            # Выдаст
            # In targetClass --- First
            # In targetClass --- Second
            # Hello from new of the __new__ meta: className = TargetClass
            # Hello from new of the __new__ meta: meta_cls = <class '__main__.Meta'>
            # Hello from new of the __init__ meta: className = TargetClass
            # Hello from new of the __init__ meta: obj_cls = <class '__main__.TargetClass'> # Это уже объект-класса.



            NB!
                У метакласса  могут быть свои методы, которые работают с классом. см. 623


    https://habr.com/ru/post/145835/

    Метакласс - это сущность, что создает классы.
        MyClass = MetaClass()   # Создал объект класса. За это отвечает метад-класс.
        MyObject = MyClass()    # Создал инстенс из объекта класса.
        
    А по сути это и есть type:
        MyClass = type('MyClass', (), {}) #Т.е. функция type является метаклассом.


    По сути когда пишем "class NameOfClass:" мы создаем объект, который будет создавать экземпляры класса.
        По этой причине NameOfClass можно присвоить новой переменной, копировать, можно передать функции в качестве аргумента, можно вернуть из функции.

    type(<имя класса>,
        <кортеж родительских классов>, # для наследования, может быть пустым
        <словарь, содержащий атрибуты и их значения>
        )

    Пример:
        def echo_info(self):
            ...
            print "Info"

        class Bar:
            ...
            pass

        class Foo(Bar):
            ...
            bar = True

        можно переписать как
        Foo = type('Foo', (Bar, ), {'bar':True, 'echo_info': echo_info})


    Еще одно есть одно поле Это для Python2
        __metaclass__ # Это для Python2???  # Для Python3 class SomeClass(metaclass=SomeMeta)

        - При создании объекта-класса ищется данное поле, в самом классе, в классе родителя, если не найдено данное поле, то будет создан объект-класса без поля __metaclass__ - т.е. в стандартном режиме. Если же будет найдено в любом классе (текущем или родительсокм) то будет создан объект исходя из значения поля __metaclass__
        - Если данное поле указано в сaмом модуле, то будет использоваться для всех классов данного модуля. Это поле в модуле задается в глобальной области (т.е. не в нутри чего либо).

    Метод __new__ у метакласса имеет следующую сигнатуру.
        __new__(cls, name, bases, dict)
            Если мы его переопределяем в нашем метаклассе, то необходимо вызвать его у type.
                retrun type.__new__(cls, name, bases, dict)


А это и есть метоКласс:
        Создание класса(объекта-класса):
            type(<имя класса>, <кортеж родительских классов # для наследования, может быть пустым>, <словарь, содержащий атрибуты и их значения>)

                # Помним, что type это класс(объект-класса). Если объект, то вызывая таким образом type(...), мы вызываем его __call__
                    # __call__ в свою очередь вызывает поочерёдно __new__ и __init__. Если есть наследование от type - то будет вызвана переопределнная версия __new__ т.е. версия из наследника класса type.
!!!                      ## с переопределением __call__ в метаклассе - всё как-то сложно. До конца так и не понятно. Пока лучше его не переопределять.
                            ### См. раздел "Перегрузка операций вызова, создающих классы, с помощью метакласса" и сам файл metaclass5.py
                            ### При этом путаница еще и с сигнатурами метода __call__ у Лутаца одна сигнатура а в классе object и интернетах другая сигнатура.
                                #### def __call__(meta, classname, supers, classdict) - у Лутца, что соотносится с вызовом type(...) при создании класса.
                                #### def __call__(self, *args, **kwds) # В классе object и в интерентах. 
                    # Главное не забыть в наследующем классе вызывать родительскую реализацию __new__ со всеми потрахами. Суть использования __new__ наследующем классе - это перехват вызова создания экземпляра. И не забыть вызвать родительский __call__

            def echo_bar(self):
                print self.bar

            FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar}) # Это есть неявный вызов __call__ у type. И сигнатура соответствует Лутцу а не Интернету или object.

            type - это метакласс.
                Цель метаклассов - кака я понял, просто перехватывать создания целевых классов и при необходимости логгировать или добавтья свойства, методы или еще чего-то.



Метакласс
!!!!        - В Python3 классы, определяемые пользователем, представляют собой экземпляры ОБЪЕКТА по имени type, который сам по себе является классом. (стр.599)
            - Экземпляры создатся из классов, а классы создатся из type
                    - Мы можем создать дочерний класс унаследованный от type - это и есть метатип.
                    - А из за того, что классы представляют собой экземпляры класса type, создание обычных классов на базе унаследованного класса от type (далее метатип) позволяет управлять созданием классов (путем задания нужной логики в метотипе и указав его в целевом классе через metaclass = targetMetaClass_that_ExtendsType).
                - Объект type на верхушке иерархии создаёт индивидуальные типы, а индивидуальные типы создат экземпляр.
                - Классы яляются типами, а типы - классами.
!!!             - Классы являются экземплярами type, а обычные экземпляры явлются экземплярами класса, определяемого пользователем
            - В Python3 классы являются типами, а типы - классами.
                - Типы определяются классами, которые унаследованы от type
                - Определяемые пользователем классы являются экземплярами класса type
                - Определяемые пользователем классы представляют собой типы. которые генерирут собственные экземпляры.
            -Типом экземпляра будет класс из которого он создан.
                - Классы имеют атрибут __class__, ссылающиийся на type, точно так же, как экземпляр имеет атрибут __class__, ссылающийся класс, из которого он был создан.

            - type - является классом, который генерирует классы, определеяемые пользователем
                - метатайп - представляют собой подклассы класса type
            - объекты классов являются экземплярами класса type или какого-то из его подклассов
            - объекты экземпляров гереритутся из класса.

            - типы определяются классами, которые унаследованы от type
            - определяемые пользователем классы являются экземплярами класса type
                - вот метотайп позволяет управлять создаинием экземпляра от класса type (т.е. управлять созданием объекта class)
                    - Метатайп есть дочерний класс от type. 
                    - Т.е. наследуемся от type - создавая дочерний класс и реализовываем нужную логику в нем. Далее указываем у обычного класса этот метатайп, тем самым получаем доступ к созданию объекта-класса.
            - определяемы пользователем классы представлют собой типы, которые генерируют собственные экземпляры.

            Py3
                - Классы имеют аттрибут __class__, ссылающийся на type, точно так же, как экземпляр имеет атрибут __class__, ссылающийся на класс, из которого он был создан.
                - Note that the __new__ method is a static method of metaclass. And you don’t need to use the @staticmethod decorator because Python treats it special.
                    см. примеры https://www.pythontutorial.net/python-oop/python-metaclass-example/


        1. Дойдя до class - выполняются все инструкции внутри, где в том числе проиходит привязка имён к пространству имён создаваемого класса (атрибуты класса)
        2. Далее в конце оператара calss происходит общарещине к объекту type для создания объекта КЛАСС:
            class = type(Class_Name, SuperClassList, DictOfAttr) # !!! Вот оно создание класса и вызов __call__ у type!!! Вот он созданный класс см. стр. 609. как реализуется см. метод __call__ (метод перегрузки операций)
!!!         В type - определён метод перегрузки операций __call__, который при вызове объекта type поочерёдно вызывает два др. метода
                type.__new__(ClassType, Class_Name, SuperClassList, DictOfAttr) # Создаёт и возвращает новый объект класса. ClassType = meta (получается это type)
                type.__init__(Class, Class_Name, SuperClassList, DictOfAttr) # После создания инициализирует вновь созданный объект

                2.1. Если для класса указан метатип, то будет вызван этот метатип.
                    class = MetaType(Class_Name, SuperClassList, DictOfAttr) # А это вызывает унаследованный от type метод __call__ который будет вызывать методы __new__ и __init__ или переопределенные их формы из метотипа.

                        - Важно - вызов MetaType(...) вызовет у класса MetaType метод __call__ - ведь MetaType это объект. При этом __call__ ищется у типа-класса (type(MetaType)) а не у объекта MetaType - т.к. происходит неявный вызов.
                            -- Метод __call__, что внутри MetaType будет вызван при создании экземпляра класса, у которого был указан в качестве метатипа класс MetaType.
                            -- Вот от куда в metainstance.py - вызов __call__ при создании объекта класса.
!!!                     - Важно - если в метотипе переопределены функции __call__ и __new__ - то они должны вызывать соответствующие у type.
                        - Важно - __call__ лучше не переопределять - что-то с ним всё сложно.

                        c() <=> type(с).__call__(с) см. стр. 228
                        x[1] <=> type(x).__getitem__(x, 1)
                        x + "egg" <=> type(x).__add__(x, "egg")

                            # см. стр. 222 Лутц "Изменения в классах нового стиля"
                            # Поиск имён вида __x__ начинается в классах а не в экземплярах (получается: для экземпляров это класс, для класса метакласс???)
                                # Если в ЭКЗЕМПЛЯР добавить метод вида __x__ то этот метод не будет использоваться, при неявном вызове (т.е. вызов через выражения): стр. 226
                                    # instance.__add__ = lambda(у): 1 + у ---> instance + 1 # даст ошибку. Это неявный вызов.
                                    # Но явный вызов будет работать instance.__add__(1) # И также явный вызов пойдёт через __getattr__ 
                            # __getattr__ и __getattribute__ НЕ вызываются для имён методов перегрузки операций __x__ (при неявном вызове)

                            # Абсолютно такая же ситуация с __setattr__ и многими другими магическими (и специальными) методами и соответствующими встроенными функциями, которые определены для всех объектов, в том числе и для объектов типа — классов.

                        a.x = 1 <=> setattr(a, 'x', 1)  <==> type(a).__setattr__(a, 'x', 1) 


                        Нужно разобраться
                            https://habr.com/ru/articles/114587/

        3. Метаклассы как правило переопределяют у type методы __new__ и __init__ (для настройки создания и иницализации классов).
        4. Объявление метакласса, наследуется дочерними классами. Т.е. метакласс будет запускаться и при создании родительского класса и при создании дочернего класса.
        4. Определяемое поведение матаклассов применяется к классу (т.к. классы это объекты type), но не к создаваемым в последствии экзамплярам класса.
            Экземпляры получают своё поведение от классов и суперклассов но не от мета-классов. Т.е. у экземпляра поиск только в __dict__ экземпляра - класса, и всех супер-классах класса. Для обычных экземпляров метаклассы в поиск при наследовании не включается.
        5. Классы получают методы своих метаклассов. 
            # Классы обзоводятся атрибутами метаклассов посредством ссылки __class__.
                ## Т.е. по аналогии, как нормальные экземпляры наследут атрибуты из классов через свои атрибуты __class__. Что логично ведь класс это экземпляр метакласса.
                ## Но экземпляр класса не переходит по ссылке __class__ своего класса, вместо этого он идет по дереву __dict__ в порядке MRO.                
                    ### Python проверяет __dict__ каждого класса в порядке MRO(наследование), преждем чем переходить к получению из экземпляра(отношение между экзмеляпрами)
            - Если классу доступно имя из супер-класса и из мета-класса, то берётся имя из супер-класса(через наследование) а не из металкласса(через экемпляр)
            - Атрибут __class__ класса не следует в его собственные экземпляры: атрибуты метаклассво деладтся доступными их классами-экземплярами. но не экземплярами этих классво-экземпляров.

            Тождественные действия/операции (ну или как внутри всё происходит):
                # Определение типа при помощи инструкции class
                class MyCls:  # Для Python 2 — MyCls(object)
                    a = 1
    
                # Эквивалент, под капотом или то что можно сделать еще и руками. Но перед этим выполнятся блоки кода где проинициализиются атрибуты.
                MyCls = type('MyCls', (), {'a': 1})

                ----------------------------

                # Определение типа при помощи инструкции class
                class MyCls(SuperCls, metaclass=Meta):
                    a = 1

                # Эквивалент, под капотом или то что можно сделать еще и руками.
                MyCls = Meta('MyCls', (SuperCls,), {'a': 1})                


    Создание собственного мета-класса:
        class Type(type):
            def __new__(meta_Class, name_targetClass, parentClassList, dictOfAttr):     # Создаёт и возвращает объект-класса.
                meta_Class.attachToMeta = "Attached_to_meta_Class"                      # Присоеденено к meta и НЕ доступно в экземпяре класса, но доступно в классе.
                dictOfAttr["attachedToDictionary"] = "Attached_To_Dictionary"           # Присоеденено к классу и доступно в экземпляре класса.
                print("Type.__new__", meta_Class, name_targetClass, parentClassList, dictOfAttr, sep = "\n\t")
                #print(meta_Class.attachToMeta)
                for attr  in meta_Class.__dict__:
                    print(attr)
                return type.__new__(meta_Class, name_targetClass, parentClassList, dictOfAttr) # Именно этот метод и создаёт класс что равно class = type(Class_Name, SuperClassList, DictOfAttr)

            def __init__(target_Class, name_targetClass, parentClassList, dictOfAttr): # Иницилизирует уже созданный класс, переданный в качестве аргумента
                print("Type.__init__", target_Class, name_targetClass, parentClassList, dictOfAttr, sep = "\n\t")
                for attr  in target_Class.__dict__:
                    print(attr)
                target_Class.attachedToTargetClass = "attached_To_Target_Class"
                super().__init__(name_targetClass, parentClassList, dictOfAttr) # А так не работает type.__init__(name_targetClass, parentClassList, dictOfAttr) - почему???
                # Вместо super() можно object. Вообще в py3 super() - это считается нормальным. См. стр 277 "Встроенная функция super ... "

            def metaPrinter(self):
                print("metaPrinter self.__class__ = ", self.__class__)
                print("metaPrinter self = ", self)

        class ParentClass:
            pass

        class MyClass(ParentClass, metaclass=Type): 
            def printer(self):
                print("printer self.__class__ = ", self.__class__)
                print("printer self = ", self)


        class ChildClass(MyClass):  #Метакласс наследуется при создании потомков для MyClass. Т.е. у потомков будет этот мета-класс. И этот метакласс будет вызван и при создании доч-го класса.
            pass

        ---------------------------------------------

        class MyMetha(type):
            def __init__(target_Class, Class_Name, SuperClassList, attrs):
                print ("Создание класса Class_Name = %s " % Class_Name)
                print ("Создание класса target_Class.name = %s" % target_Class) # Здесь можно добавить новые атрибуты или еще чего.
                if len(attrs) > 0:
                    for i in attrs.keys():
                        print("Key = %s ::: %s " % (i, attrs.get(i)))

                super().__init__(Class_Name, SuperClassList, attrs)

        class SomeClass(metaclass=MyMetha): #class SomeClass(SuperClass1, metaclass=MyMetha)
            def __init__(self):
                print("It is ibn __init__ in SomeClass")

        sc = SomeClass()

        newClassCreated = MyMetha('newClassCreated', (), dict(x=2))


            Другой способ.
            class AnotherMetaclass(type):
                def __new__(meta_cls, name, parents, dct):
                        # cls is this class
                        # name is the name of the class to be created
                        # parents is the list of the class's parent classes
                        # dct is the list of class's attributes (methods, static variables)

                        # here all of the attributes can be modified before creating the class, e.g.

                    dct['x'] = 8  # now the class will have a static variable x = 8

                        # return value is the new class. super will take care of that
                    return super(AnotherMetaclass, meta_cls).__new__(meta_cls, name, parents, dct) #new_class = super().__new__(meta_cls, class_name, class_parents, class_dict)

        Т.е. метокласс - это про создание классов, а не экземпляров классов.

        В метоклассе методы:
            __new__  - для создания класса.
            __init__ - применяется для инициализации вновь созданных классов.
        
        Другие методики реализации метаклассов:
            - Использование простых фабричных функций (стр. 608) - достаточно просто.
            - Перегрузка опреаций вызова, создающих классы, с помощью нормальных классов (стр. 609) - достаточно просто
            - Перегрузка операций вызова, создающих классы, с помощью метаклассов (стр. 611) - а тут нужно разбираться (не смог разобраться)
                - На данный момент вывод один: не переоределять в метаклассах __call__ - это пока какая-то непоятная путанница. И связано это с тем, что __call__ вызывается не явно и тут начинается анархия.
                    --- Под неявным вызовом подразумевется вызов через встроенную функцию (допустим str() и соответствующий __str__) или через оператор (для __add__ это +).
                            ----- К ним же относятся встроенные операции на подобии вызовов.
                        ---- Здесь же в файле metaclass5_hmm.py даётся такое:
                                #print(SubMeta.__call__(SubMeta, 'xxx', (),{}))   # Explicit calls work
                                #print(SubMeta('xxx', (),{}))                     # But implict built-in calls do not
                    --- Метод __call__ ИЩЕТСЯ ВСТРОЕННЫМИ ОПЕРАЦИЯМИ в классе (т.е. в типе) объекта. А раз так, то этот поиск будет выполняться и у его метакласса целевого класса.
                            Просмотр класса метакласса, доступного по ссылке __class__, который будет либо стандартный type либо метакласс.

                            раздел "Особый случай для встроенных имён"
                                встроенные имена ищутся в мета-классе для встроенных функций.
                            см. 622-623 

==============================================================================================================================================
ИТЕРРАТОРЫ:
    Объекты, что имеют метод obj.__next__() - это в Python3
        В python2 это метод next(obj) - но в Python3 он будет вызывать __next__()

        __next__() - возвращает следующий объект или генерирует исключение StopIteration - для окончания итерации.
        Итератор извлекается с помощью встроенной функции iter().

        yeild - по сути возвращает объект итератор. Т.е. они компилирются как генераторы (которые поддерживают протокол генератора т.е. функцию __next__())
            - Функция с yeild продолжается до тех пор пока не встретится следующая yeild либо до исключения StopInteration
            - Такие функции можно выполнять в любом итерируемом объекте.

    Различают Итерируемый(iterable) и Итератор(iterator)
            - В первом случае - это то что будем перебирать. И должен името метод iter().
            - Во втором случае - это то что будет перебирать. И который можно передать методу next(). Итератор как правило имеет метод __next__() ну или __getitem__()
                - __getitem__ вызывается только тогда, когда нет __iter__
        Т.е. итерируемый объект может/должен возвращать итератор. При этом, как правило, итерируемый объект НЕ является итератором.
            Такое разделение целенаправленно. 
                Первое - разделение обязанностей.
                Второе - если сам объект будет итератором, то НЕ получится пройтись повторно не нему.
                    А так мы при получении iter получим новый итератор и по нему снова можно будет пройтись.

        Генераторы:
            Генераторные функции и генераторные выражения - представляются собой итераторы и по этому поддерживают только одну активную итерацияю.
                Итератором генератора является гам генератор. 
                    По этой прчине вызов iter На генераторном выражении или функции нечего не делает.


    To create an object/class as an iterator you have to implement the methods __iter__() and __next__() to your object.
        The __iter__() method acts similar, you can do operations (initializing etc.), but must always return the iterator object itself.
        The __next__() method also allows you to do operations, and must return the next item in the sequence.
            - Т.е. итератором является тот, кто имеет метод __next__()
            - To prevent the iteration from going on forever, we can use the StopIteration statement.
            - In the __next__() method, we can add a terminating condition to raise an error if the iteration is done a specified number of times
                    class MyNumbers:
                      def __iter__(self):
                        self.a = 1
                        return self # Here should be returned other object which is the iterator.

                      def __next__(self):
                        if self.a <= 20:
                          x = self.a
                          self.a += 1
                          return x
                        else:
                          raise StopIteration # Итерация продолжается до тех пор, пока не встретится исключение StopIteration

                    myclass = MyNumbers()
                    myiter = iter(myclass) #Здесь происходит закулное обращение к __iter__

                    for x in myiter: # Здесь можно было бы не указывать myiter - за зановесами был бы вызван меод iter()
                      print(x)



    Для получения из списка итератора нужно выполнить:
        iterator = iter(some_list)

        range() - позвляет получить индекс
        enumerate() - позволяет получить индекс элемента и его значение.
            a = [10, 20, 30, 40]
            for id, val in enumerate(a):
                print(id, val)
        или можно так
            a = [10, 20, 30, 40]
            for i in range(len(a)): # перебор по индексам
                a[i] += 5

==============================================================================================================================================
ДЕКТОРАТОРЫ:
    Декараторы применяются как к методам так и к классам.
    Декараторы являются прокси по отношению к классу или методу (и имя этого декаратора такое же как и декарируемый класс или метод - Так называемое ПОВТОРНОЕ ПРИВЯЗЫВАНИЕ).

    Повторное привязывание происходит на этапе определения метода или класса.
        Вспоминая что def и class это по сути объявлние переменной, то можно говорить, что привязывание происходит в конце операторов def и class.

    Декаратор это сущность времени выполнения.

    Декоратор вызывается при декорировании, а возвращённый объект при обращении к декорированной функции.
         Сам декоратор принимает декорируемую функциою
         А возвращённый объект - аргументы, что передаются исходной функции.

         Т.о. каждое декорирование создаёт свое назевасимое пространство имёт. Т.к. каждая декорируЮЩАЯ функция создаёт своё пространство имён и возвращает новую функцию.

    Декораторы функций:
    #--------------------------------------------------------------------------------------
        def my_shiny_new_decorator(function_to_decorate): # Внутри себя декоратор определяет функцию-"обёртку". Она будет обёрнута вокруг декорируемой, получая возможность исполнять произвольный код до и после неё.

            def the_wrapper_around_the_original_function():             #the_wrapper_around_the_original_function(arg1, arg2) или #stand_alone_function(*args)
                print("Я - код, который отработает до вызова функции")
                function_to_decorate() # Сама функция                   #function_to_decorate(arg1, arg2)
                print("А я - код, срабатывающий после")

            return the_wrapper_around_the_original_function # Вернём эту функцию
        

        def stand_alone_function():                                     #stand_alone_function(arg1, arg2)                
            print("Я простая одинокая функция, ты ведь не посмеешь меня изменять?")

        stand_alone_function()
        stand_alone_function_decorated = my_shiny_new_decorator(stand_alone_function)
        stand_alone_function_decorated()

        stand_alone_function = my_shiny_new_decorator(stand_alone_function)
        stand_alone_function()

        @my_shiny_new_decorator
        def another_stand_alone_function(): # По судит вызывается следующее: another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)
            print("Оставь меня в покое")

        another_stand_alone_function()
    #--------------------------------------------------------------------------------------
        class decorator:
            def __init__(self, func):       #func
                self.func = func

            def __call__(self, *args):      #self - экземпляр декоратора т.е. класса decorator. Но момент в том что *args не содержит экземпляр что нужен для func т.е. к какому экземпляру класса "С" будет вызов этой функции func. Т.е. это вызывает проблемы для функции из класса/экземпляра
                ...                         #__call__ вызывается перед вызовом любого метода экземпляра данного класса.
                self.func(*args)
                ...

        @decorator
        def func(x, y):         #func = decorator(func)
                                #func передается __init__ а когда происходит вызов внутренней функции класса, происходит вызов __call__ который собственно и является оберткой.
            ....

        func(6, 7)


!!!!    Но с методами экземпляров классов работать НЕ будет. Допустим для:
        См. выше. Т.к. в __call__ не будет передан self класса С т.е. в *args не будет передан self. См. Лутц 5изд. стр. 510-511
        Действительно кто в __call__ будет передавать экземпляр класса С???? Что будет необходимо для метода method(self, ....)????
        В таком случае руками нужно передавать в __call___ класса декторатор объект(экземпляр) для которого мы вызываем. В данном случае экземпляр класса С. Но тогда зачем всё это нужно???

        class C:                    
            @decorator
            def method(self, x, y):
                ...

        С функцией декоратором такой проблемы не бывает - выходит она универсальная. См. ниже пример.

    #--------------------------------------------------------------------------------------
        Для поддержика и функций и методов, нужно использовать вложенные функции

        def decorator(F):
            def wrapper(*args): #Для метод экземпляр класса находится в args[0]. В отличии от __call__ в *args будет передан и self.
                F(*args)
            return wrapper

        @decorator
        def func(x, y):
            ...

        class C:
            @decorator
            def method(self, x, y):
                ...

        func(6, 7)
        X = C()
        X.method(6, 7) #по сути будет вызов (X, 6, 7)
    #--------------------------------------------------------------------------------------
        def decorator(cls):
            class Wrapper:
                def __init__(self, *args):
                    self.wrapped = cls(*args):

                def __getattr__(self, name):                # метод вызывается, когда у экземпляра не найден такой атрибут. А так как у этого Wrapper нет такого атрибута, мы однозначно попадем в этот метод.
                    return getattr(self.wrapped, name)      # getattr(object, name) возвращает значение атрибута объекта object по его имени name. Где name это строка.

            return Wrepper  #Возвращаем объект класса Wrapper (по сути в питоне это фабрика экземпляров для класса Wrapper). См. метаклассы.
                            #Т.к. это является объект, то по этой причине мы спокойно можем передавать эту ссылку и возвращать из метода эту ссылку.
                            #А тип у него будет type.

        @decorator
        class C:
            def __init__(self, x, y):
                self.attr = 'spam'      #Здесь пример дан для атрибута класса, а как с методами и перехватом вызовов метода?

        x = C(6, 7)
        print(x.attr)

==============================================================================================================================================
ДЕСКРИПТОРЫ:
    Дескриптор это атрибут объекта со “связанным поведением”, то есть такой атрибут, при доступе к которому его поведение переопределяется методом протокола дескриптора. Эти методы  __get__, __set__ и __delete__. Если хотя бы один из этих методов определен в объекте , то можно сказать что этот метод дескриптор.

    Класс определяющий методы:
            __get__             # descr.__get__(self, obj, type=None) -> value
            __set__             # descr.__set__(self, obj, value) -> None                
            __delete__          # descr.__delete__(self, obj) -> None
        Может называться дескриптором.

            class NonNegative:
                def __init__(self, name):               # Python 3.6+ в место инит может использоваться __set_name__
                    self.name = name
                def __get__(self, instance, owner):
                    return instance.__dict__[self.name]
                def __set__(self, instance, value):
                    if value < 0:
                        raise ValueError('Cannot be negative.')
                    instance.__dict__[self.name] = value

            class Order:
                price = NonNegative('price')
                quantity = NonNegative('quantity')

                def __init__(self, name, price, quantity):
                    self._name = name
                    self.price = price
                    self.quantity = quantity

                def total(self):
                    return self.price * self.quantity

            apple_order = Order('apple', 1, 10)

        Python позволяет перехватить выше упомянутые попытки доступа к атрибуту и переопределить связанное с этим доступом поведение. Это реализуется через механизм протокола дескрипторов. 


==============================================================================================================================================

Исключения:
    https://learn.saylor.org/mod/book/tool/print/index.php?id=29251
    Цепочка исключений работает так же как и в Java (по этому очредность располагаем так же от специфического к общему).
    Если исключение не генерируется, то можно добавить блок else, который будет выполняеться при отсутствии генерации исключения.
    Ну и аналогично Java можно добавить finaly - данный блок будет выполняться всегда.

    class SomeExcption(Exception): pass

    try:
        raise SomeExceptoin()
    except SomeExctption as x:
        print x
    else:
        print исключение не возникло.

    import traceback

    И после исключения можно получать информацию.
        traceback_info = traceback.format_exc()

    Можно еще
        exception_type, value, tracebackk = sys.exc_info() - но здесь окончательно не разобрался.

--------------------------------------------------

With...as
    with <Выражение>[ as <Переменная>]:
        <Блок, в котором перехватываем исключения>

    Вначале вычисляется <Выражение>, которое должно возвращать объект, поддерживающий протокол. Этот объект должен иметь два метода: __enter__() и __exit__(). Метод __enter__() вызывается после создания объекта. Значение, возвращаемое этим методом, присваивается переменной, указанной после ключевого слова as. Если переменная не указана, возвращаемое значение игнорируется. Формат метода __enter__():

    __enter__(self)

    Далее выполняется выражения внутри тела инструкции with. Если при выполнении возникло исключение, то управление передается методу __exit__(). Метод имеет следующий формат:

    __exit__(self, <Тип исключения>, <Значение>, <Объект traceback>)

    Значения, доступные через последние три параметра, полностью эквивалентны значения, возвращаемых функции exc_info() из модуля sys. Если исключение обработано, метод должен вернуть значение True, в противном случае - False. Если метод возвращает False, то исключение передается вышестоящему обработчику.

    Если при выполнении выражений, расположенных внутри тела инструкции with, исключение не возникло, то управление все равно передается методу __exit__(). В этом случае последние три параметра будут содержать значение None. 

    Однако если произойдет исключение в <Выражение> - то ничего не перехватится. Т.е. если open() выкинет исключение, то оно не будет перехватано и нужно для этого добавлять try.
        try:
            with open("234") as file:
                print(file)
        except FileNotFoundError as e:
            print("FileNotFoundError _ 2")
            print(e)

--------------------------------------------------

Строки:
    Строки Unicode:
        s = u'SomeString'   # Характерно для Py2.x. А для Python3.x всё является Ubicode. Хотя такая запись тоже работает.
        s = ru'SomeString' - необрабатываемая строка. Так же и с R

        The opposite method of bytes.decode() is str.encode(), which returns a bytes representation of the Unicode string, encoded in the requested encoding.

        strr = u'Привет'
        strr_koi8r = strr.encode("KOI8-R")          # Кодировка
        print(strr_koi8r)                           # b'\xf0\xd2\xc9\xd7\xc5\xd4'
        strr_utf8 = strr_koi8r.decode("KOI8-R")     # Декодирование из KOI8-R. А вот как  b'\x80abc'.decode("utf-8", "strict")
        print(strr_utf8)
        strr.encode("utf8")     # b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82'
        strr.encode("utf16")    # b'\xff\xfe\x1f\x04@\x048\x042\x045\x04B\x04'

        len(strr)

    Разложить string в list
        list("some_stritn")

    B = bytearray(b'spam')
    B.extend(b'spam')
    B.decode()

    b'a string'.decode('ascii')  b'a string'.decode('utf-8')
        'a string'

    'a string'.encode('ascii')
        b'a string'

    from bitarray import bitarray
    bins = "01000001 01110011 01101011 01010000 01111001 01110100 01101000 01101111 01101110"
    bts = bitarray(bins)
    ascs = bts.tobytes().decode('ascii')

    chr(97) ---> a
    Обратная функция к ord()# ord('a') ---> 97 # Возвращает число символа.


    Регулярка:
        import re
        match = re.match("Regexp", "TargetStrWhereWillSearch")


    Python_3 уже читает в Unicode
    udata = open('somefile', 'r', encoding='UTF-8').read()

    convert byte-data to unicode like this:
        udata = bytedata.decode('UTF-8')

    Unicode data to character form using the opposite transform.
        bytedata = udata.encode('UTF-8')

    Python_2
        data = open('somefile', 'r').read()
        udata = unicode(data) # Для Python3 эквивалент str(text, 'utf-8'). Но правильнее как выше.



    Конвертирование
        bin() - преобразует число в бинарное представление в виде строки.
        hex() - преобразует число в шестнадцатеричное представление в виде строки
--------------------------------------------------

Кортежи:
    (1, 2, 3) или tuple("spam")

List:
    Списки - это изменяемые объекты.
        a = [1, 2, 3, 4] или list(...)
        a[0:2] = [5, 6] - замена, с нулевого до второго(исключительно). Даст [5, 6, 3, 4] - а можно и больше вставить, чем удаляем.
        a[0:2] = [] - удаление, с нулевого до второго. Даст [3, 4]
        a[1:1] = [6, 7] - вставка (вставит между нулевым и первым). Даст [3, 6, 7, 4]
        a[:1] = a - вставка, все что до 3го удалит и вставит содержимое a
        len(a)

        [3*x for x in vec if x > 3] # А если круглые скобки, то будет итератор. А не кортеж. Итератор возвращает значение при запросе методом next. При этом в памяти вся последоватлеьность не хранится, а генерируется при запросе.
        [{x: x**2} for x in vec] # Создается список словарей.
        [x*y for x in vec1 for y in vec2] #Если в конструкторе указано несколько блоков for, элементы второй последователь-ности перебираются для каждого элемента первой и т. д., то есть 
        перебираются все комбинации.
        [[x*y for x in vec1] for y in vec2] #А так будет совсем иной результат, для каждого элемента из второго цикла будет выполнен весь проход первого цикла.

Set
    set('abc') или {'a', 'b', 'c'}

Словари:
    {'a':1, 'b':2} или dict(a=1) #dict(short='dict', long='dictionary') #dict([(1, 1), (2, 4)])

    d = {a: a ** 2 for a in range(7)}

    dictt = {'f' : 1, 's' : 2, 't' : 3}
    del dictt['f']

Множественное присвоение.
    a, b = 1, 2

Распаковка:
    t = (1, 2, 3)
    a, b, c = t #Распаковка требует, чтоб слева стояло столько же элементов сколько в кортеже.


For:
    for i in a:
        ....

    range() - #В Python3 она полностью совпадает с поведением xrange.
    xrange() - #Удалена в Python3.

    else - выполняется, когда цикл (while/for) заканчивается в обычном/нормальном режиме. Если срабатывает break - то else не выполняется.

    Если коллекция закачивается (т.е. выход за пределы коллекции), то генерируется исключение IndexError - и for счиает, что закончилась наша псевдопоследоватлеьность.


Чтение из файла
    for line in open (’ script2 .ру ’) :    # Использование итератора файлового объекта для чтения по строкам. 
        print (line.upper () , end=’ ’)     # Современный способ. Т.к. используется генератор (а не чтение всего файла) - то экономно по памяти.

    for line in open(’script2 .ру’).readlines () : Эта версия считается устаревшей, из за чтения всего файла и расходования ресурсов. Загружает в память весь файл.
        print(line.upper(), end=’’)

    file = open('file.txt', 'w', encoding='utf-8')
    file.write(someText)
    file.close()
    text = open('file.txt', encoding='utf-8').read()
    len(text) #Количество символов

    raw = open('file.txt', 'rb').read() #Чтение байт.
    len(raw) #Количество байт.

    text.encode('utf-8') #В ручную декодировать в байты
    raw.decode('utf-8') #В ручную декодировать в строку.

    Для Windows
    myFile = open(r"C:\text.txt", 'w') # r - подовляет спец. символы и не нужно делать \\


Ввод/вывод:
    str() - переводит в строковое представление.
    repr() - тождественно ``

    str().rjust(3) / ljust() / center()
    print '%2d %3d %4d' % (x, x*x, x*x*x)

    f = open('/tnp/workfile', 'wb') # w - только для записи, r - только для чтения, a - для дописывания в конец, r+ для чтения и записи.


Stepik

        Операции
            Целочисленное деление // (усечение в меньшую сторону -5//2 = -3)
            Остаток от деления %
            Возведение в степень **

        Вечественные числа
            Записываются через точку.
            Вещественное деление через / (т.е. обычное деление)
            5e-1 = 0.5

Числа:
    Преобразования:
            int(3.14) => 3        
            float(3) => 3.0
            str(3.14) => 3.14
            3.14 + 4 => 7.14

    Округления
        import math
        math.floor(2.5) => 2 Ближайшее меньшее значение,
        math.floor(-2.5) => -3

        math.trunc(2.5) => 2 Усечение дробной части в строну нуля
        math.trunc(-2.5) => -2

        round(2.567, 2) => 2.57 #до двух знаков после запятой.

    Системы счисления
        oct(64), hex(64), bin(64) => ('0o100', '0x40', '0b1000000')
        int('64'), int('64', 8), int('64', 16)


Множества:
    По множествам МаркЛутц 2019 стр. 196
    

Многопоточка
Unicode
with ... as

----------------------------------------------------------------------
Приведение типов:
    int(some_str) или int(some_folat) - генерирует исключение ValueError. При этом если строка будет задана в виде float - то тоже будет ошибка.        
    int('0b100', 2) - переведёт в 10чную систему исчисления. Т.е. говорит из какой в 10ную.
        bin(), oct(), hex()
    float(some_str) или float(some_int)
    str(some_type)
    bool(3) - приведение типа к boolean
    list(some_str) - вернёт массив символов, из которых состоит строка.

----------------------------------------------------------------------
import os

filename = os.environ.get(’PYTHONSTARTUP’)
if filename and os.path.isfile(filename):
    execfile(filename)
------------------------
Преобразование
    int(), float(), long(), abs()
------------------------
Строка это массив.
    word = "Abcd"
    word = [0:2] -> "Ab" эксивалентно [:2].
    word = [-1] - последний символ или [-2:] последние 2а символа, или [:-2] кроме последних 2х
------------------------
    u"Hello World !"
    ur"Hello World !"
    s = unicode("Привет", "KOI8-R")
------------------------
    a[:] - копия всего списка
------------------------
    a.insert(2, -1)
------------------------
listt = [11, 22, 33, 44, 55, 55]
del listt[2] - удалите 3ий элменты
listt.pop(1) - извлечёт второй элемент.
listt.remove(55) - удаление по значению. Первый найденный
listt.sort()


listt1 = ['123', '33', '9']
listt1.sort(key=len) # Сорт меняет сам список.
print(listt1)
ll = sorted(listt1, reverse=True, key=len) # Возвращает новый список
------------------------
    str.isdigit
------------------------
    List comprehension вместо filter:
        nums = [10, 111, 102, 213, 314, 515]
        [n for n in nums if n % 2 == 1]
        #[x ** 2 for x in range(10)]
        #[x ** 2 if x % 2 == 0 else x ** 3 for x in range(10)]

        Возьми число и положи его в конец списка (list).

        Вложенные циклы (списочные выражения)


        Полные аналоги:
            Через List Comprehension:

                some_list = [1, 10, 100, 1000, 10000]
                matrix = [[x * y for x in some_list]
                            for y in range(1, 3)]
                print(matrix)

            Через цикл:

                res = []
                for y in range(1, 3):
                    tmp = []
                    for x in some_list:
                        tmp.append(x*y)
                    res.append(tmp)
                print(res)

        Второй аналог:
            matrix1 = [x * y for x in some_list
                                for y in range(1, 3)]  

            print(matrix1)
            res = []
            for x in some_list:    
                for y in range(1, 3):
                    res.append(x*y)
            print(res)


        Пример для вложенных объектов
            M = [[1,2,3], [4, 5, 6]]
            [col + 10 for row in M for col in row]

        Аналогично для словаря:
            countries = {country: capital for country, capital in [("Россия", "Москва"), ("Беларусь", "Минск"), ("Сербия", "Белград")]}
            Даст:
            #   {'Россия': 'Москва', 'Беларусь': 'Минск', 'Сербия': 'Белград'}

            In general,

                [f(x) if condition else g(x) for x in sequence]
                And, for list comprehensions with if conditions only,

                [f(x) for x in sequence if condition]

        А можно два условия:
            [x+y for x in 'spam' if x in 'sm' for y in 'SPAM' if y in ('P', 'A')]
------------------------
tables = [lambda x = x: x*10 for x in range(1, 11)]
------------------------
Форматирование строки.
    print('%2d %3d %4d' % (x, x*x, x*x*x))
    ---
    f'Results of the {year} {event}'
    ---
    print('{0} and {1}'.format('spam', 'eggs'))
------------------------
Ввод данных с консоли:
    some_var = input("Введите данныеЖ")
------------------------
Пример присванивания в цикле
    while (x := mapped.__next__()) is not None:
        print(x)
    ---
    while val := next(i):
        print('doing something here with value', val)
------------------------
    import random
    random.randrange(1, 1000)
------------------------
x = isinstance("Hello", (float, int, str, list, dict, tuple))

x = 10
print(type(x) == int)  # вернет True
y = "Hello"
print(type(y) == str)  # вернет True
------------------------
Подпроцессы - bash
    Run the command described by args. Wait for command to complete, then return a CompletedProcess instance.

    process = subprocess.run(['ls', '-l', '-a'], capture_output=True) 
        # capture_output=True захват вывода. В Байтах. Для текста нужно установить text=True
        # process.returncode - вернёт результат выполнения, вернее код.
        # check=True - если генерируемый процесс заверашется ошибкой, то будет выбрашено исключение CalledProcessError.
        # shell=True - то будут доступны переменные в вызываемой команде допустим $HOME
        # timeout=5 - время в сек. Время, которое дается на выполнение команды иначе исключение TimeoutExpired а процесс будет остановлен сигналом SIGKILL.

    Процесс, запущенный с использованием класса Popen, не блокирует выполнение скрипта.
        Эмуляция 
            $ output="$(dmesg | grep sda)"
        Будет выглядеть так:
            dmesg = subprocess.Popen(['dmesg'], stdout=subprocess.PIPE)     #Переводим вывод в Pipe
            grep = subprocess.Popen(['grep', 'sda'], stdin=dmesg.stdout)    #Вход делаем из вывода предыдущей команды.
            dmesg.stdout.close()                                            #Закрывается поток, так требует документация. Для того, чтоб первый процесс мог получить сигнал SIGPIPE
            output = grep.comunicate()[0]

Асинхронность
    https://imgvoid.medium.com/python-async-await-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D1%8F-%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F-%D0%B8-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0-f970e29854b3
    Приоритетная и кооперативная многозадачность
        - Вытесняющая многозадачность (приоритетная, preemptive multitasking) — когда переключать контекст решает планировщик: в задачах не указано место переключения, зато указаны таймауты.
            Например, многопоточность — это разделение задач по потокам. Ограничение Python Global Interpreter Lock (GIL) позволяет CPython выполнять байткод только одного потока за раз.
        - Невытесняющая многозадачность (совместная, cooperative multitasking) — когда переключать контекст решает сама задача: в коде явно указывается, когда вернуть выполнение планировщику. Например, асинхронный код переключает контекст оператором await в теле функции.

    Основы Python asyncio:
        В одном потоке запускается цикл событий Event Loop, он выполняет задачи-футуры Task (базовый класс Future). Футуры создаются из сопрограмм Coroutine и обещают отдать результат в будущем, после ожидания с await.

    Футура Task или корутина?
        Coroutine всегда нужен await!
            Chain of responsibilities & composite, нужно ждать результат в теле функции. Является возвращаемым значением (результатом вызова) асинхронного генератора: type(coro) == function, type(coro()) == coroutine
        Task не нужен await!
            Producer-Consumer и фоновые задачи, результат не нужно ждать в теле функции. Представляет будущий результат выполнения корутины, наследует базовый класс Future: asyncio.isfuture(Task()) == True

    Методы и объекты Python asyncio
        Event loop:
            asyncio.run(main()) — запуск event loop в Python 3.7+.
            asyncio.get_event_loop().run_until_complete(main()) — получение и запуск event loop в Python 3.7-.
            asyncio.get_event_loop().call_later(timeout, coro) — выполняет указанную корутину спустя указанную задержку.
            asyncio.wait_for(coro, timeout), async with asyncio.timeout(timeout) — указывает ограничение по времени для выполнения задания.
            asyncio.wait(tasks_iter, return_when, timeout) — Блокирует выполнение до достижения указанного условия. Низкоуровневый аналог gather, возвращает два контейнера, с завершенными и незавершенными задача. Для return_when доступны такие значения: FIRST_COMPLETED,FIRST_EXCEPTION, ALL_COMPLETED.
            await asyncio.gather(task(), coro()) — ждет завершения переданных футур и сопрограмм, возвращает одну общую футуру. Высокоуровневый аналог wait.
        Future:
            asyncio.create_task(coro()) — создает футуру Task и добавляет ее в конкурентную очередь задач.
            asyncio.ensure_future(coro()) — создание футуры в Python 3.7-.
            asyncio.Task.cancel() — останавливает футуру Task насильно.
        Queue:
            asyncio.Queue — создает очередь first in, first out.
            asyncio.Queue.get() — возвращает следующий элемент очереди.
            asyncio.Queue.put(x) — добавляет новый элемент в очередь.
            asyncio.Queue.join() — останавливает дальнейшее выполнение тела функции, пока очередь не опустеет.
            asyncio.Queue.task_done() — сообщает очереди, что очередной элемент обработан, и можно переходить к следующему в очереди.

    - async --- используется для объявления асинхронной функции. Это означает, что функция будет возвращать объект coroutine, который можно выполнить асинхронно.
    - await --- используется внутри асинхронной функции для ожидания результата другой асинхронной операции. Это позволяет основному потоку продолжить выполнение других задач, пока ожидается результат.

    https://www.pythontutorial.net/python-concurrency/python-async-await/
    - The async keyword creates a coroutine.
    - The await keyword pauses a coroutine.

    To run a coroutine, you need to execute it on an event loop. Prior to Python 3.7, you have to manually create an event loop to execute coroutines and close the event loop.
    However, since version 3.7, the asyncio library added some functions that simplify the event loop management.
    For example, you can use the asyncio.run() function to automatically create an event loop, run a coroutine, and close it.
        - It’s important to note that the asyncio.run() is designed to be the main entry point of an asyncio program.
        - Also, the asyncio.run() function only executes one coroutine which may call other coroutines and functions in the program.

    Summary:
        A coroutine is a regular function with the power of pausing a long-running operation, waiting for the result, and resuming from the paused point.
        Use async keyword to define a coroutine.
        Use await keyword to pause a coroutine.
        Use asyncio.run() function to automatically execute a coroutine on an event loop and manage an event loop.

        import asyncio

        async def square(number: int) -> int:
            return number*number

        result = asyncio.run(square(10))
        print(result)

        ----------------------

        import asyncio
 
        async def my_coroutine():
            print("Starting coroutine...")
            await asyncio.sleep(1)
            print("Coroutine finished!")
         
        async def main():
            await my_coroutine()
         
        asyncio.run(main())


-------------------------------------------
numbers = [1, 2, 3]
print(f"{numbers}, id = {id(numbers)}")
numbers += [4]
print(f"{numbers}, id = {id(numbers)}")

Вывод программы:
    [1, 2, 3], id = 2095932585856
    [1, 2, 3, 4], id = 2095932585856

Обратите внимание: операция присваивания (=) всегда создаёт новую переменную с новым идентификатором, даже для изменяемых типов данных:
    numbers = [1, 2, 3]
    print(f"{numbers}, id = {id(numbers)}")
    numbers = numbers + [4]
    print(f"{numbers}, id = {id(numbers)}")

    Вывод программы:
        [1, 2, 3], id = 1438332303232
        [1, 2, 3, 4], id = 1438341470336


----------------------------------
class set([iterable])
class frozenset([iterable])
Return a new set or frozenset object whose elements are taken from iterable. The elements of a set must be hashable. To represent sets of sets, the inner sets must be frozenset objects. If iterable is not specified, a new empty set is returned.

hashable
An object is hashable if it has a hash value which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same hash value.

Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.

Most of Python’s immutable built-in objects are hashable; mutable containers (such as lists or dictionaries) are not; immutable containers (such as tuples and frozensets) are only hashable if their elements are hashable. Objects which are instances of user-defined classes are hashable by default. They all compare unequal (except with themselves), and their hash value is derived from their id().