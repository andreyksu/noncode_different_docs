#-*- coding:utf-8 -*-

#  Проверяется импорт и добавление атрибута. Упор на порядок.

# Внимание, участвуют три модуля a, b, c.
# Центральный c - модуль. a и b импортируется.

from b_pack.a_pack import a_mod as modA

# from b_pack import b_mod as modBB  # Здесь упадёт, 
# Т.к. запустится код этого модуля. А внутри модуля b_mod будет вызван метод printStrrAA() модуля a_mod - который не найдет атрибут modA.strrAA т.к. он еще не добавлен.
# Главное метод модуля вызвать после добавления переменнной. Сделать это можно либо поздним импортированием, либо завернув в метод все вызовы модуля a_mod 

print(f'c_mod dir() = {dir()}') # Без аргумента выводит информацию для тек. окружения.

print(id(modA))         # См. что выводит здесь и то что выводится в модулe bb - это одно ID

modA.strrA='Modified value in other module' # Изменили переменную в импортированном модуле.
modA.strrAA='new bbbb'  # Добавили новую переменную в ИМПОРТИРОВАННЫЙ модуль! Ошибку не выдало. 
                        # При этом в др. модуле будет видна эта переменная, если модуль импортируется позже. Т.е. после этой строки. Если до этой строки, то будет ошибка, что такого атрибута нет.
                        # Но это если модуль вызывать где print делается сразу. 
modA.listtA.append(4)   # Изменили переменную в импортированном модуле.

modA.printOwnAttr()
modA.printStrrAA() # Просим модуль "a" - вывести переменную которую добавили здесь. Т.е. в "а" - этой переменной не было

from b_pack import b_mod as modBB    # См. комментарий к modA.strrAA='new bbbb'
