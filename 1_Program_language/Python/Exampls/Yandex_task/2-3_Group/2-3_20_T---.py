# Задача решена с учётом порядка подачи материала (методов, массивов/коллекций еще не было). Решал так если бы не знал перечисленного.

# Первая попытка, поптыка простого перебора. Где меняется r [0, 255] и m [0, inf] и даже для значений m=28 и r=119, что соответствуют нулевому блоку 1_865_535 получаем 28*119=3332 вычислений
# Вторая причина, слишком много вложенных циклов и условий. Да можно упростить если раскидать по методам, но даже с методами получается избыточно много условий и циклов.
# Вообще, конечно можно упростить и оптимизировать условия, часть вынести и объединить - но останется все равно сложно.

# n = 0
# m_n_0 = 0
h_n_1 = 0
# b_n = 6_122_802
tartget_b_n = 1_865_535
is_present = True
count = 0

for x in range(0, 1):
    count = 0
    tartget_b_n = int(input())
    for i in range(0, 255 + 1):
        m_n_0 = 0  # Нужно где то инкрементировать данную переменну. Это значение соответствует 255 вариантм r. Дальше должно быть m_n_0 = 1 и снова r от 0 до 255. Т.е. сверху нужно еще один цикл для m_n_0 но там бесконечный цикл.
        if x == 0:
            h_n = (37 * (m_n_0 + i)) % 256
            # print(f"h_n = {h_n}, i = {i}")
        else:
            h_n = (37 * (m_n_0 + i + h_n_1)) % 256

        if h_n >= 100:
            continue
        else:
            count += 1
            camputed_b_n = h_n + i * 256 + m_n_0 * 256**2
            if camputed_b_n > tartget_b_n:
                print("camputed_b_n > tartget_b_n")
                break
            else:
                while camputed_b_n <= tartget_b_n:
                    print(f"camputed_b_n = {camputed_b_n}")
                    if camputed_b_n == tartget_b_n:
                        h_n_1 = h_n
                        print("break... count = ", count)
                        break
                    else:
                        print(
                            f"h_n = {h_n}, i = {i}, camputed_b_n = {camputed_b_n}, m_n_0 = {m_n_0}"
                        )
                        m_n_0 += 1
                        camputed_b_n = h_n + i * 256 + m_n_0 * 256**2
                        print(
                            f"______h_n = {h_n}, i = {i}, camputed_b_n = {camputed_b_n}, m_n_0 = {m_n_0}"
                        )
    else:
        is_present = False  # Выполнится только при исчерпании последовательности для for и при break - else выполняться не будет.

print(is_present)
